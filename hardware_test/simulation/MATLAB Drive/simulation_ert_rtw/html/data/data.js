var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"simulation","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Main file","code":"//\n// File: ert_main.cpp\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include <stdio.h>              // This example main program uses printf/fflush\n#include \"simulation.h\"                // Model header file\n\n//\n// Associating rt_OneStep with a real-time clock or interrupt service routine\n// is what makes the generated code \"real-time\".  The function rt_OneStep is\n// always associated with the base rate of the model.  Subrates are managed\n// by the base rate from inside the generated code.  Enabling/disabling\n// interrupts and floating point context switches are target specific.  This\n// example code indicates where these should take place relative to executing\n// the generated code step function.  Overrun behavior should be tailored to\n// your application needs.  This example simply sets an error status in the\n// real-time model and returns from rt_OneStep.\n//\nvoid rt_OneStep(void);\nvoid rt_OneStep(void)\n{\n  static boolean_T OverrunFlag{ false };\n\n  // Disable interrupts here\n\n  // Check for overrun\n  if (OverrunFlag) {\n    rtmSetErrorStatus(simulation_M, \"Overrun\");\n    return;\n  }\n\n  OverrunFlag = true;\n\n  // Save FPU context here (if necessary)\n  // Re-enable timer or interrupt here\n  // Set model inputs here\n\n  // Step the model\n  simulation_step();\n\n  // Get model outputs here\n\n  // Indicate task complete\n  OverrunFlag = false;\n\n  // Disable interrupts here\n  // Restore FPU context here (if necessary)\n  // Enable interrupts here\n}\n\n//\n// The example main function illustrates what is required by your\n// application code to initialize, execute, and terminate the generated code.\n// Attaching rt_OneStep to a real-time clock is target specific. This example\n// illustrates how you do this relative to initializing the model.\n//\nint_T main(int_T argc, const char *argv[])\n{\n  // Unused arguments\n  (void)(argc);\n  (void)(argv);\n\n  // Initialize model\n  simulation_initialize();\n\n  // Simulating the model step behavior (in non real-time) to\n  //   simulate model behavior at stop time.\n\n  while ((rtmGetErrorStatus(simulation_M) == (nullptr)) && !rtmGetStopRequested\n         (simulation_M)) {\n    rt_OneStep();\n  }\n\n  // Terminate model\n  simulation_terminate();\n  return 0;\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"simulation.cpp","type":"source","group":"model","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// File: simulation.cpp\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"simulation.h\"\n#include \"simulation_types.h\"\n#include \"rtwtypes.h\"\n#include <cmath>\n#include \"simulation_private.h\"\n#include <stddef.h>\n#include <emmintrin.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rt_defines.h\"\n\n// Named constants for Chart: '<S5>/Discretizer'\nconst uint8_T simulation_IN_Detached{ 1U };\n\nconst uint8_T simulation_IN_Idle{ 2U };\n\nconst uint8_T simulation_IN_NO_ACTIVE_CHILD{ 0U };\n\nconst uint8_T simulation_IN_S0{ 3U };\n\nconst uint8_T simulation_IN_S1_Ignite{ 1U };\n\nconst uint8_T simulation_IN_S1_engaged{ 2U };\n\nconst uint8_T simulation_IN_S1_fire{ 4U };\n\nconst uint8_T simulation_IN_S2_Fire{ 5U };\n\n// Block signals (default storage)\nB_simulation_T simulation_B;\n\n// Continuous states\nX_simulation_T simulation_X;\n\n// Disabled State Vector\nXDis_simulation_T simulation_XDis;\n\n// Block states (default storage)\nDW_simulation_T simulation_DW;\n\n// External inputs (root inport signals with default storage)\nExtU_simulation_T simulation_U;\n\n// External outputs (root outports fed by signals with default storage)\nExtY_simulation_T simulation_Y;\n\n// Real-time model\nRT_MODEL_simulation_T simulation_M_{ };\n\nRT_MODEL_simulation_T *const simulation_M{ &simulation_M_ };\n\n// Forward declaration for local functions\nstatic boolean_T simulation_isequal_o(const real_T varargin_1[3], const real_T\n  varargin_2[3]);\nstatic void imuSensor_set_MagneticFieldNED(fusion_simulink_imuSensor_sim_T *obj,\n  const real_T val[3]);\nstatic boolean_T simulation_isequal_oi(const real_T varargin_1[9], const real_T\n  varargin_2[9]);\nstatic boolean_T simulation_isequal(const real_T varargin_1[2], const real_T\n  varargin_2[2]);\nstatic void IMUSensorParameters_updateSyste(real_T obj_MeasurementRange, real_T\n  obj_Resolution, const real_T obj_ConstantBias[3], const real_T\n  obj_AxesMisalignment[9], const real_T obj_NoiseDensity[3], const real_T\n  obj_BiasInstability[3], const real_T obj_RandomWalk[3], real_T\n  obj_BiasInstabilityCoefficients, const real_T obj_BiasInstabilityCoefficien_0\n  [2], const char_T obj_NoiseType_Value[12], const real_T obj_TemperatureBias[3],\n  const real_T obj_TemperatureScaleFactor[3], g_fusion_internal_Acceleromet_T\n  *sobj);\nstatic void IMUSensorParameters_updateSys_o(real_T obj_MeasurementRange, real_T\n  obj_Resolution, const real_T obj_ConstantBias[3], const real_T\n  obj_AxesMisalignment[9], const real_T obj_NoiseDensity[3], const real_T\n  obj_BiasInstability[3], const real_T obj_RandomWalk[3], real_T\n  obj_BiasInstabilityCoefficients, const real_T obj_BiasInstabilityCoefficien_0\n  [2], const char_T obj_NoiseType_Value[12], const real_T obj_TemperatureBias[3],\n  const real_T obj_TemperatureScaleFactor[3], const real_T obj_AccelerationBias\n  [3], h_fusion_internal_GyroscopeSi_T *sobj);\nstatic void IMUSensorParameters_updateSy_oi(real_T obj_MeasurementRange, real_T\n  obj_Resolution, const real_T obj_ConstantBias[3], const real_T\n  obj_AxesMisalignment[9], const real_T obj_NoiseDensity[3], const real_T\n  obj_BiasInstability[3], const real_T obj_RandomWalk[3], real_T\n  obj_BiasInstabilityCoefficients, const real_T obj_BiasInstabilityCoefficien_0\n  [2], const char_T obj_NoiseType_Value[12], const real_T obj_TemperatureBias[3],\n  const real_T obj_TemperatureScaleFactor[3], i_fusion_internal_Magnetomete_T\n  *sobj);\nstatic boolean_T simulation_vectorAny(const boolean_T x_data[], const int32_T\n  x_size[2]);\nstatic void simulat_genrand_uint32_vector_o(uint32_T mt[625], uint32_T u[2]);\nstatic real_T simulation_genrandu_o(uint32_T mt[625]);\nstatic void simulation_filter(real_T b, real_T a[2], const real_T x[3], const\n  real_T zi[3], real_T y[3], real_T zf[3]);\nstatic void simulation_SystemCore_step_o(g_fusion_internal_Acceleromet_T *obj,\n  const real_T varargin_1[3], const real_T varargin_2[9], const real_T\n  varargin_3[9], real_T varargout_1[3]);\nstatic void simulation_SystemCore_step_oi(h_fusion_internal_GyroscopeSi_T *obj,\n  const real_T varargin_1[3], const real_T varargin_2[3], const real_T\n  varargin_3[9], const real_T varargin_4[9], real_T varargout_1[3]);\nstatic void simulation_imuSensor_stepImpl(fusion_simulink_imuSensor_sim_T *obj,\n  const real_T la[3], const real_T av[3], const real_T o[4], real_T a[3], real_T\n  g[3], real_T m[3]);\nstatic void simulation_SystemCore_step(fusion_simulink_imuSensor_sim_T *obj,\n  const real_T varargin_1[3], const real_T varargin_2[3], const real_T\n  varargin_3[4], real_T varargout_1[3], real_T varargout_2[3], real_T\n  varargout_3[3]);\nstatic void simulation_SystemCore_setup(fusion_simulink_imuSensor_sim_T *obj);\nstatic void simulat_IMUSensorBase_resetImpl(fusion_simulink_imuSensor_sim_T *obj);\nstatic void rate_scheduler(void);\n\n//\n//         This function updates active task flag for each subrate.\n//         The function is called at model base rate, hence the\n//         generated code self-manages all its subrates.\n//\nstatic void rate_scheduler(void)\n{\n  // Compute which subrates run during the next base time step.  Subrates\n  //  are an integer multiple of the base rate counter.  Therefore, the subtask\n  //  counter is reset when it reaches its limit (zero means run).\n\n  (simulation_M->Timing.TaskCounters.TID[2])++;\n  if ((simulation_M->Timing.TaskCounters.TID[2]) > 49) {// Sample time: [0.05s, 0.0s] \n    simulation_M->Timing.TaskCounters.TID[2] = 0;\n  }\n}\n\n// Projection for root system: '<Root>'\nvoid simulation_projection(void)\n{\n  NeslSimulationData *simulationData;\n  NeslSimulator *simulator;\n  NeuDiagnosticManager *diagnosticManager;\n  NeuDiagnosticTree *diagnosticTree;\n  char *msg;\n  real_T tmp_0[20];\n  real_T time;\n  int32_T tmp_2;\n  int_T tmp_1[6];\n  boolean_T tmp;\n\n  // Projection for SimscapeExecutionBlock: '<S69>/STATE_1'\n  simulationData = static_cast<NeslSimulationData *>\n    (simulation_DW.STATE_1_SimData);\n  time = simulation_M->Timing.t[0];\n  simulationData->mData->mTime.mN = 1;\n  simulationData->mData->mTime.mX = &time;\n  simulationData->mData->mContStates.mN = 26;\n  simulationData->mData->mContStates.mX =\n    &simulation_X.simulationPlantRocket_BodyFree_[0];\n  simulationData->mData->mDiscStates.mN = 0;\n  simulationData->mData->mDiscStates.mX = &simulation_DW.STATE_1_Discrete;\n  simulationData->mData->mModeVector.mN = 1;\n  simulationData->mData->mModeVector.mX = &simulation_DW.STATE_1_Modes;\n  tmp = false;\n  simulationData->mData->mFoundZcEvents = tmp;\n  simulationData->mData->mIsMajorTimeStep = rtmIsMajorTimeStep(simulation_M);\n  tmp = false;\n  simulationData->mData->mIsSolverAssertCheck = tmp;\n  simulationData->mData->mIsSolverCheckingCIC = false;\n  tmp = rtsiIsSolverComputingJacobian(&simulation_M->solverInfo);\n  simulationData->mData->mIsComputingJacobian = tmp;\n  simulationData->mData->mIsEvaluatingF0 = false;\n  simulationData->mData->mIsSolverRequestingReset = false;\n  simulationData->mData->mIsModeUpdateTimeStep = rtsiIsModeUpdateTimeStep\n    (&simulation_M->solverInfo);\n  tmp_1[0] = 0;\n  tmp_0[0] = simulation_B.INPUT_4_1_1[0];\n  tmp_0[1] = simulation_B.INPUT_4_1_1[1];\n  tmp_0[2] = simulation_B.INPUT_4_1_1[2];\n  tmp_0[3] = simulation_B.INPUT_4_1_1[3];\n  tmp_1[1] = 4;\n  tmp_0[4] = simulation_B.INPUT_5_1_1[0];\n  tmp_0[5] = simulation_B.INPUT_5_1_1[1];\n  tmp_0[6] = simulation_B.INPUT_5_1_1[2];\n  tmp_0[7] = simulation_B.INPUT_5_1_1[3];\n  tmp_1[2] = 8;\n  tmp_0[8] = simulation_B.INPUT_1_1_1[0];\n  tmp_0[9] = simulation_B.INPUT_1_1_1[1];\n  tmp_0[10] = simulation_B.INPUT_1_1_1[2];\n  tmp_0[11] = simulation_B.INPUT_1_1_1[3];\n  tmp_1[3] = 12;\n  tmp_0[12] = simulation_B.INPUT_2_1_1[0];\n  tmp_0[13] = simulation_B.INPUT_2_1_1[1];\n  tmp_0[14] = simulation_B.INPUT_2_1_1[2];\n  tmp_0[15] = simulation_B.INPUT_2_1_1[3];\n  tmp_1[4] = 16;\n  tmp_0[16] = simulation_B.INPUT_3_1_1[0];\n  tmp_0[17] = simulation_B.INPUT_3_1_1[1];\n  tmp_0[18] = simulation_B.INPUT_3_1_1[2];\n  tmp_0[19] = simulation_B.INPUT_3_1_1[3];\n  tmp_1[5] = 20;\n  simulationData->mData->mInputValues.mN = 20;\n  simulationData->mData->mInputValues.mX = &tmp_0[0];\n  simulationData->mData->mInputOffsets.mN = 6;\n  simulationData->mData->mInputOffsets.mX = &tmp_1[0];\n  simulator = static_cast<NeslSimulator *>(simulation_DW.STATE_1_Simulator);\n  diagnosticManager = static_cast<NeuDiagnosticManager *>\n    (simulation_DW.STATE_1_DiagMgr);\n  diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\n  tmp_2 = ne_simulator_method(simulator, NESL_SIM_PROJECTION, simulationData,\n    diagnosticManager);\n  if (tmp_2 != 0) {\n    tmp = error_buffer_is_empty(rtmGetErrorStatus(simulation_M));\n    if (tmp) {\n      msg = rtw_diagnostics_msg(diagnosticTree);\n      rtmSetErrorStatus(simulation_M, msg);\n    }\n  }\n\n  // End of Projection for SimscapeExecutionBlock: '<S69>/STATE_1'\n}\n\n//\n// This function updates continuous states using the ODE3 fixed-step\n// solver algorithm\n//\nstatic void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\n{\n  // Solver Matrices\n  static const real_T rt_ODE3_A[3]{\n    1.0/2.0, 3.0/4.0, 1.0\n  };\n\n  static const real_T rt_ODE3_B[3][3]{\n    { 1.0/2.0, 0.0, 0.0 },\n\n    { 0.0, 3.0/4.0, 0.0 },\n\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\n  };\n\n  time_T t { rtsiGetT(si) };\n\n  time_T tnew { rtsiGetSolverStopTime(si) };\n\n  time_T h { rtsiGetStepSize(si) };\n\n  real_T *x { rtsiGetContStates(si) };\n\n  ODE3_IntgData *id { static_cast<ODE3_IntgData *>(rtsiGetSolverData(si)) };\n\n  real_T *y { id->y };\n\n  real_T *f0 { id->f[0] };\n\n  real_T *f1 { id->f[1] };\n\n  real_T *f2 { id->f[2] };\n\n  real_T hB[3];\n  int_T i;\n  int_T nXc { 30 };\n\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n  // Save the state values at time t in y, we'll use x as ynew.\n  (void) std::memcpy(y, x,\n                     static_cast<uint_T>(nXc)*sizeof(real_T));\n\n  // Assumes that rtsiSetT and ModelOutputs are up-to-date\n  // f0 = f(t,y)\n  rtsiSetdX(si, f0);\n  simulation_derivatives();\n\n  // f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*));\n  hB[0] = h * rt_ODE3_B[0][0];\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\n  rtsiSetdX(si, f1);\n  simulation_step();\n  simulation_derivatives();\n\n  // f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*));\n  for (i = 0; i <= 1; i++) {\n    hB[i] = h * rt_ODE3_B[1][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\n  rtsiSetdX(si, f2);\n  simulation_step();\n  simulation_derivatives();\n\n  // tnew = t + hA(3);\n  // ynew = y + f*hB(:,3);\n  for (i = 0; i <= 2; i++) {\n    hB[i] = h * rt_ODE3_B[2][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\n  }\n\n  rtsiSetT(si, tnew);\n  simulation_step();\n  simulation_projection();\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  if (std::isnan(u0) || std::isnan(u1)) {\n    y = (rtNaN);\n  } else if (std::isinf(u0) && std::isinf(u1)) {\n    int32_T tmp;\n    int32_T tmp_0;\n    if (u1 > 0.0) {\n      tmp = 1;\n    } else {\n      tmp = -1;\n    }\n\n    if (u0 > 0.0) {\n      tmp_0 = 1;\n    } else {\n      tmp_0 = -1;\n    }\n\n    y = std::atan2(static_cast<real_T>(tmp_0), static_cast<real_T>(tmp));\n  } else if (u1 == 0.0) {\n    if (u0 > 0.0) {\n      y = RT_PI / 2.0;\n    } else if (u0 < 0.0) {\n      y = -(RT_PI / 2.0);\n    } else {\n      y = 0.0;\n    }\n  } else {\n    y = std::atan2(u0, u1);\n  }\n\n  return y;\n}\n\nstatic boolean_T simulation_isequal_o(const real_T varargin_1[3], const real_T\n  varargin_2[3])\n{\n  int32_T b_k;\n  boolean_T exitg1;\n  boolean_T p;\n  boolean_T p_0;\n  p = false;\n  p_0 = true;\n  b_k = 0;\n  exitg1 = false;\n  while ((!exitg1) && (b_k < 3)) {\n    if (!(varargin_1[b_k] == varargin_2[b_k])) {\n      p_0 = false;\n      exitg1 = true;\n    } else {\n      b_k++;\n    }\n  }\n\n  if (p_0) {\n    p = true;\n  }\n\n  return p;\n}\n\nstatic void imuSensor_set_MagneticFieldNED(fusion_simulink_imuSensor_sim_T *obj,\n  const real_T val[3])\n{\n  boolean_T flag;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  flag = (obj->isInitialized == 1);\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj->TunablePropsChanged = true;\n    obj->tunablePropertyChanged[2] = true;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  obj->MagneticField[0] = val[0];\n  obj->MagneticField[1] = val[1];\n  obj->MagneticField[2] = val[2];\n}\n\nstatic boolean_T simulation_isequal_oi(const real_T varargin_1[9], const real_T\n  varargin_2[9])\n{\n  int32_T b_k;\n  boolean_T exitg1;\n  boolean_T p;\n  boolean_T p_0;\n  p = false;\n  p_0 = true;\n  b_k = 0;\n  exitg1 = false;\n  while ((!exitg1) && (b_k < 9)) {\n    if (!(varargin_1[b_k] == varargin_2[b_k])) {\n      p_0 = false;\n      exitg1 = true;\n    } else {\n      b_k++;\n    }\n  }\n\n  if (p_0) {\n    p = true;\n  }\n\n  return p;\n}\n\nstatic boolean_T simulation_isequal(const real_T varargin_1[2], const real_T\n  varargin_2[2])\n{\n  int32_T b_k;\n  boolean_T exitg1;\n  boolean_T p;\n  boolean_T p_0;\n  p = false;\n  p_0 = true;\n  b_k = 0;\n  exitg1 = false;\n  while ((!exitg1) && (b_k < 2)) {\n    if (!(varargin_1[b_k] == varargin_2[b_k])) {\n      p_0 = false;\n      exitg1 = true;\n    } else {\n      b_k++;\n    }\n  }\n\n  if (p_0) {\n    p = true;\n  }\n\n  return p;\n}\n\nstatic void IMUSensorParameters_updateSyste(real_T obj_MeasurementRange, real_T\n  obj_Resolution, const real_T obj_ConstantBias[3], const real_T\n  obj_AxesMisalignment[9], const real_T obj_NoiseDensity[3], const real_T\n  obj_BiasInstability[3], const real_T obj_RandomWalk[3], real_T\n  obj_BiasInstabilityCoefficients, const real_T obj_BiasInstabilityCoefficien_0\n  [2], const char_T obj_NoiseType_Value[12], const real_T obj_TemperatureBias[3],\n  const real_T obj_TemperatureScaleFactor[3], g_fusion_internal_Acceleromet_T\n  *sobj)\n{\n  boolean_T flag;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  flag = (sobj->isInitialized == 1);\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[0] = true;\n  }\n\n  sobj->MeasurementRange = obj_MeasurementRange;\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[1] = true;\n  }\n\n  sobj->Resolution = obj_Resolution;\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[2] = true;\n  }\n\n  sobj->ConstantBias[0] = obj_ConstantBias[0];\n  sobj->ConstantBias[1] = obj_ConstantBias[1];\n  sobj->ConstantBias[2] = obj_ConstantBias[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[3] = true;\n  }\n\n  for (int32_T i{0}; i < 9; i++) {\n    sobj->AxesMisalignment[i] = obj_AxesMisalignment[i];\n  }\n\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[4] = true;\n  }\n\n  sobj->NoiseDensity[0] = obj_NoiseDensity[0];\n  sobj->NoiseDensity[1] = obj_NoiseDensity[1];\n  sobj->NoiseDensity[2] = obj_NoiseDensity[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[5] = true;\n  }\n\n  sobj->BiasInstability[0] = obj_BiasInstability[0];\n  sobj->BiasInstability[1] = obj_BiasInstability[1];\n  sobj->BiasInstability[2] = obj_BiasInstability[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[6] = true;\n  }\n\n  sobj->RandomWalk[0] = obj_RandomWalk[0];\n  sobj->RandomWalk[1] = obj_RandomWalk[1];\n  sobj->RandomWalk[2] = obj_RandomWalk[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[7] = true;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  sobj->BiasInstabilityCoefficients.Numerator = obj_BiasInstabilityCoefficients;\n  sobj->BiasInstabilityCoefficients.Denominator[0] =\n    obj_BiasInstabilityCoefficien_0[0];\n  sobj->BiasInstabilityCoefficients.Denominator[1] =\n    obj_BiasInstabilityCoefficien_0[1];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[8] = true;\n  }\n\n  for (int32_T i{0}; i < 12; i++) {\n    sobj->NoiseType.Value[i] = obj_NoiseType_Value[i];\n  }\n\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[9] = true;\n  }\n\n  sobj->TemperatureBias[0] = obj_TemperatureBias[0];\n  sobj->TemperatureBias[1] = obj_TemperatureBias[1];\n  sobj->TemperatureBias[2] = obj_TemperatureBias[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[10] = true;\n  }\n\n  sobj->TemperatureScaleFactor[0] = obj_TemperatureScaleFactor[0];\n  sobj->TemperatureScaleFactor[1] = obj_TemperatureScaleFactor[1];\n  sobj->TemperatureScaleFactor[2] = obj_TemperatureScaleFactor[2];\n}\n\nstatic void IMUSensorParameters_updateSys_o(real_T obj_MeasurementRange, real_T\n  obj_Resolution, const real_T obj_ConstantBias[3], const real_T\n  obj_AxesMisalignment[9], const real_T obj_NoiseDensity[3], const real_T\n  obj_BiasInstability[3], const real_T obj_RandomWalk[3], real_T\n  obj_BiasInstabilityCoefficients, const real_T obj_BiasInstabilityCoefficien_0\n  [2], const char_T obj_NoiseType_Value[12], const real_T obj_TemperatureBias[3],\n  const real_T obj_TemperatureScaleFactor[3], const real_T obj_AccelerationBias\n  [3], h_fusion_internal_GyroscopeSi_T *sobj)\n{\n  boolean_T flag;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  flag = (sobj->isInitialized == 1);\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[0] = true;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  sobj->AccelerationBias[0] = obj_AccelerationBias[0];\n  sobj->AccelerationBias[1] = obj_AccelerationBias[1];\n  sobj->AccelerationBias[2] = obj_AccelerationBias[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[1] = true;\n  }\n\n  sobj->MeasurementRange = obj_MeasurementRange;\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[2] = true;\n  }\n\n  sobj->Resolution = obj_Resolution;\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[3] = true;\n  }\n\n  sobj->ConstantBias[0] = obj_ConstantBias[0];\n  sobj->ConstantBias[1] = obj_ConstantBias[1];\n  sobj->ConstantBias[2] = obj_ConstantBias[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[4] = true;\n  }\n\n  for (int32_T i{0}; i < 9; i++) {\n    sobj->AxesMisalignment[i] = obj_AxesMisalignment[i];\n  }\n\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[5] = true;\n  }\n\n  sobj->NoiseDensity[0] = obj_NoiseDensity[0];\n  sobj->NoiseDensity[1] = obj_NoiseDensity[1];\n  sobj->NoiseDensity[2] = obj_NoiseDensity[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[6] = true;\n  }\n\n  sobj->BiasInstability[0] = obj_BiasInstability[0];\n  sobj->BiasInstability[1] = obj_BiasInstability[1];\n  sobj->BiasInstability[2] = obj_BiasInstability[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[7] = true;\n  }\n\n  sobj->RandomWalk[0] = obj_RandomWalk[0];\n  sobj->RandomWalk[1] = obj_RandomWalk[1];\n  sobj->RandomWalk[2] = obj_RandomWalk[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[8] = true;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  sobj->BiasInstabilityCoefficients.Numerator = obj_BiasInstabilityCoefficients;\n  sobj->BiasInstabilityCoefficients.Denominator[0] =\n    obj_BiasInstabilityCoefficien_0[0];\n  sobj->BiasInstabilityCoefficients.Denominator[1] =\n    obj_BiasInstabilityCoefficien_0[1];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[9] = true;\n  }\n\n  for (int32_T i{0}; i < 12; i++) {\n    sobj->NoiseType.Value[i] = obj_NoiseType_Value[i];\n  }\n\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[10] = true;\n  }\n\n  sobj->TemperatureBias[0] = obj_TemperatureBias[0];\n  sobj->TemperatureBias[1] = obj_TemperatureBias[1];\n  sobj->TemperatureBias[2] = obj_TemperatureBias[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[11] = true;\n  }\n\n  sobj->TemperatureScaleFactor[0] = obj_TemperatureScaleFactor[0];\n  sobj->TemperatureScaleFactor[1] = obj_TemperatureScaleFactor[1];\n  sobj->TemperatureScaleFactor[2] = obj_TemperatureScaleFactor[2];\n}\n\nstatic void IMUSensorParameters_updateSy_oi(real_T obj_MeasurementRange, real_T\n  obj_Resolution, const real_T obj_ConstantBias[3], const real_T\n  obj_AxesMisalignment[9], const real_T obj_NoiseDensity[3], const real_T\n  obj_BiasInstability[3], const real_T obj_RandomWalk[3], real_T\n  obj_BiasInstabilityCoefficients, const real_T obj_BiasInstabilityCoefficien_0\n  [2], const char_T obj_NoiseType_Value[12], const real_T obj_TemperatureBias[3],\n  const real_T obj_TemperatureScaleFactor[3], i_fusion_internal_Magnetomete_T\n  *sobj)\n{\n  boolean_T flag;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  flag = (sobj->isInitialized == 1);\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[0] = true;\n  }\n\n  sobj->MeasurementRange = obj_MeasurementRange;\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[1] = true;\n  }\n\n  sobj->Resolution = obj_Resolution;\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[2] = true;\n  }\n\n  sobj->ConstantBias[0] = obj_ConstantBias[0];\n  sobj->ConstantBias[1] = obj_ConstantBias[1];\n  sobj->ConstantBias[2] = obj_ConstantBias[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[3] = true;\n  }\n\n  for (int32_T i{0}; i < 9; i++) {\n    sobj->AxesMisalignment[i] = obj_AxesMisalignment[i];\n  }\n\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[4] = true;\n  }\n\n  sobj->NoiseDensity[0] = obj_NoiseDensity[0];\n  sobj->NoiseDensity[1] = obj_NoiseDensity[1];\n  sobj->NoiseDensity[2] = obj_NoiseDensity[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[5] = true;\n  }\n\n  sobj->BiasInstability[0] = obj_BiasInstability[0];\n  sobj->BiasInstability[1] = obj_BiasInstability[1];\n  sobj->BiasInstability[2] = obj_BiasInstability[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[6] = true;\n  }\n\n  sobj->RandomWalk[0] = obj_RandomWalk[0];\n  sobj->RandomWalk[1] = obj_RandomWalk[1];\n  sobj->RandomWalk[2] = obj_RandomWalk[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[7] = true;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  sobj->BiasInstabilityCoefficients.Numerator = obj_BiasInstabilityCoefficients;\n  sobj->BiasInstabilityCoefficients.Denominator[0] =\n    obj_BiasInstabilityCoefficien_0[0];\n  sobj->BiasInstabilityCoefficients.Denominator[1] =\n    obj_BiasInstabilityCoefficien_0[1];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[8] = true;\n  }\n\n  for (int32_T i{0}; i < 12; i++) {\n    sobj->NoiseType.Value[i] = obj_NoiseType_Value[i];\n  }\n\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[9] = true;\n  }\n\n  sobj->TemperatureBias[0] = obj_TemperatureBias[0];\n  sobj->TemperatureBias[1] = obj_TemperatureBias[1];\n  sobj->TemperatureBias[2] = obj_TemperatureBias[2];\n  if (flag) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    sobj->TunablePropsChanged = true;\n    sobj->tunablePropertyChanged[10] = true;\n  }\n\n  sobj->TemperatureScaleFactor[0] = obj_TemperatureScaleFactor[0];\n  sobj->TemperatureScaleFactor[1] = obj_TemperatureScaleFactor[1];\n  sobj->TemperatureScaleFactor[2] = obj_TemperatureScaleFactor[2];\n}\n\nstatic boolean_T simulation_vectorAny(const boolean_T x_data[], const int32_T\n  x_size[2])\n{\n  int32_T b_k;\n  boolean_T exitg1;\n  boolean_T y;\n  y = false;\n  b_k = 0;\n  exitg1 = false;\n  while ((!exitg1) && (b_k <= x_size[1] - 1)) {\n    boolean_T b;\n    b = !x_data[b_k];\n    if (!b) {\n      y = true;\n      exitg1 = true;\n    } else {\n      b_k++;\n    }\n  }\n\n  return y;\n}\n\nstatic void simulat_genrand_uint32_vector_o(uint32_T mt[625], uint32_T u[2])\n{\n  for (int32_T b_j{0}; b_j < 2; b_j++) {\n    uint32_T mti;\n    uint32_T y;\n    mti = mt[624] + 1U;\n    if (mti >= 625U) {\n      for (int32_T b_kk{0}; b_kk < 227; b_kk++) {\n        // Start for MATLABSystem: '<S17>/IMU'\n        y = (mt[b_kk + 1] & 2147483647U) | (mt[b_kk] & 2147483648U);\n        if ((y & 1U) == 0U) {\n          mti = y >> 1U;\n        } else {\n          mti = y >> 1U ^ 2567483615U;\n        }\n\n        mt[b_kk] = mt[b_kk + 397] ^ mti;\n      }\n\n      for (int32_T b_kk{0}; b_kk < 396; b_kk++) {\n        // Start for MATLABSystem: '<S17>/IMU'\n        y = (mt[b_kk + 227] & 2147483648U) | (mt[b_kk + 228] & 2147483647U);\n        if ((y & 1U) == 0U) {\n          mti = y >> 1U;\n        } else {\n          mti = y >> 1U ^ 2567483615U;\n        }\n\n        mt[b_kk + 227] = mt[b_kk] ^ mti;\n      }\n\n      y = (mt[623] & 2147483648U) | (mt[0] & 2147483647U);\n\n      // Start for MATLABSystem: '<S17>/IMU'\n      if ((y & 1U) == 0U) {\n        mti = y >> 1U;\n      } else {\n        mti = y >> 1U ^ 2567483615U;\n      }\n\n      mt[623] = mt[396] ^ mti;\n      mti = 1U;\n    }\n\n    y = mt[static_cast<int32_T>(mti) - 1];\n    mt[624] = mti;\n    y ^= y >> 11U;\n    y ^= y << 7U & 2636928640U;\n    y ^= y << 15U & 4022730752U;\n    y ^= y >> 18U;\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    u[b_j] = y;\n  }\n}\n\nstatic real_T simulation_genrandu_o(uint32_T mt[625])\n{\n  real_T r;\n  int32_T exitg1;\n  int32_T k;\n  int32_T tmp;\n  uint32_T b_u[2];\n  uint32_T r_0;\n  boolean_T b_isvalid;\n  boolean_T exitg2;\n\n  // ========================= COPYRIGHT NOTICE ============================\n  //  This is a uniform (0,1) pseudorandom number generator based on:\n  //\n  //  A C-program for MT19937, with initialization improved 2002/1/26.\n  //  Coded by Takuji Nishimura and Makoto Matsumoto.\n  //\n  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n  //  All rights reserved.\n  //\n  //  Redistribution and use in source and binary forms, with or without\n  //  modification, are permitted provided that the following conditions\n  //  are met:\n  //\n  //    1. Redistributions of source code must retain the above copyright\n  //       notice, this list of conditions and the following disclaimer.\n  //\n  //    2. Redistributions in binary form must reproduce the above copyright\n  //       notice, this list of conditions and the following disclaimer\n  //       in the documentation and/or other materials provided with the\n  //       distribution.\n  //\n  //    3. The names of its contributors may not be used to endorse or\n  //       promote products derived from this software without specific\n  //       prior written permission.\n  //\n  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  //  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  //\n  // =============================   END   =================================\n  do {\n    exitg1 = 0;\n    simulat_genrand_uint32_vector_o(mt, b_u);\n    r = (static_cast<real_T>(b_u[0] >> 5U) * 6.7108864E+7 + static_cast<real_T>\n         (b_u[1] >> 6U)) * 1.1102230246251565E-16;\n    if (r == 0.0) {\n      if ((mt[624] >= 1U) && (mt[624] < 625U)) {\n        b_isvalid = false;\n        k = 0;\n        exitg2 = false;\n        while ((!exitg2) && (k + 1 < 625)) {\n          if (mt[k] == 0U) {\n            k++;\n          } else {\n            b_isvalid = true;\n            exitg2 = true;\n          }\n        }\n      } else {\n        b_isvalid = false;\n      }\n\n      if (!b_isvalid) {\n        r_0 = 67U;\n        mt[0] = 67U;\n        for (k = 0; k < 623; k++) {\n          tmp = k + 1;\n          r_0 = (r_0 >> 30U ^ r_0) * 1812433253U + static_cast<uint32_T>(tmp);\n          mt[k + 1] = r_0;\n        }\n\n        mt[624] = 624U;\n      }\n    } else {\n      exitg1 = 1;\n    }\n  } while (exitg1 == 0);\n\n  return r;\n}\n\nstatic void simulation_filter(real_T b, real_T a[2], const real_T x[3], const\n  real_T zi[3], real_T y[3], real_T zf[3])\n{\n  // Start for MATLABSystem: '<S17>/IMU'\n  if ((!std::isinf(a[0])) && (!std::isnan(a[0])) && (!(a[0] == 0.0)) && (a[0] !=\n       1.0)) {\n    b /= a[0];\n    a[1] /= a[0];\n  }\n\n  y[0] = zi[0];\n  y[1] = zi[1];\n  y[2] = zi[2];\n  y[0] += x[0] * b;\n  zf[0] = -y[0] * a[1];\n  y[1] += x[1] * b;\n  zf[1] = -y[1] * a[1];\n  y[2] += x[2] * b;\n  zf[2] = -y[2] * a[1];\n\n  // End of Start for MATLABSystem: '<S17>/IMU'\n}\n\nstatic void simulation_SystemCore_step_o(g_fusion_internal_Acceleromet_T *obj,\n  const real_T varargin_1[3], const real_T varargin_2[9], const real_T\n  varargin_3[9], real_T varargout_1[3])\n{\n  static const char_T tmp_2[12]{ 'd', 'o', 'u', 'b', 'l', 'e', '-', 's', 'i',\n    'd', 'e', 'd' };\n\n  __m128d tmp_0;\n  __m128d tmp_1;\n  real_T B[3];\n  real_T c[3];\n  real_T obj_0[3];\n  real_T y[3];\n  real_T obj_1[2];\n  real_T maximum;\n  real_T tmp;\n  real_T whiteNoiseDrift_idx_1;\n  real_T whiteNoiseDrift_idx_2;\n  real_T x_idx_0;\n  real_T x_idx_1;\n  real_T x_idx_2;\n  real_T x_idx_3;\n  real_T x_idx_4;\n  real_T x_idx_5;\n  int32_T b;\n  int32_T b_kstr;\n  int32_T exitg1;\n  int32_T kstr;\n  int32_T tmp_size_idx_1;\n  int8_T b_data[3];\n  int8_T tmp_data[3];\n  boolean_T equal;\n  boolean_T guard1;\n  if (obj->isInitialized != 1) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj->isInitialized = 1;\n    for (b_kstr = 0; b_kstr <= 6; b_kstr += 2) {\n      // Start for MATLABSystem: '<S17>/IMU'\n      tmp_1 = _mm_loadu_pd(&obj->AxesMisalignment[b_kstr]);\n      tmp_1 = _mm_div_pd(tmp_1, _mm_set1_pd(100.0));\n\n      // Start for MATLABSystem: '<S17>/IMU'\n      _mm_storeu_pd(&obj->pGain[b_kstr], tmp_1);\n    }\n\n    for (b_kstr = 8; b_kstr < 9; b_kstr++) {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj->pGain[b_kstr] = obj->AxesMisalignment[b_kstr] / 100.0;\n    }\n\n    equal = false;\n    b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (b_kstr - 1 < 12) {\n        kstr = b_kstr - 1;\n        if (obj->NoiseType.Value[kstr] != tmp_2[kstr]) {\n          exitg1 = 1;\n        } else {\n          b_kstr++;\n        }\n      } else {\n        equal = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n\n    if (equal) {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj->pBandwidth = 500.0;\n    } else {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj->pBandwidth = 1000.0;\n    }\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    maximum = obj->BiasInstabilityCoefficients.Numerator;\n    obj->pBiasInstFilterNum = maximum;\n    obj->pBiasInstFilterDen[0] = obj->BiasInstabilityCoefficients.Denominator[0];\n    obj->pBiasInstFilterDen[1] = obj->BiasInstabilityCoefficients.Denominator[1];\n    obj->pCorrelationTime = 0.002;\n    maximum = 2.0 / (1000.0 * obj->pCorrelationTime);\n    maximum = std::sqrt(maximum);\n    obj->pStdDevBiasInst[0] = maximum * obj->BiasInstability[0];\n    obj->pStdDevBiasInst[1] = maximum * obj->BiasInstability[1];\n    obj->pStdDevBiasInst[2] = maximum * obj->BiasInstability[2];\n    maximum = obj->pBandwidth;\n    maximum = std::sqrt(maximum);\n    obj->pStdDevWhiteNoise[0] = maximum * obj->NoiseDensity[0];\n    obj->pStdDevWhiteNoise[1] = maximum * obj->NoiseDensity[1];\n    obj->pStdDevWhiteNoise[2] = maximum * obj->NoiseDensity[2];\n    maximum = obj->pBandwidth;\n    maximum = std::sqrt(maximum);\n    obj->TunablePropsChanged = false;\n    obj->pStdDevRandWalk[0] = obj->RandomWalk[0] / maximum;\n    obj->pBiasInstFilterStates[0] = 0.0;\n    obj->pRandWalkFilterStates[0] = 0.0;\n    obj->pStdDevRandWalk[1] = obj->RandomWalk[1] / maximum;\n    obj->pBiasInstFilterStates[1] = 0.0;\n    obj->pRandWalkFilterStates[1] = 0.0;\n    obj->pStdDevRandWalk[2] = obj->RandomWalk[2] / maximum;\n    obj->pBiasInstFilterStates[2] = 0.0;\n    obj->pRandWalkFilterStates[2] = 0.0;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  if (obj->TunablePropsChanged) {\n    obj->TunablePropsChanged = false;\n    equal = obj->tunablePropertyChanged[3];\n    if (equal) {\n      for (b_kstr = 0; b_kstr <= 6; b_kstr += 2) {\n        tmp_1 = _mm_loadu_pd(&obj->AxesMisalignment[b_kstr]);\n        tmp_1 = _mm_div_pd(tmp_1, _mm_set1_pd(100.0));\n        _mm_storeu_pd(&obj->pGain[b_kstr], tmp_1);\n      }\n\n      for (b_kstr = 8; b_kstr < 9; b_kstr++) {\n        obj->pGain[b_kstr] = obj->AxesMisalignment[b_kstr] / 100.0;\n      }\n    }\n\n    equal = obj->tunablePropertyChanged[4];\n    guard1 = false;\n    if (equal) {\n      guard1 = true;\n    } else {\n      equal = obj->tunablePropertyChanged[8];\n      if (equal) {\n        guard1 = true;\n      }\n    }\n\n    if (guard1) {\n      equal = false;\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 12) {\n          kstr = b_kstr - 1;\n          if (obj->NoiseType.Value[kstr] != tmp_2[kstr]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          equal = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n\n      if (equal) {\n        obj->pBandwidth = 500.0;\n      } else {\n        obj->pBandwidth = 1000.0;\n      }\n\n      maximum = obj->pBandwidth;\n      maximum = std::sqrt(maximum);\n      obj->pStdDevWhiteNoise[0] = maximum * obj->NoiseDensity[0];\n      obj->pStdDevWhiteNoise[1] = maximum * obj->NoiseDensity[1];\n      obj->pStdDevWhiteNoise[2] = maximum * obj->NoiseDensity[2];\n    }\n\n    equal = obj->tunablePropertyChanged[5];\n    if (equal) {\n      maximum = 2.0 / (1000.0 * obj->pCorrelationTime);\n      maximum = std::sqrt(maximum);\n      obj->pStdDevBiasInst[0] = maximum * obj->BiasInstability[0];\n      obj->pStdDevBiasInst[1] = maximum * obj->BiasInstability[1];\n      obj->pStdDevBiasInst[2] = maximum * obj->BiasInstability[2];\n    }\n\n    equal = obj->tunablePropertyChanged[6];\n    guard1 = false;\n    if (equal) {\n      guard1 = true;\n    } else {\n      equal = obj->tunablePropertyChanged[8];\n      if (equal) {\n        guard1 = true;\n      }\n    }\n\n    if (guard1) {\n      equal = false;\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 12) {\n          kstr = b_kstr - 1;\n          if (obj->NoiseType.Value[kstr] != tmp_2[kstr]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          equal = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n\n      if (equal) {\n        obj->pBandwidth = 500.0;\n      } else {\n        obj->pBandwidth = 1000.0;\n      }\n\n      maximum = obj->pBandwidth;\n      maximum = std::sqrt(maximum);\n      obj->pStdDevRandWalk[0] = obj->RandomWalk[0] / maximum;\n      obj->pStdDevRandWalk[1] = obj->RandomWalk[1] / maximum;\n      obj->pStdDevRandWalk[2] = obj->RandomWalk[2] / maximum;\n    }\n\n    equal = obj->tunablePropertyChanged[7];\n    if (equal) {\n      maximum = obj->BiasInstabilityCoefficients.Numerator;\n      obj->pBiasInstFilterNum = maximum;\n      obj->pBiasInstFilterDen[0] = obj->BiasInstabilityCoefficients.Denominator\n        [0];\n      obj->pBiasInstFilterDen[1] = obj->BiasInstabilityCoefficients.Denominator\n        [1];\n    }\n\n    for (b_kstr = 0; b_kstr < 12; b_kstr++) {\n      obj->tunablePropertyChanged[b_kstr] = false;\n    }\n  }\n\n  whiteNoiseDrift_idx_1 = -varargin_1[0];\n  whiteNoiseDrift_idx_2 = -varargin_1[1];\n  tmp = -varargin_1[2] + 9.81;\n  for (b_kstr = 0; b_kstr <= 0; b_kstr += 2) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp_1 = _mm_loadu_pd(&varargin_2[b_kstr]);\n    tmp_1 = _mm_mul_pd(tmp_1, _mm_set1_pd(whiteNoiseDrift_idx_1));\n    tmp_0 = _mm_loadu_pd(&varargin_2[b_kstr + 3]);\n    tmp_0 = _mm_mul_pd(tmp_0, _mm_set1_pd(whiteNoiseDrift_idx_2));\n    tmp_1 = _mm_add_pd(tmp_0, tmp_1);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp_0 = _mm_loadu_pd(&varargin_2[b_kstr + 6]);\n    tmp_0 = _mm_mul_pd(tmp_0, _mm_set1_pd(tmp));\n    tmp_1 = _mm_add_pd(tmp_0, tmp_1);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    _mm_storeu_pd(&B[b_kstr], tmp_1);\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  for (b_kstr = 2; b_kstr < 3; b_kstr++) {\n    maximum = varargin_2[b_kstr] * whiteNoiseDrift_idx_1;\n    maximum += varargin_2[b_kstr + 3] * whiteNoiseDrift_idx_2;\n    maximum += varargin_2[b_kstr + 6] * tmp;\n    B[b_kstr] = maximum;\n  }\n\n  maximum = B[0];\n  whiteNoiseDrift_idx_2 = B[1];\n  tmp = B[2];\n  for (b_kstr = 0; b_kstr <= 0; b_kstr += 2) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp_1 = _mm_loadu_pd(&obj->pGain[b_kstr]);\n    tmp_1 = _mm_mul_pd(tmp_1, _mm_set1_pd(maximum));\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp_0 = _mm_loadu_pd(&obj->pGain[b_kstr + 3]);\n    tmp_0 = _mm_mul_pd(tmp_0, _mm_set1_pd(whiteNoiseDrift_idx_2));\n    tmp_1 = _mm_add_pd(tmp_0, tmp_1);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp_0 = _mm_loadu_pd(&obj->pGain[b_kstr + 6]);\n    tmp_0 = _mm_mul_pd(tmp_0, _mm_set1_pd(tmp));\n    tmp_1 = _mm_add_pd(tmp_0, tmp_1);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp_0 = _mm_loadu_pd(&obj->ConstantBias[b_kstr]);\n    tmp_1 = _mm_add_pd(tmp_1, tmp_0);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    _mm_storeu_pd(&B[b_kstr], tmp_1);\n    tmp_1 = _mm_loadu_pd(&varargin_3[b_kstr]);\n    tmp_0 = _mm_loadu_pd(&obj->pStdDevBiasInst[b_kstr]);\n    tmp_1 = _mm_mul_pd(tmp_1, tmp_0);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    _mm_storeu_pd(&c[b_kstr], tmp_1);\n  }\n\n  for (b_kstr = 2; b_kstr < 3; b_kstr++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    whiteNoiseDrift_idx_1 = obj->pGain[b_kstr] * maximum;\n    whiteNoiseDrift_idx_1 += obj->pGain[b_kstr + 3] * whiteNoiseDrift_idx_2;\n    whiteNoiseDrift_idx_1 += obj->pGain[b_kstr + 6] * tmp;\n    B[b_kstr] = whiteNoiseDrift_idx_1 + obj->ConstantBias[b_kstr];\n    c[b_kstr] = varargin_3[b_kstr] * obj->pStdDevBiasInst[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 3; b_kstr++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj_0[b_kstr] = obj->pBiasInstFilterStates[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 2; b_kstr++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj_1[b_kstr] = obj->pBiasInstFilterDen[b_kstr];\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  simulation_filter(obj->pBiasInstFilterNum, obj_1, c, obj_0, y,\n                    obj->pBiasInstFilterStates);\n  maximum = obj->pStdDevWhiteNoise[0] * varargin_3[3];\n  tmp = obj->pStdDevRandWalk[0] * varargin_3[6];\n  x_idx_0 = obj->pRandWalkFilterStates[0];\n  x_idx_1 = tmp;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  whiteNoiseDrift_idx_1 = obj->pStdDevWhiteNoise[1] * varargin_3[4];\n  tmp = obj->pStdDevRandWalk[1] * varargin_3[7];\n  x_idx_2 = obj->pRandWalkFilterStates[1];\n  x_idx_3 = tmp;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  whiteNoiseDrift_idx_2 = obj->pStdDevWhiteNoise[2] * varargin_3[5];\n  tmp = obj->pStdDevRandWalk[2] * varargin_3[8];\n  x_idx_4 = obj->pRandWalkFilterStates[2];\n  x_idx_5 = tmp;\n  x_idx_1 += x_idx_0;\n  x_idx_3 += x_idx_2;\n  x_idx_5 += x_idx_4;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  tmp = obj->Temperature - 25.0;\n  obj->pRandWalkFilterStates[0] = x_idx_1;\n  c[0] = tmp * obj->TemperatureBias[0];\n  obj->pRandWalkFilterStates[1] = x_idx_3;\n  c[1] = tmp * obj->TemperatureBias[1];\n  obj->pRandWalkFilterStates[2] = x_idx_5;\n  c[2] = tmp * obj->TemperatureBias[2];\n  x_idx_0 = c[0];\n  x_idx_2 = c[1];\n  x_idx_4 = c[2];\n  tmp = (obj->Temperature - 25.0) * 0.01;\n  c[0] = tmp * obj->TemperatureScaleFactor[0] + 1.0;\n  c[1] = tmp * obj->TemperatureScaleFactor[1] + 1.0;\n  c[2] = tmp * obj->TemperatureScaleFactor[2] + 1.0;\n  varargout_1[0] = c[0];\n  varargout_1[1] = c[1];\n  varargout_1[2] = c[2];\n  varargout_1[0] *= (((maximum + y[0]) + x_idx_1) + x_idx_0) + B[0];\n  varargout_1[1] *= (((whiteNoiseDrift_idx_1 + y[1]) + x_idx_3) + x_idx_2) + B[1];\n  varargout_1[2] *= (((whiteNoiseDrift_idx_2 + y[2]) + x_idx_5) + x_idx_4) + B[2];\n  maximum = obj->MeasurementRange;\n  if (!std::isinf(maximum)) {\n    whiteNoiseDrift_idx_1 = std::abs(varargout_1[0]);\n    y[0] = whiteNoiseDrift_idx_1;\n    whiteNoiseDrift_idx_2 = std::abs(varargout_1[1]);\n    y[1] = whiteNoiseDrift_idx_2;\n    tmp = std::abs(varargout_1[2]);\n    y[2] = tmp;\n    kstr = 0;\n    for (b_kstr = 0; b_kstr < 3; b_kstr++) {\n      if (y[b_kstr] > maximum) {\n        b_data[kstr] = static_cast<int8_T>(b_kstr);\n        kstr++;\n      }\n    }\n\n    y[0] = whiteNoiseDrift_idx_1;\n    y[1] = whiteNoiseDrift_idx_2;\n    y[2] = tmp;\n    kstr = 0;\n    for (b_kstr = 0; b_kstr < 3; b_kstr++) {\n      if (y[b_kstr] > maximum) {\n        kstr++;\n      }\n    }\n\n    tmp_size_idx_1 = kstr;\n    kstr = 0;\n    for (b_kstr = 0; b_kstr < 3; b_kstr++) {\n      if (y[b_kstr] > maximum) {\n        tmp_data[kstr] = static_cast<int8_T>(b_kstr);\n        kstr++;\n      }\n    }\n\n    kstr = tmp_size_idx_1;\n    for (b_kstr = 0; b_kstr < kstr; b_kstr++) {\n      B[b_kstr] = varargout_1[tmp_data[b_kstr]];\n    }\n\n    kstr = 0;\n    for (b_kstr = 0; b_kstr < 3; b_kstr++) {\n      if (y[b_kstr] > maximum) {\n        kstr++;\n      }\n    }\n\n    b = kstr - 1;\n    for (kstr = 0; kstr <= b; kstr++) {\n      b_kstr = kstr;\n      whiteNoiseDrift_idx_1 = B[b_kstr];\n      if (std::isnan(whiteNoiseDrift_idx_1)) {\n        whiteNoiseDrift_idx_1 = (rtNaN);\n      } else if (whiteNoiseDrift_idx_1 < 0.0) {\n        whiteNoiseDrift_idx_1 = -1.0;\n      } else {\n        whiteNoiseDrift_idx_1 = (whiteNoiseDrift_idx_1 > 0.0);\n      }\n\n      B[b_kstr] = whiteNoiseDrift_idx_1;\n    }\n\n    kstr = tmp_size_idx_1;\n    for (b_kstr = 0; b_kstr < kstr; b_kstr++) {\n      varargout_1[b_data[b_kstr]] = B[b_kstr] * maximum;\n    }\n  }\n\n  if (obj->Resolution != 0.0) {\n    maximum = obj->Resolution;\n    varargout_1[0] /= maximum;\n    varargout_1[1] /= maximum;\n    varargout_1[2] /= maximum;\n    varargout_1[0] = std::round(varargout_1[0]);\n    varargout_1[1] = std::round(varargout_1[1]);\n    varargout_1[2] = std::round(varargout_1[2]);\n    varargout_1[0] *= maximum;\n    varargout_1[1] *= maximum;\n    varargout_1[2] *= maximum;\n  }\n}\n\nstatic void simulation_SystemCore_step_oi(h_fusion_internal_GyroscopeSi_T *obj,\n  const real_T varargin_1[3], const real_T varargin_2[3], const real_T\n  varargin_3[9], const real_T varargin_4[9], real_T varargout_1[3])\n{\n  static const char_T tmp_1[12]{ 'd', 'o', 'u', 'b', 'l', 'e', '-', 's', 'i',\n    'd', 'e', 'd' };\n\n  __m128d tmp;\n  __m128d tmp_0;\n  real_T B[3];\n  real_T c[3];\n  real_T obj_0[3];\n  real_T varargin_3_0[3];\n  real_T obj_1[2];\n  real_T accelerationDrift_idx_1;\n  real_T accelerationDrift_idx_2;\n  real_T maximum;\n  real_T temperatureDrift_idx_2;\n  real_T varargin_1_0;\n  real_T whiteNoiseDrift_idx_1;\n  real_T whiteNoiseDrift_idx_2;\n  real_T x_idx_0;\n  real_T x_idx_1;\n  real_T x_idx_2;\n  real_T x_idx_3;\n  real_T x_idx_4;\n  real_T x_idx_5;\n  int32_T b;\n  int32_T b_kstr;\n  int32_T exitg1;\n  int32_T kstr;\n  int32_T tmp_size_idx_1;\n  int8_T b_data[3];\n  int8_T tmp_data[3];\n  boolean_T equal;\n  boolean_T guard1;\n  if (obj->isInitialized != 1) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj->isInitialized = 1;\n    for (b_kstr = 0; b_kstr <= 6; b_kstr += 2) {\n      // Start for MATLABSystem: '<S17>/IMU'\n      tmp_0 = _mm_loadu_pd(&obj->AxesMisalignment[b_kstr]);\n      tmp_0 = _mm_div_pd(tmp_0, _mm_set1_pd(100.0));\n\n      // Start for MATLABSystem: '<S17>/IMU'\n      _mm_storeu_pd(&obj->pGain[b_kstr], tmp_0);\n    }\n\n    for (b_kstr = 8; b_kstr < 9; b_kstr++) {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj->pGain[b_kstr] = obj->AxesMisalignment[b_kstr] / 100.0;\n    }\n\n    equal = false;\n    b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (b_kstr - 1 < 12) {\n        kstr = b_kstr - 1;\n        if (obj->NoiseType.Value[kstr] != tmp_1[kstr]) {\n          exitg1 = 1;\n        } else {\n          b_kstr++;\n        }\n      } else {\n        equal = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n\n    if (equal) {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj->pBandwidth = 500.0;\n    } else {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj->pBandwidth = 1000.0;\n    }\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    maximum = obj->BiasInstabilityCoefficients.Numerator;\n    obj->pBiasInstFilterNum = maximum;\n    obj->pBiasInstFilterDen[0] = obj->BiasInstabilityCoefficients.Denominator[0];\n    obj->pBiasInstFilterDen[1] = obj->BiasInstabilityCoefficients.Denominator[1];\n    obj->pCorrelationTime = 0.002;\n    maximum = 2.0 / (1000.0 * obj->pCorrelationTime);\n    maximum = std::sqrt(maximum);\n    obj->pStdDevBiasInst[0] = maximum * obj->BiasInstability[0];\n    obj->pStdDevBiasInst[1] = maximum * obj->BiasInstability[1];\n    obj->pStdDevBiasInst[2] = maximum * obj->BiasInstability[2];\n    maximum = obj->pBandwidth;\n    maximum = std::sqrt(maximum);\n    obj->pStdDevWhiteNoise[0] = maximum * obj->NoiseDensity[0];\n    obj->pStdDevWhiteNoise[1] = maximum * obj->NoiseDensity[1];\n    obj->pStdDevWhiteNoise[2] = maximum * obj->NoiseDensity[2];\n    maximum = obj->pBandwidth;\n    maximum = std::sqrt(maximum);\n    obj->TunablePropsChanged = false;\n    obj->pStdDevRandWalk[0] = obj->RandomWalk[0] / maximum;\n    obj->pBiasInstFilterStates[0] = 0.0;\n    obj->pRandWalkFilterStates[0] = 0.0;\n    obj->pStdDevRandWalk[1] = obj->RandomWalk[1] / maximum;\n    obj->pBiasInstFilterStates[1] = 0.0;\n    obj->pRandWalkFilterStates[1] = 0.0;\n    obj->pStdDevRandWalk[2] = obj->RandomWalk[2] / maximum;\n    obj->pBiasInstFilterStates[2] = 0.0;\n    obj->pRandWalkFilterStates[2] = 0.0;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  if (obj->TunablePropsChanged) {\n    obj->TunablePropsChanged = false;\n    equal = obj->tunablePropertyChanged[4];\n    if (equal) {\n      for (b_kstr = 0; b_kstr <= 6; b_kstr += 2) {\n        tmp_0 = _mm_loadu_pd(&obj->AxesMisalignment[b_kstr]);\n        tmp_0 = _mm_div_pd(tmp_0, _mm_set1_pd(100.0));\n        _mm_storeu_pd(&obj->pGain[b_kstr], tmp_0);\n      }\n\n      for (b_kstr = 8; b_kstr < 9; b_kstr++) {\n        obj->pGain[b_kstr] = obj->AxesMisalignment[b_kstr] / 100.0;\n      }\n    }\n\n    equal = obj->tunablePropertyChanged[5];\n    guard1 = false;\n    if (equal) {\n      guard1 = true;\n    } else {\n      equal = obj->tunablePropertyChanged[9];\n      if (equal) {\n        guard1 = true;\n      }\n    }\n\n    if (guard1) {\n      equal = false;\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 12) {\n          kstr = b_kstr - 1;\n          if (obj->NoiseType.Value[kstr] != tmp_1[kstr]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          equal = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n\n      if (equal) {\n        obj->pBandwidth = 500.0;\n      } else {\n        obj->pBandwidth = 1000.0;\n      }\n\n      maximum = obj->pBandwidth;\n      maximum = std::sqrt(maximum);\n      obj->pStdDevWhiteNoise[0] = maximum * obj->NoiseDensity[0];\n      obj->pStdDevWhiteNoise[1] = maximum * obj->NoiseDensity[1];\n      obj->pStdDevWhiteNoise[2] = maximum * obj->NoiseDensity[2];\n    }\n\n    equal = obj->tunablePropertyChanged[6];\n    if (equal) {\n      maximum = 2.0 / (1000.0 * obj->pCorrelationTime);\n      maximum = std::sqrt(maximum);\n      obj->pStdDevBiasInst[0] = maximum * obj->BiasInstability[0];\n      obj->pStdDevBiasInst[1] = maximum * obj->BiasInstability[1];\n      obj->pStdDevBiasInst[2] = maximum * obj->BiasInstability[2];\n    }\n\n    equal = obj->tunablePropertyChanged[7];\n    guard1 = false;\n    if (equal) {\n      guard1 = true;\n    } else {\n      equal = obj->tunablePropertyChanged[9];\n      if (equal) {\n        guard1 = true;\n      }\n    }\n\n    if (guard1) {\n      equal = false;\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 12) {\n          kstr = b_kstr - 1;\n          if (obj->NoiseType.Value[kstr] != tmp_1[kstr]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          equal = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n\n      if (equal) {\n        obj->pBandwidth = 500.0;\n      } else {\n        obj->pBandwidth = 1000.0;\n      }\n\n      maximum = obj->pBandwidth;\n      maximum = std::sqrt(maximum);\n      obj->pStdDevRandWalk[0] = obj->RandomWalk[0] / maximum;\n      obj->pStdDevRandWalk[1] = obj->RandomWalk[1] / maximum;\n      obj->pStdDevRandWalk[2] = obj->RandomWalk[2] / maximum;\n    }\n\n    equal = obj->tunablePropertyChanged[8];\n    if (equal) {\n      maximum = obj->BiasInstabilityCoefficients.Numerator;\n      obj->pBiasInstFilterNum = maximum;\n      obj->pBiasInstFilterDen[0] = obj->BiasInstabilityCoefficients.Denominator\n        [0];\n      obj->pBiasInstFilterDen[1] = obj->BiasInstabilityCoefficients.Denominator\n        [1];\n    }\n\n    for (b_kstr = 0; b_kstr < 13; b_kstr++) {\n      obj->tunablePropertyChanged[b_kstr] = false;\n    }\n  }\n\n  whiteNoiseDrift_idx_1 = varargin_1[0];\n  whiteNoiseDrift_idx_2 = varargin_1[1];\n  varargin_1_0 = varargin_1[2];\n  for (b_kstr = 0; b_kstr <= 0; b_kstr += 2) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp_0 = _mm_loadu_pd(&varargin_2[b_kstr]);\n    _mm_storeu_pd(&obj->pAcceleration[b_kstr], tmp_0);\n    tmp_0 = _mm_loadu_pd(&varargin_3[b_kstr]);\n    tmp_0 = _mm_mul_pd(tmp_0, _mm_set1_pd(whiteNoiseDrift_idx_1));\n    tmp = _mm_loadu_pd(&varargin_3[b_kstr + 3]);\n    tmp = _mm_mul_pd(tmp, _mm_set1_pd(whiteNoiseDrift_idx_2));\n    tmp_0 = _mm_add_pd(tmp, tmp_0);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp = _mm_loadu_pd(&varargin_3[b_kstr + 6]);\n    tmp = _mm_mul_pd(tmp, _mm_set1_pd(varargin_1_0));\n    tmp_0 = _mm_add_pd(tmp, tmp_0);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    _mm_storeu_pd(&varargin_3_0[b_kstr], tmp_0);\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  for (b_kstr = 2; b_kstr < 3; b_kstr++) {\n    obj->pAcceleration[b_kstr] = varargin_2[b_kstr];\n    maximum = varargin_3[b_kstr] * whiteNoiseDrift_idx_1;\n    maximum += varargin_3[b_kstr + 3] * whiteNoiseDrift_idx_2;\n    maximum += varargin_3[b_kstr + 6] * varargin_1_0;\n    varargin_3_0[b_kstr] = maximum;\n  }\n\n  maximum = varargin_3_0[0];\n  whiteNoiseDrift_idx_2 = varargin_3_0[1];\n  varargin_1_0 = varargin_3_0[2];\n  for (b_kstr = 0; b_kstr <= 0; b_kstr += 2) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp_0 = _mm_loadu_pd(&obj->pGain[b_kstr]);\n    tmp_0 = _mm_mul_pd(tmp_0, _mm_set1_pd(maximum));\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp = _mm_loadu_pd(&obj->pGain[b_kstr + 3]);\n    tmp = _mm_mul_pd(tmp, _mm_set1_pd(whiteNoiseDrift_idx_2));\n    tmp_0 = _mm_add_pd(tmp, tmp_0);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp = _mm_loadu_pd(&obj->pGain[b_kstr + 6]);\n    tmp = _mm_mul_pd(tmp, _mm_set1_pd(varargin_1_0));\n    tmp_0 = _mm_add_pd(tmp, tmp_0);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp = _mm_loadu_pd(&obj->ConstantBias[b_kstr]);\n    tmp_0 = _mm_add_pd(tmp_0, tmp);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    _mm_storeu_pd(&B[b_kstr], tmp_0);\n    tmp_0 = _mm_loadu_pd(&varargin_4[b_kstr]);\n    tmp = _mm_loadu_pd(&obj->pStdDevBiasInst[b_kstr]);\n    tmp_0 = _mm_mul_pd(tmp_0, tmp);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    _mm_storeu_pd(&c[b_kstr], tmp_0);\n  }\n\n  for (b_kstr = 2; b_kstr < 3; b_kstr++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    whiteNoiseDrift_idx_1 = obj->pGain[b_kstr] * maximum;\n    whiteNoiseDrift_idx_1 += obj->pGain[b_kstr + 3] * whiteNoiseDrift_idx_2;\n    whiteNoiseDrift_idx_1 += obj->pGain[b_kstr + 6] * varargin_1_0;\n    B[b_kstr] = whiteNoiseDrift_idx_1 + obj->ConstantBias[b_kstr];\n    c[b_kstr] = varargin_4[b_kstr] * obj->pStdDevBiasInst[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 3; b_kstr++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj_0[b_kstr] = obj->pBiasInstFilterStates[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 2; b_kstr++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj_1[b_kstr] = obj->pBiasInstFilterDen[b_kstr];\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  simulation_filter(obj->pBiasInstFilterNum, obj_1, c, obj_0, varargin_3_0,\n                    obj->pBiasInstFilterStates);\n  maximum = obj->pStdDevWhiteNoise[0] * varargin_4[3];\n  varargin_1_0 = obj->pStdDevRandWalk[0] * varargin_4[6];\n  x_idx_0 = obj->pRandWalkFilterStates[0];\n  x_idx_1 = varargin_1_0;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  whiteNoiseDrift_idx_1 = obj->pStdDevWhiteNoise[1] * varargin_4[4];\n  varargin_1_0 = obj->pStdDevRandWalk[1] * varargin_4[7];\n  x_idx_2 = obj->pRandWalkFilterStates[1];\n  x_idx_3 = varargin_1_0;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  whiteNoiseDrift_idx_2 = obj->pStdDevWhiteNoise[2] * varargin_4[5];\n  varargin_1_0 = obj->pStdDevRandWalk[2] * varargin_4[8];\n  x_idx_4 = obj->pRandWalkFilterStates[2];\n  x_idx_5 = varargin_1_0;\n  x_idx_1 += x_idx_0;\n  x_idx_3 += x_idx_2;\n  x_idx_5 += x_idx_4;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  varargin_1_0 = obj->Temperature - 25.0;\n  obj->pRandWalkFilterStates[0] = x_idx_1;\n  c[0] = varargin_1_0 * obj->TemperatureBias[0];\n  obj->pRandWalkFilterStates[1] = x_idx_3;\n  c[1] = varargin_1_0 * obj->TemperatureBias[1];\n  obj->pRandWalkFilterStates[2] = x_idx_5;\n  c[2] = varargin_1_0 * obj->TemperatureBias[2];\n  x_idx_0 = c[0];\n  x_idx_2 = obj->pAcceleration[0] * obj->AccelerationBias[0];\n  x_idx_4 = c[1];\n  accelerationDrift_idx_1 = obj->pAcceleration[1] * obj->AccelerationBias[1];\n  temperatureDrift_idx_2 = c[2];\n  accelerationDrift_idx_2 = obj->pAcceleration[2] * obj->AccelerationBias[2];\n  varargin_1_0 = (obj->Temperature - 25.0) * 0.01;\n  c[0] = varargin_1_0 * obj->TemperatureScaleFactor[0] + 1.0;\n  c[1] = varargin_1_0 * obj->TemperatureScaleFactor[1] + 1.0;\n  c[2] = varargin_1_0 * obj->TemperatureScaleFactor[2] + 1.0;\n  varargout_1[0] = c[0];\n  varargout_1[1] = c[1];\n  varargout_1[2] = c[2];\n  varargout_1[0] *= (((maximum + varargin_3_0[0]) + x_idx_1) + (x_idx_0 +\n    x_idx_2)) + B[0];\n  varargout_1[1] *= (((whiteNoiseDrift_idx_1 + varargin_3_0[1]) + x_idx_3) +\n                     (x_idx_4 + accelerationDrift_idx_1)) + B[1];\n  varargout_1[2] *= (((whiteNoiseDrift_idx_2 + varargin_3_0[2]) + x_idx_5) +\n                     (temperatureDrift_idx_2 + accelerationDrift_idx_2)) + B[2];\n  maximum = obj->MeasurementRange;\n  if (!std::isinf(maximum)) {\n    whiteNoiseDrift_idx_1 = std::abs(varargout_1[0]);\n    varargin_3_0[0] = whiteNoiseDrift_idx_1;\n    whiteNoiseDrift_idx_2 = std::abs(varargout_1[1]);\n    varargin_3_0[1] = whiteNoiseDrift_idx_2;\n    varargin_1_0 = std::abs(varargout_1[2]);\n    varargin_3_0[2] = varargin_1_0;\n    kstr = 0;\n    for (b_kstr = 0; b_kstr < 3; b_kstr++) {\n      if (varargin_3_0[b_kstr] > maximum) {\n        b_data[kstr] = static_cast<int8_T>(b_kstr);\n        kstr++;\n      }\n    }\n\n    varargin_3_0[0] = whiteNoiseDrift_idx_1;\n    varargin_3_0[1] = whiteNoiseDrift_idx_2;\n    varargin_3_0[2] = varargin_1_0;\n    kstr = 0;\n    for (b_kstr = 0; b_kstr < 3; b_kstr++) {\n      if (varargin_3_0[b_kstr] > maximum) {\n        kstr++;\n      }\n    }\n\n    tmp_size_idx_1 = kstr;\n    kstr = 0;\n    for (b_kstr = 0; b_kstr < 3; b_kstr++) {\n      if (varargin_3_0[b_kstr] > maximum) {\n        tmp_data[kstr] = static_cast<int8_T>(b_kstr);\n        kstr++;\n      }\n    }\n\n    kstr = tmp_size_idx_1;\n    for (b_kstr = 0; b_kstr < kstr; b_kstr++) {\n      B[b_kstr] = varargout_1[tmp_data[b_kstr]];\n    }\n\n    kstr = 0;\n    for (b_kstr = 0; b_kstr < 3; b_kstr++) {\n      if (varargin_3_0[b_kstr] > maximum) {\n        kstr++;\n      }\n    }\n\n    b = kstr - 1;\n    for (kstr = 0; kstr <= b; kstr++) {\n      b_kstr = kstr;\n      whiteNoiseDrift_idx_1 = B[b_kstr];\n      if (std::isnan(whiteNoiseDrift_idx_1)) {\n        whiteNoiseDrift_idx_1 = (rtNaN);\n      } else if (whiteNoiseDrift_idx_1 < 0.0) {\n        whiteNoiseDrift_idx_1 = -1.0;\n      } else {\n        whiteNoiseDrift_idx_1 = (whiteNoiseDrift_idx_1 > 0.0);\n      }\n\n      B[b_kstr] = whiteNoiseDrift_idx_1;\n    }\n\n    kstr = tmp_size_idx_1;\n    for (b_kstr = 0; b_kstr < kstr; b_kstr++) {\n      varargout_1[b_data[b_kstr]] = B[b_kstr] * maximum;\n    }\n  }\n\n  if (obj->Resolution != 0.0) {\n    maximum = obj->Resolution;\n    varargout_1[0] /= maximum;\n    varargout_1[1] /= maximum;\n    varargout_1[2] /= maximum;\n    varargout_1[0] = std::round(varargout_1[0]);\n    varargout_1[1] = std::round(varargout_1[1]);\n    varargout_1[2] = std::round(varargout_1[2]);\n    varargout_1[0] *= maximum;\n    varargout_1[1] *= maximum;\n    varargout_1[2] *= maximum;\n  }\n}\n\nstatic void simulation_imuSensor_stepImpl(fusion_simulink_imuSensor_sim_T *obj,\n  const real_T la[3], const real_T av[3], const real_T o[4], real_T a[3], real_T\n  g[3], real_T m[3])\n{\n  static const real_T tmp_1[257]{ 0.0, 0.215241895984875, 0.286174591792068,\n    0.335737519214422, 0.375121332878378, 0.408389134611989, 0.43751840220787,\n    0.46363433679088, 0.487443966139235, 0.50942332960209, 0.529909720661557,\n    0.549151702327164, 0.567338257053817, 0.584616766106378, 0.601104617755991,\n    0.61689699000775, 0.63207223638606, 0.646695714894993, 0.660822574244419,\n    0.674499822837293, 0.687767892795788, 0.700661841106814, 0.713212285190975,\n    0.725446140909999, 0.737387211434295, 0.749056662017815, 0.760473406430107,\n    0.771654424224568, 0.782615023307232, 0.793369058840623, 0.80392911698997,\n    0.814306670135215, 0.824512208752291, 0.834555354086381, 0.844444954909153,\n    0.854189171008163, 0.863795545553308, 0.87327106808886, 0.882622229585165,\n    0.891855070732941, 0.900975224461221, 0.909987953496718, 0.91889818364959,\n    0.927710533401999, 0.936429340286575, 0.945058684468165, 0.953602409881086,\n    0.96206414322304, 0.970447311064224, 0.978755155294224, 0.986990747099062,\n    0.99515699963509, 1.00325667954467, 1.01129241744, 1.01926671746548,\n    1.02718196603564, 1.03504043983344, 1.04284431314415, 1.05059566459093,\n    1.05829648333067, 1.06594867476212, 1.07355406579244, 1.0811144097034,\n    1.08863139065398, 1.09610662785202, 1.10354167942464, 1.11093804601357,\n    1.11829717411934, 1.12562045921553, 1.13290924865253, 1.14016484436815,\n    1.14738850542085, 1.15458145035993, 1.16174485944561, 1.16887987673083,\n    1.17598761201545, 1.18306914268269, 1.19012551542669, 1.19715774787944,\n    1.20416683014438, 1.2111537262437, 1.21811937548548, 1.22506469375653,\n    1.23199057474614, 1.23889789110569, 1.24578749554863, 1.2526602218949,\n    1.25951688606371, 1.26635828701823, 1.27318520766536, 1.27999841571382,\n    1.28679866449324, 1.29358669373695, 1.30036323033084, 1.30712898903073,\n    1.31388467315022, 1.32063097522106, 1.32736857762793, 1.33409815321936,\n    1.3408203658964, 1.34753587118059, 1.35424531676263, 1.36094934303328,\n    1.36764858359748, 1.37434366577317, 1.38103521107586, 1.38772383568998,\n    1.39441015092814, 1.40109476367925, 1.4077782768464, 1.41446128977547,\n    1.42114439867531, 1.42782819703026, 1.43451327600589, 1.44120022484872,\n    1.44788963128058, 1.45458208188841, 1.46127816251028, 1.46797845861808,\n    1.47468355569786, 1.48139403962819, 1.48811049705745, 1.49483351578049,\n    1.50156368511546, 1.50830159628131, 1.51504784277671, 1.521803020761,\n    1.52856772943771, 1.53534257144151, 1.542128153229, 1.54892508547417,\n    1.55573398346918, 1.56255546753104, 1.56939016341512, 1.57623870273591,\n    1.58310172339603, 1.58997987002419, 1.59687379442279, 1.60378415602609,\n    1.61071162236983, 1.61765686957301, 1.62462058283303, 1.63160345693487,\n    1.63860619677555, 1.64562951790478, 1.65267414708306, 1.65974082285818,\n    1.66683029616166, 1.67394333092612, 1.68108070472517, 1.68824320943719,\n    1.69543165193456, 1.70264685479992, 1.7098896570713, 1.71716091501782,\n    1.72446150294804, 1.73179231405296, 1.73915426128591, 1.74654827828172,\n    1.75397532031767, 1.76143636531891, 1.76893241491127, 1.77646449552452,\n    1.78403365954944, 1.79164098655216, 1.79928758454972, 1.80697459135082,\n    1.81470317596628, 1.82247454009388, 1.83028991968276, 1.83815058658281,\n    1.84605785028518, 1.8540130597602, 1.86201760539967, 1.87007292107127,\n    1.878180486293, 1.88634182853678, 1.8945585256707, 1.90283220855043,\n    1.91116456377125, 1.91955733659319, 1.92801233405266, 1.93653142827569,\n    1.94511656000868, 1.95376974238465, 1.96249306494436, 1.97128869793366,\n    1.98015889690048, 1.98910600761744, 1.99813247135842, 2.00724083056053,\n    2.0164337349062, 2.02571394786385, 2.03508435372962, 2.04454796521753,\n    2.05410793165065, 2.06376754781173, 2.07353026351874, 2.0833996939983,\n    2.09337963113879, 2.10347405571488, 2.11368715068665, 2.12402331568952,\n    2.13448718284602, 2.14508363404789, 2.15581781987674, 2.16669518035431,\n    2.17772146774029, 2.18890277162636, 2.20024554661128, 2.21175664288416,\n    2.22344334009251, 2.23531338492992, 2.24737503294739, 2.25963709517379,\n    2.27210899022838, 2.28480080272449, 2.29772334890286, 2.31088825060137,\n    2.32430801887113, 2.33799614879653, 2.35196722737914, 2.36623705671729,\n    2.38082279517208, 2.39574311978193, 2.41101841390112, 2.42667098493715,\n    2.44272531820036, 2.4592083743347, 2.47614993967052, 2.49358304127105,\n    2.51154444162669, 2.53007523215985, 2.54922155032478, 2.56903545268184,\n    2.58957598670829, 2.61091051848882, 2.63311639363158, 2.65628303757674,\n    2.68051464328574, 2.70593365612306, 2.73268535904401, 2.76094400527999,\n    2.79092117400193, 2.82287739682644, 2.85713873087322, 2.89412105361341,\n    2.93436686720889, 2.97860327988184, 3.02783779176959, 3.08352613200214,\n    3.147889289518, 3.2245750520478, 3.32024473383983, 3.44927829856143,\n    3.65415288536101, 3.91075795952492 };\n\n  static const real_T tmp_2[257]{ 1.0, 0.977101701267673, 0.959879091800108,\n    0.9451989534423, 0.932060075959231, 0.919991505039348, 0.908726440052131,\n    0.898095921898344, 0.887984660755834, 0.878309655808918, 0.869008688036857,\n    0.860033621196332, 0.851346258458678, 0.842915653112205, 0.834716292986884,\n    0.826726833946222, 0.818929191603703, 0.811307874312656, 0.803849483170964,\n    0.796542330422959, 0.789376143566025, 0.782341832654803, 0.775431304981187,\n    0.768637315798486, 0.761953346836795, 0.755373506507096, 0.748892447219157,\n    0.742505296340151, 0.736207598126863, 0.729995264561476, 0.72386453346863,\n    0.717811932630722, 0.711834248878248, 0.705928501332754, 0.700091918136512,\n    0.694321916126117, 0.688616083004672, 0.682972161644995, 0.677388036218774,\n    0.671861719897082, 0.66639134390875, 0.660975147776663, 0.655611470579697,\n    0.650298743110817, 0.645035480820822, 0.639820277453057, 0.634651799287624,\n    0.629528779924837, 0.624450015547027, 0.619414360605834, 0.614420723888914,\n    0.609468064925773, 0.604555390697468, 0.599681752619125, 0.594846243767987,\n    0.590047996332826, 0.585286179263371, 0.580559996100791, 0.575868682972354,\n    0.571211506735253, 0.566587763256165, 0.561996775814525, 0.557437893618766,\n    0.552910490425833, 0.548413963255266, 0.543947731190026, 0.539511234256952,\n    0.535103932380458, 0.530725304403662, 0.526374847171684, 0.522052074672322,\n    0.517756517229756, 0.513487720747327, 0.509245245995748, 0.505028667943468,\n    0.500837575126149, 0.49667156905249, 0.492530263643869, 0.488413284705458,\n    0.484320269426683, 0.480250865909047, 0.476204732719506, 0.47218153846773,\n    0.468180961405694, 0.464202689048174, 0.460246417812843, 0.456311852678716,\n    0.452398706861849, 0.448506701507203, 0.444635565395739, 0.440785034665804,\n    0.436954852547985, 0.433144769112652, 0.429354541029442, 0.425583931338022,\n    0.421832709229496, 0.418100649837848, 0.414387534040891, 0.410693148270188,\n    0.407017284329473, 0.403359739221114, 0.399720314980197, 0.396098818515832,\n    0.392495061459315, 0.388908860018789, 0.385340034840077, 0.381788410873393,\n    0.378253817245619, 0.374736087137891, 0.371235057668239, 0.367750569779032,\n    0.364282468129004, 0.360830600989648, 0.357394820145781, 0.353974980800077,\n    0.350570941481406, 0.347182563956794, 0.343809713146851, 0.340452257044522,\n    0.337110066637006, 0.333783015830718, 0.330470981379163, 0.327173842813601,\n    0.323891482376391, 0.320623784956905, 0.317370638029914, 0.314131931596337,\n    0.310907558126286, 0.307697412504292, 0.30450139197665, 0.301319396100803,\n    0.298151326696685, 0.294997087799962, 0.291856585617095, 0.288729728482183,\n    0.285616426815502, 0.282516593083708, 0.279430141761638, 0.276356989295668,\n    0.273297054068577, 0.270250256365875, 0.267216518343561, 0.264195763997261,\n    0.261187919132721, 0.258192911337619, 0.255210669954662, 0.252241126055942,\n    0.249284212418529, 0.246339863501264, 0.24340801542275, 0.240488605940501,\n    0.237581574431238, 0.23468686187233, 0.231804410824339, 0.228934165414681,\n    0.226076071322381, 0.223230075763918, 0.220396127480152, 0.217574176724331,\n    0.214764175251174, 0.211966076307031, 0.209179834621125, 0.206405406397881,\n    0.203642749310335, 0.200891822494657, 0.198152586545776, 0.195425003514135,\n    0.192709036903589, 0.190004651670465, 0.187311814223801, 0.1846304924268,\n    0.181960655599523, 0.179302274522848, 0.176655321443735, 0.174019770081839,\n    0.171395595637506, 0.168782774801212, 0.166181285764482, 0.163591108232366,\n    0.161012223437511, 0.158444614155925, 0.15588826472448, 0.153343161060263,\n    0.150809290681846, 0.148286642732575, 0.145775208005994, 0.143274978973514,\n    0.140785949814445, 0.138308116448551, 0.135841476571254, 0.133386029691669,\n    0.130941777173644, 0.12850872228, 0.126086870220186, 0.123676228201597,\n    0.12127680548479, 0.11888861344291, 0.116511665625611, 0.114145977827839,\n    0.111791568163838, 0.109448457146812, 0.107116667774684, 0.104796225622487,\n    0.102487158941935, 0.10018949876881, 0.0979032790388625, 0.095628536713009,\n    0.093365311912691, 0.0911136480663738, 0.0888735920682759,\n    0.0866451944505581, 0.0844285095703535, 0.082223595813203,\n    0.0800305158146631, 0.0778493367020961, 0.0756801303589272,\n    0.0735229737139814, 0.0713779490588905, 0.0692451443970068,\n    0.0671246538277886, 0.065016577971243, 0.0629210244377582, 0.06083810834954,\n    0.0587679529209339, 0.0567106901062031, 0.0546664613248891,\n    0.0526354182767924, 0.0506177238609479, 0.0486135532158687,\n    0.0466230949019305, 0.0446465522512946, 0.0426841449164746,\n    0.0407361106559411, 0.0388027074045262, 0.0368842156885674,\n    0.0349809414617162, 0.0330932194585786, 0.0312214171919203,\n    0.0293659397581334, 0.0275272356696031, 0.0257058040085489,\n    0.0239022033057959, 0.0221170627073089, 0.0203510962300445,\n    0.0186051212757247, 0.0168800831525432, 0.0151770883079353,\n    0.0134974506017399, 0.0118427578579079, 0.0102149714397015,\n    0.00861658276939875, 0.00705087547137324, 0.00552240329925101,\n    0.00403797259336304, 0.00260907274610216, 0.0012602859304986,\n    0.000477467764609386 };\n\n  static const char_T tmp_3[12]{ 'd', 'o', 'u', 'b', 'l', 'e', '-', 's', 'i',\n    'd', 'e', 'd' };\n\n  __m128d tmp;\n  __m128d tmp_0;\n  i_fusion_internal_Magnetomete_T *obj_0;\n  real_T allRandData[27];\n  real_T a_1[9];\n  real_T rmat[9];\n  real_T a_0[3];\n  real_T magneticfield[3];\n  real_T rmat_0[3];\n  real_T temperatureDrift[3];\n  real_T obj_1[2];\n  real_T aasq;\n  real_T ab2;\n  real_T ac2;\n  real_T ad2;\n  real_T bc2;\n  real_T bd2;\n  real_T cd2;\n  real_T n;\n  real_T tb;\n  real_T tc;\n  int32_T b;\n  int32_T b_colIdx;\n  int32_T exitg1;\n  int32_T i;\n  int32_T tmp_size_idx_1;\n  uint32_T c_mt[625];\n  uint32_T e_mt[625];\n  uint32_T u32[2];\n  char_T obj1_Value[12];\n  int8_T b_data[3];\n  int8_T tmp_data[3];\n  boolean_T equal;\n  boolean_T guard1;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  n = std::sqrt(((o[0] * o[0] + o[1] * o[1]) + o[2] * o[2]) + o[3] * o[3]);\n  aasq = o[0] / n;\n  bd2 = o[1] / n;\n  cd2 = o[2] / n;\n  n = o[3] / n;\n  tb = bd2;\n  tc = cd2;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  ab2 = aasq * bd2 * 2.0;\n  ac2 = aasq * cd2 * 2.0;\n  ad2 = aasq * n * 2.0;\n  bc2 = bd2 * cd2 * 2.0;\n  bd2 = bd2 * n * 2.0;\n  cd2 = cd2 * n * 2.0;\n  aasq = aasq * aasq * 2.0 - 1.0;\n  rmat[0] = tb * tb * 2.0 + aasq;\n  rmat[3] = bc2 + ad2;\n  rmat[6] = bd2 - ac2;\n  rmat[1] = bc2 - ad2;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  rmat[4] = tc * tc * 2.0 + aasq;\n  rmat[7] = cd2 + ab2;\n  rmat[2] = bd2 + ac2;\n  rmat[5] = cd2 - ab2;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  rmat[8] = n * n * 2.0 + aasq;\n  for (i = 0; i < 625; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    c_mt[i] = obj->pStreamState[i];\n  }\n\n  for (b_colIdx = 0; b_colIdx < 27; b_colIdx++) {\n    do {\n      exitg1 = 0;\n      simulat_genrand_uint32_vector_o(c_mt, u32);\n      i = static_cast<int32_T>((u32[1] >> 24U) + 1U);\n      tb = ((static_cast<real_T>(u32[0] >> 3U) * 1.6777216E+7 + static_cast<\n             real_T>(static_cast<int32_T>(u32[1]) & 16777215)) *\n            2.2204460492503131E-16 - 1.0) * tmp_1[i];\n      if (std::abs(tb) <= tmp_1[i - 1]) {\n        exitg1 = 1;\n      } else if (i < 256) {\n        tc = simulation_genrandu_o(c_mt);\n        if ((tmp_2[i - 1] - tmp_2[i]) * tc + tmp_2[i] < std::exp(-0.5 * tb * tb))\n        {\n          exitg1 = 1;\n        }\n      } else {\n        do {\n          for (i = 0; i < 625; i++) {\n            e_mt[i] = c_mt[i];\n          }\n\n          tc = simulation_genrandu_o(e_mt);\n          tc = std::log(tc) * 0.273661237329758;\n          for (i = 0; i < 625; i++) {\n            c_mt[i] = e_mt[i];\n          }\n\n          aasq = simulation_genrandu_o(c_mt);\n        } while (!(-2.0 * std::log(aasq) > tc * tc));\n\n        if (tb < 0.0) {\n          tb = tc - 3.65415288536101;\n        } else {\n          tb = 3.65415288536101 - tc;\n        }\n\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    allRandData[b_colIdx] = tb;\n  }\n\n  for (i = 0; i < 625; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj->pStreamState[i] = c_mt[i];\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  simulation_SystemCore_step_o(obj->pAccel, la, rmat, &allRandData[0], a);\n  simulation_SystemCore_step_oi(obj->pGyro, av, la, rmat, &allRandData[9], g);\n  a_0[0] = obj->MagneticField[0];\n  a_0[1] = obj->MagneticField[1];\n  a_0[2] = obj->MagneticField[2];\n  magneticfield[0] = a_0[0];\n  magneticfield[1] = a_0[1];\n  magneticfield[2] = a_0[2];\n  obj_0 = obj->pMag;\n  if (obj_0->isInitialized != 1) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj_0->isInitialized = 1;\n    for (i = 0; i < 9; i++) {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj_0->pGain[i] = obj_0->AxesMisalignment[i] / 100.0;\n    }\n\n    for (i = 0; i < 12; i++) {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj1_Value[i] = obj_0->NoiseType.Value[i];\n    }\n\n    equal = false;\n    b_colIdx = 1;\n    do {\n      exitg1 = 0;\n      if (b_colIdx - 1 < 12) {\n        i = b_colIdx - 1;\n        if (obj1_Value[i] != tmp_3[i]) {\n          exitg1 = 1;\n        } else {\n          b_colIdx++;\n        }\n      } else {\n        equal = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n\n    if (equal) {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj_0->pBandwidth = 500.0;\n    } else {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj_0->pBandwidth = 1000.0;\n    }\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    tb = obj_0->BiasInstabilityCoefficients.Numerator;\n    obj_0->pBiasInstFilterNum = tb;\n    tb = obj_0->BiasInstabilityCoefficients.Denominator[0];\n    obj_0->pBiasInstFilterDen[0] = tb;\n    tb = obj_0->BiasInstabilityCoefficients.Denominator[1];\n    obj_0->pBiasInstFilterDen[1] = tb;\n    obj_0->pCorrelationTime = 0.002;\n    tc = 2.0 / (1000.0 * obj_0->pCorrelationTime);\n    tb = std::sqrt(tc);\n    obj_0->pBiasInstFilterStates[0] = 0.0;\n    obj_0->pStdDevBiasInst[0] = tb * obj_0->BiasInstability[0];\n    obj_0->pBiasInstFilterStates[1] = 0.0;\n    obj_0->pStdDevBiasInst[1] = tb * obj_0->BiasInstability[1];\n    obj_0->pBiasInstFilterStates[2] = 0.0;\n    obj_0->pStdDevBiasInst[2] = tb * obj_0->BiasInstability[2];\n    tc = obj_0->pBandwidth;\n    tb = std::sqrt(tc);\n    obj_0->pStdDevWhiteNoise[0] = tb * obj_0->NoiseDensity[0];\n    obj_0->pRandWalkFilterStates[0] = 0.0;\n    obj_0->pStdDevWhiteNoise[1] = tb * obj_0->NoiseDensity[1];\n    obj_0->pRandWalkFilterStates[1] = 0.0;\n    obj_0->pStdDevWhiteNoise[2] = tb * obj_0->NoiseDensity[2];\n    obj_0->pRandWalkFilterStates[2] = 0.0;\n    tc = obj_0->pBandwidth;\n    tb = std::sqrt(tc);\n    obj_0->TunablePropsChanged = false;\n    obj_0->pStdDevRandWalk[0] = obj_0->RandomWalk[0] / tb;\n    obj_0->pBiasInstFilterStates[0] = 0.0;\n    obj_0->pRandWalkFilterStates[0] = 0.0;\n    obj_0->pStdDevRandWalk[1] = obj_0->RandomWalk[1] / tb;\n    obj_0->pBiasInstFilterStates[1] = 0.0;\n    obj_0->pRandWalkFilterStates[1] = 0.0;\n    obj_0->pStdDevRandWalk[2] = obj_0->RandomWalk[2] / tb;\n    obj_0->pBiasInstFilterStates[2] = 0.0;\n    obj_0->pRandWalkFilterStates[2] = 0.0;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  if (obj_0->TunablePropsChanged) {\n    obj_0->TunablePropsChanged = false;\n    equal = obj_0->tunablePropertyChanged[3];\n    if (equal) {\n      for (i = 0; i < 9; i++) {\n        obj_0->pGain[i] = obj_0->AxesMisalignment[i] / 100.0;\n      }\n    }\n\n    equal = obj_0->tunablePropertyChanged[4];\n    guard1 = false;\n    if (equal) {\n      guard1 = true;\n    } else {\n      equal = obj_0->tunablePropertyChanged[8];\n      if (equal) {\n        guard1 = true;\n      }\n    }\n\n    if (guard1) {\n      for (i = 0; i < 12; i++) {\n        obj1_Value[i] = obj_0->NoiseType.Value[i];\n      }\n\n      equal = false;\n      b_colIdx = 1;\n      do {\n        exitg1 = 0;\n        if (b_colIdx - 1 < 12) {\n          i = b_colIdx - 1;\n          if (obj1_Value[i] != tmp_3[i]) {\n            exitg1 = 1;\n          } else {\n            b_colIdx++;\n          }\n        } else {\n          equal = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n\n      if (equal) {\n        obj_0->pBandwidth = 500.0;\n      } else {\n        obj_0->pBandwidth = 1000.0;\n      }\n\n      tc = obj_0->pBandwidth;\n      tb = std::sqrt(tc);\n      obj_0->pStdDevWhiteNoise[0] = tb * obj_0->NoiseDensity[0];\n      obj_0->pStdDevWhiteNoise[1] = tb * obj_0->NoiseDensity[1];\n      obj_0->pStdDevWhiteNoise[2] = tb * obj_0->NoiseDensity[2];\n    }\n\n    equal = obj_0->tunablePropertyChanged[5];\n    if (equal) {\n      tc = 2.0 / (1000.0 * obj_0->pCorrelationTime);\n      tb = std::sqrt(tc);\n      obj_0->pStdDevBiasInst[0] = tb * obj_0->BiasInstability[0];\n      obj_0->pStdDevBiasInst[1] = tb * obj_0->BiasInstability[1];\n      obj_0->pStdDevBiasInst[2] = tb * obj_0->BiasInstability[2];\n    }\n\n    equal = obj_0->tunablePropertyChanged[6];\n    guard1 = false;\n    if (equal) {\n      guard1 = true;\n    } else {\n      equal = obj_0->tunablePropertyChanged[8];\n      if (equal) {\n        guard1 = true;\n      }\n    }\n\n    if (guard1) {\n      for (i = 0; i < 12; i++) {\n        obj1_Value[i] = obj_0->NoiseType.Value[i];\n      }\n\n      equal = false;\n      b_colIdx = 1;\n      do {\n        exitg1 = 0;\n        if (b_colIdx - 1 < 12) {\n          i = b_colIdx - 1;\n          if (obj1_Value[i] != tmp_3[i]) {\n            exitg1 = 1;\n          } else {\n            b_colIdx++;\n          }\n        } else {\n          equal = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n\n      if (equal) {\n        obj_0->pBandwidth = 500.0;\n      } else {\n        obj_0->pBandwidth = 1000.0;\n      }\n\n      tc = obj_0->pBandwidth;\n      tb = std::sqrt(tc);\n      obj_0->pStdDevRandWalk[0] = obj_0->RandomWalk[0] / tb;\n      obj_0->pStdDevRandWalk[1] = obj_0->RandomWalk[1] / tb;\n      obj_0->pStdDevRandWalk[2] = obj_0->RandomWalk[2] / tb;\n    }\n\n    equal = obj_0->tunablePropertyChanged[7];\n    if (equal) {\n      tb = obj_0->BiasInstabilityCoefficients.Numerator;\n      obj_0->pBiasInstFilterNum = tb;\n      tb = obj_0->BiasInstabilityCoefficients.Denominator[0];\n      obj_0->pBiasInstFilterDen[0] = tb;\n      tb = obj_0->BiasInstabilityCoefficients.Denominator[1];\n      obj_0->pBiasInstFilterDen[1] = tb;\n    }\n\n    for (i = 0; i < 12; i++) {\n      obj_0->tunablePropertyChanged[i] = false;\n    }\n  }\n\n  for (i = 0; i < 9; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    a_1[i] = obj_0->pGain[i];\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  n = magneticfield[0];\n  aasq = magneticfield[1];\n  bd2 = magneticfield[2];\n  for (i = 0; i <= 0; i += 2) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp = _mm_loadu_pd(&rmat[i]);\n    tmp = _mm_mul_pd(tmp, _mm_set1_pd(n));\n    tmp_0 = _mm_loadu_pd(&rmat[i + 3]);\n    tmp_0 = _mm_mul_pd(tmp_0, _mm_set1_pd(aasq));\n    tmp = _mm_add_pd(tmp_0, tmp);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp_0 = _mm_loadu_pd(&rmat[i + 6]);\n    tmp_0 = _mm_mul_pd(tmp_0, _mm_set1_pd(bd2));\n    tmp = _mm_add_pd(tmp_0, tmp);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    _mm_storeu_pd(&rmat_0[i], tmp);\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  for (i = 2; i < 3; i++) {\n    tb = rmat[i] * n;\n    tb += rmat[i + 3] * aasq;\n    tb += rmat[i + 6] * bd2;\n    rmat_0[i] = tb;\n  }\n\n  tb = rmat_0[0];\n  bd2 = rmat_0[1];\n  cd2 = rmat_0[2];\n  for (b_colIdx = 0; b_colIdx < 3; b_colIdx++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    aasq = a_1[b_colIdx] * tb;\n    aasq += a_1[b_colIdx + 3] * bd2;\n    aasq += a_1[b_colIdx + 6] * cd2;\n    n = obj_0->ConstantBias[b_colIdx];\n    magneticfield[b_colIdx] = aasq + n;\n    n = obj_0->pStdDevBiasInst[b_colIdx];\n    temperatureDrift[b_colIdx] = allRandData[b_colIdx + 18] * n;\n  }\n\n  for (i = 0; i < 2; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj_1[i] = obj_0->pBiasInstFilterDen[i];\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  simulation_filter(obj_0->pBiasInstFilterNum, obj_1, temperatureDrift,\n                    obj_0->pBiasInstFilterStates, rmat_0, a_0);\n  n = a_0[0];\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  obj_0->pBiasInstFilterStates[0] = n;\n  n = obj_0->pStdDevWhiteNoise[0];\n  tb = allRandData[21] * n;\n  n = obj_0->pStdDevRandWalk[0];\n  n *= allRandData[24];\n  cd2 = obj_0->pRandWalkFilterStates[0];\n  tc = n;\n  n = a_0[1];\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  obj_0->pBiasInstFilterStates[1] = n;\n  n = obj_0->pStdDevWhiteNoise[1];\n  aasq = allRandData[22] * n;\n  n = obj_0->pStdDevRandWalk[1];\n  n *= allRandData[25];\n  ab2 = obj_0->pRandWalkFilterStates[1];\n  ac2 = n;\n  n = a_0[2];\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  obj_0->pBiasInstFilterStates[2] = n;\n  n = obj_0->pStdDevWhiteNoise[2];\n  bd2 = allRandData[23] * n;\n  n = obj_0->pStdDevRandWalk[2];\n  n *= allRandData[26];\n  ad2 = obj_0->pRandWalkFilterStates[2];\n  bc2 = n;\n  tc += cd2;\n  ac2 += ab2;\n  bc2 += ad2;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  n = obj_0->Temperature - 25.0;\n  obj_0->pRandWalkFilterStates[0] = tc;\n  a_0[0] = n * obj_0->TemperatureBias[0];\n  obj_0->pRandWalkFilterStates[1] = ac2;\n  a_0[1] = n * obj_0->TemperatureBias[1];\n  obj_0->pRandWalkFilterStates[2] = bc2;\n  a_0[2] = n * obj_0->TemperatureBias[2];\n  temperatureDrift[0] = a_0[0];\n  temperatureDrift[1] = a_0[1];\n  temperatureDrift[2] = a_0[2];\n  n = (obj_0->Temperature - 25.0) * 0.01;\n  a_0[0] = n * obj_0->TemperatureScaleFactor[0] + 1.0;\n  a_0[1] = n * obj_0->TemperatureScaleFactor[1] + 1.0;\n  a_0[2] = n * obj_0->TemperatureScaleFactor[2] + 1.0;\n  m[0] = a_0[0];\n  m[1] = a_0[1];\n  m[2] = a_0[2];\n  m[0] *= (((tb + rmat_0[0]) + tc) + temperatureDrift[0]) + magneticfield[0];\n  m[1] *= (((aasq + rmat_0[1]) + ac2) + temperatureDrift[1]) + magneticfield[1];\n  m[2] *= (((bd2 + rmat_0[2]) + bc2) + temperatureDrift[2]) + magneticfield[2];\n  tc = obj_0->MeasurementRange;\n  if (!std::isinf(tc)) {\n    tb = obj_0->MeasurementRange;\n    n = std::abs(m[0]);\n    rmat_0[0] = n;\n    aasq = std::abs(m[1]);\n    rmat_0[1] = aasq;\n    bd2 = std::abs(m[2]);\n    rmat_0[2] = bd2;\n    b_colIdx = 0;\n    for (i = 0; i < 3; i++) {\n      if (rmat_0[i] > tb) {\n        b_data[b_colIdx] = static_cast<int8_T>(i);\n        b_colIdx++;\n      }\n    }\n\n    rmat_0[0] = n;\n    rmat_0[1] = aasq;\n    rmat_0[2] = bd2;\n    b_colIdx = 0;\n    for (i = 0; i < 3; i++) {\n      if (rmat_0[i] > tb) {\n        b_colIdx++;\n      }\n    }\n\n    tmp_size_idx_1 = b_colIdx;\n    b_colIdx = 0;\n    for (i = 0; i < 3; i++) {\n      if (rmat_0[i] > tb) {\n        tmp_data[b_colIdx] = static_cast<int8_T>(i);\n        b_colIdx++;\n      }\n    }\n\n    b_colIdx = tmp_size_idx_1;\n    for (i = 0; i < b_colIdx; i++) {\n      a_0[i] = m[tmp_data[i]];\n    }\n\n    b_colIdx = 0;\n    for (i = 0; i < 3; i++) {\n      if (rmat_0[i] > tb) {\n        b_colIdx++;\n      }\n    }\n\n    b = b_colIdx - 1;\n    for (i = 0; i <= b; i++) {\n      b_colIdx = i;\n      n = a_0[b_colIdx];\n      if (std::isnan(n)) {\n        aasq = (rtNaN);\n      } else if (n < 0.0) {\n        aasq = -1.0;\n      } else {\n        aasq = (n > 0.0);\n      }\n\n      a_0[b_colIdx] = aasq;\n    }\n\n    b_colIdx = tmp_size_idx_1;\n    for (i = 0; i < b_colIdx; i++) {\n      m[b_data[i]] = a_0[i] * tb;\n    }\n  }\n\n  if (obj_0->Resolution != 0.0) {\n    tb = obj_0->Resolution;\n    m[0] /= tb;\n    m[1] /= tb;\n    m[2] /= tb;\n    m[0] = std::round(m[0]);\n    m[1] = std::round(m[1]);\n    m[2] = std::round(m[2]);\n    m[0] *= tb;\n    m[1] *= tb;\n    m[2] *= tb;\n  }\n}\n\nstatic void simulation_SystemCore_step(fusion_simulink_imuSensor_sim_T *obj,\n  const real_T varargin_1[3], const real_T varargin_2[3], const real_T\n  varargin_3[4], real_T varargout_1[3], real_T varargout_2[3], real_T\n  varargout_3[3])\n{\n  static const int32_T tmp_0[2]{ 1, 11 };\n\n  static const int32_T tmp_1[2]{ 1, 12 };\n\n  static const char_T tmp[12]{ 'd', 'o', 'u', 'b', 'l', 'e', '-', 's', 'i', 'd',\n    'e', 'd' };\n\n  g_fusion_internal_Acceleromet_T *obj_0;\n  h_fusion_internal_GyroscopeSi_T *obj_1;\n  i_fusion_internal_Magnetomete_T *obj_2;\n  real_T ap_AxesMisalignment[9];\n  real_T gp_AxesMisalignment[9];\n  real_T mp_AxesMisalignment[9];\n  real_T ap_BiasInstability[3];\n  real_T ap_ConstantBias[3];\n  real_T ap_NoiseDensity[3];\n  real_T ap_RandomWalk[3];\n  real_T ap_TemperatureBias[3];\n  real_T ap_TemperatureScaleFactor[3];\n  real_T gp_AccelerationBias[3];\n  real_T gp_BiasInstability[3];\n  real_T gp_ConstantBias[3];\n  real_T gp_NoiseDensity[3];\n  real_T gp_RandomWalk[3];\n  real_T gp_TemperatureBias[3];\n  real_T gp_TemperatureScaleFactor[3];\n  real_T mp_BiasInstability[3];\n  real_T mp_ConstantBias[3];\n  real_T mp_NoiseDensity[3];\n  real_T mp_RandomWalk[3];\n  real_T mp_TemperatureBias[3];\n  real_T mp_TemperatureScaleFactor[3];\n  real_T ap_BiasInstabilityCoefficients_[2];\n  real_T gp_BiasInstabilityCoefficients_[2];\n  real_T mp_BiasInstabilityCoefficients_[2];\n  real_T b_Numerator;\n  real_T b_Numerator_0;\n  real_T b_Numerator_1;\n  real_T val;\n  real_T val_0;\n  real_T val_1;\n  real_T val_2;\n  real_T val_3;\n  real_T val_4;\n  int32_T i;\n  char_T ap_NoiseType_Value[12];\n  char_T gp_NoiseType_Value[12];\n  char_T mp_NoiseType_Value[12];\n  boolean_T flag_1[12];\n  boolean_T flag_0[11];\n  boolean_T flag;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  if (obj->TunablePropsChanged) {\n    obj->TunablePropsChanged = false;\n    val = obj->AccelParamsMeasurementRange;\n    val_0 = obj->AccelParamsResolution;\n    ap_ConstantBias[0] = obj->AccelParamsConstantBias[0];\n    ap_ConstantBias[1] = obj->AccelParamsConstantBias[1];\n    ap_ConstantBias[2] = obj->AccelParamsConstantBias[2];\n    for (i = 0; i < 9; i++) {\n      ap_AxesMisalignment[i] = obj->AccelParamsAxesMisalignment[i];\n    }\n\n    ap_NoiseDensity[0] = obj->AccelParamsNoiseDensity[0];\n    ap_NoiseDensity[1] = obj->AccelParamsNoiseDensity[1];\n    ap_NoiseDensity[2] = obj->AccelParamsNoiseDensity[2];\n    ap_BiasInstability[0] = obj->AccelParamsBiasInstability[0];\n    ap_BiasInstability[1] = obj->AccelParamsBiasInstability[1];\n    ap_BiasInstability[2] = obj->AccelParamsBiasInstability[2];\n    ap_RandomWalk[0] = obj->AccelParamsRandomWalk[0];\n    ap_RandomWalk[1] = obj->AccelParamsRandomWalk[1];\n    ap_RandomWalk[2] = obj->AccelParamsRandomWalk[2];\n    for (i = 0; i < 12; i++) {\n      ap_NoiseType_Value[i] = tmp[i];\n    }\n\n    ap_TemperatureBias[0] = obj->AccelParamsTemperatureBias[0];\n    ap_TemperatureBias[1] = obj->AccelParamsTemperatureBias[1];\n    ap_TemperatureBias[2] = obj->AccelParamsTemperatureBias[2];\n    ap_TemperatureScaleFactor[0] = obj->AccelParamsTemperatureScaleFactor[0];\n    ap_TemperatureScaleFactor[1] = obj->AccelParamsTemperatureScaleFactor[1];\n    ap_TemperatureScaleFactor[2] = obj->AccelParamsTemperatureScaleFactor[2];\n    b_Numerator = obj->AccelParamsBiasInstabilityNumerator;\n    ap_BiasInstabilityCoefficients_[0] =\n      obj->AccelParamsBiasInstabilityDenominator[0];\n    ap_BiasInstabilityCoefficients_[1] =\n      obj->AccelParamsBiasInstabilityDenominator[1];\n    val_1 = obj->GyroParamsMeasurementRange;\n    val_2 = obj->GyroParamsResolution;\n    gp_ConstantBias[0] = obj->GyroParamsConstantBias[0];\n    gp_ConstantBias[1] = obj->GyroParamsConstantBias[1];\n    gp_ConstantBias[2] = obj->GyroParamsConstantBias[2];\n    for (i = 0; i < 9; i++) {\n      gp_AxesMisalignment[i] = obj->GyroParamsAxesMisalignment[i];\n    }\n\n    gp_NoiseDensity[0] = obj->GyroParamsNoiseDensity[0];\n    gp_NoiseDensity[1] = obj->GyroParamsNoiseDensity[1];\n    gp_NoiseDensity[2] = obj->GyroParamsNoiseDensity[2];\n    gp_BiasInstability[0] = obj->GyroParamsBiasInstability[0];\n    gp_BiasInstability[1] = obj->GyroParamsBiasInstability[1];\n    gp_BiasInstability[2] = obj->GyroParamsBiasInstability[2];\n    gp_RandomWalk[0] = obj->GyroParamsRandomWalk[0];\n    gp_RandomWalk[1] = obj->GyroParamsRandomWalk[1];\n    gp_RandomWalk[2] = obj->GyroParamsRandomWalk[2];\n    for (i = 0; i < 12; i++) {\n      gp_NoiseType_Value[i] = tmp[i];\n    }\n\n    gp_TemperatureBias[0] = obj->GyroParamsTemperatureBias[0];\n    gp_TemperatureBias[1] = obj->GyroParamsTemperatureBias[1];\n    gp_TemperatureBias[2] = obj->GyroParamsTemperatureBias[2];\n    gp_TemperatureScaleFactor[0] = obj->GyroParamsTemperatureScaleFactor[0];\n    gp_TemperatureScaleFactor[1] = obj->GyroParamsTemperatureScaleFactor[1];\n    gp_TemperatureScaleFactor[2] = obj->GyroParamsTemperatureScaleFactor[2];\n    gp_AccelerationBias[0] = obj->GyroParamsAccelerationBias[0];\n    gp_AccelerationBias[1] = obj->GyroParamsAccelerationBias[1];\n    gp_AccelerationBias[2] = obj->GyroParamsAccelerationBias[2];\n    b_Numerator_0 = obj->GyroParamsBiasInstabilityNumerator;\n    gp_BiasInstabilityCoefficients_[0] =\n      obj->GyroParamsBiasInstabilityDenominator[0];\n    gp_BiasInstabilityCoefficients_[1] =\n      obj->GyroParamsBiasInstabilityDenominator[1];\n    val_3 = obj->MagParamsMeasurementRange;\n    val_4 = obj->MagParamsResolution;\n    mp_ConstantBias[0] = obj->MagParamsConstantBias[0];\n    mp_ConstantBias[1] = obj->MagParamsConstantBias[1];\n    mp_ConstantBias[2] = obj->MagParamsConstantBias[2];\n    for (i = 0; i < 9; i++) {\n      mp_AxesMisalignment[i] = obj->MagParamsAxesMisalignment[i];\n    }\n\n    mp_NoiseDensity[0] = obj->MagParamsNoiseDensity[0];\n    mp_NoiseDensity[1] = obj->MagParamsNoiseDensity[1];\n    mp_NoiseDensity[2] = obj->MagParamsNoiseDensity[2];\n    mp_BiasInstability[0] = obj->MagParamsBiasInstability[0];\n    mp_BiasInstability[1] = obj->MagParamsBiasInstability[1];\n    mp_BiasInstability[2] = obj->MagParamsBiasInstability[2];\n    mp_RandomWalk[0] = obj->MagParamsRandomWalk[0];\n    mp_RandomWalk[1] = obj->MagParamsRandomWalk[1];\n    mp_RandomWalk[2] = obj->MagParamsRandomWalk[2];\n    for (i = 0; i < 12; i++) {\n      mp_NoiseType_Value[i] = tmp[i];\n    }\n\n    mp_TemperatureBias[0] = obj->MagParamsTemperatureBias[0];\n    mp_TemperatureBias[1] = obj->MagParamsTemperatureBias[1];\n    mp_TemperatureBias[2] = obj->MagParamsTemperatureBias[2];\n    mp_TemperatureScaleFactor[0] = obj->MagParamsTemperatureScaleFactor[0];\n    mp_TemperatureScaleFactor[1] = obj->MagParamsTemperatureScaleFactor[1];\n    mp_TemperatureScaleFactor[2] = obj->MagParamsTemperatureScaleFactor[2];\n    b_Numerator_1 = obj->MagParamsBiasInstabilityNumerator;\n    mp_BiasInstabilityCoefficients_[0] =\n      obj->MagParamsBiasInstabilityDenominator[0];\n    mp_BiasInstabilityCoefficients_[1] =\n      obj->MagParamsBiasInstabilityDenominator[1];\n    flag = obj->tunablePropertyChanged[37];\n    if (flag) {\n      obj_0 = obj->pAccel;\n      flag = (obj_0->isInitialized == 1);\n      if (flag) {\n        obj_0->TunablePropsChanged = true;\n        obj_0->tunablePropertyChanged[11] = true;\n      }\n\n      obj->pAccel->Temperature = obj->Temperature;\n      IMUSensorParameters_updateSyste(val, val_0, ap_ConstantBias,\n        ap_AxesMisalignment, ap_NoiseDensity, ap_BiasInstability, ap_RandomWalk,\n        b_Numerator, ap_BiasInstabilityCoefficients_, ap_NoiseType_Value,\n        ap_TemperatureBias, ap_TemperatureScaleFactor, obj->pAccel);\n      obj_1 = obj->pGyro;\n      flag = (obj_1->isInitialized == 1);\n      if (flag) {\n        obj_1->TunablePropsChanged = true;\n        obj_1->tunablePropertyChanged[12] = true;\n      }\n\n      obj->pGyro->Temperature = obj->Temperature;\n      IMUSensorParameters_updateSys_o(val_1, val_2, gp_ConstantBias,\n        gp_AxesMisalignment, gp_NoiseDensity, gp_BiasInstability, gp_RandomWalk,\n        b_Numerator_0, gp_BiasInstabilityCoefficients_, gp_NoiseType_Value,\n        gp_TemperatureBias, gp_TemperatureScaleFactor, gp_AccelerationBias,\n        obj->pGyro);\n      obj_2 = obj->pMag;\n      flag = (obj_2->isInitialized == 1);\n      if (flag) {\n        obj_2->TunablePropsChanged = true;\n        obj_2->tunablePropertyChanged[11] = true;\n      }\n\n      obj->pMag->Temperature = obj->Temperature;\n      IMUSensorParameters_updateSy_oi(val_3, val_4, mp_ConstantBias,\n        mp_AxesMisalignment, mp_NoiseDensity, mp_BiasInstability, mp_RandomWalk,\n        b_Numerator_1, mp_BiasInstabilityCoefficients_, mp_NoiseType_Value,\n        mp_TemperatureBias, mp_TemperatureScaleFactor, obj->pMag);\n    }\n\n    flag_0[0] = obj->tunablePropertyChanged[3];\n    flag_0[1] = obj->tunablePropertyChanged[4];\n    flag_0[2] = obj->tunablePropertyChanged[5];\n    flag_0[3] = obj->tunablePropertyChanged[6];\n    flag_0[4] = obj->tunablePropertyChanged[7];\n    flag_0[5] = obj->tunablePropertyChanged[8];\n    flag_0[6] = obj->tunablePropertyChanged[9];\n    flag_0[7] = obj->tunablePropertyChanged[10];\n    flag_0[8] = obj->tunablePropertyChanged[11];\n    flag_0[9] = obj->tunablePropertyChanged[12];\n    flag_0[10] = obj->tunablePropertyChanged[13];\n    if (simulation_vectorAny(flag_0, tmp_0)) {\n      IMUSensorParameters_updateSyste(val, val_0, ap_ConstantBias,\n        ap_AxesMisalignment, ap_NoiseDensity, ap_BiasInstability, ap_RandomWalk,\n        b_Numerator, ap_BiasInstabilityCoefficients_, ap_NoiseType_Value,\n        ap_TemperatureBias, ap_TemperatureScaleFactor, obj->pAccel);\n    }\n\n    flag_1[0] = obj->tunablePropertyChanged[14];\n    flag_1[1] = obj->tunablePropertyChanged[15];\n    flag_1[2] = obj->tunablePropertyChanged[16];\n    flag_1[3] = obj->tunablePropertyChanged[17];\n    flag_1[4] = obj->tunablePropertyChanged[18];\n    flag_1[5] = obj->tunablePropertyChanged[19];\n    flag_1[6] = obj->tunablePropertyChanged[20];\n    flag_1[7] = obj->tunablePropertyChanged[21];\n    flag_1[8] = obj->tunablePropertyChanged[22];\n    flag_1[9] = obj->tunablePropertyChanged[23];\n    flag_1[10] = obj->tunablePropertyChanged[24];\n    flag_1[11] = obj->tunablePropertyChanged[25];\n    if (simulation_vectorAny(flag_1, tmp_1)) {\n      IMUSensorParameters_updateSys_o(val_1, val_2, gp_ConstantBias,\n        gp_AxesMisalignment, gp_NoiseDensity, gp_BiasInstability, gp_RandomWalk,\n        b_Numerator_0, gp_BiasInstabilityCoefficients_, gp_NoiseType_Value,\n        gp_TemperatureBias, gp_TemperatureScaleFactor, gp_AccelerationBias,\n        obj->pGyro);\n    }\n\n    flag_0[0] = obj->tunablePropertyChanged[26];\n    flag_0[1] = obj->tunablePropertyChanged[27];\n    flag_0[2] = obj->tunablePropertyChanged[28];\n    flag_0[3] = obj->tunablePropertyChanged[29];\n    flag_0[4] = obj->tunablePropertyChanged[30];\n    flag_0[5] = obj->tunablePropertyChanged[31];\n    flag_0[6] = obj->tunablePropertyChanged[32];\n    flag_0[7] = obj->tunablePropertyChanged[33];\n    flag_0[8] = obj->tunablePropertyChanged[34];\n    flag_0[9] = obj->tunablePropertyChanged[35];\n    flag_0[10] = obj->tunablePropertyChanged[36];\n    if (simulation_vectorAny(flag_0, tmp_0)) {\n      IMUSensorParameters_updateSy_oi(val_3, val_4, mp_ConstantBias,\n        mp_AxesMisalignment, mp_NoiseDensity, mp_BiasInstability, mp_RandomWalk,\n        b_Numerator_1, mp_BiasInstabilityCoefficients_, mp_NoiseType_Value,\n        mp_TemperatureBias, mp_TemperatureScaleFactor, obj->pMag);\n    }\n\n    for (i = 0; i < 38; i++) {\n      obj->tunablePropertyChanged[i] = false;\n    }\n  }\n\n  // End of Start for MATLABSystem: '<S17>/IMU'\n  simulation_imuSensor_stepImpl(obj, varargin_1, varargin_2, varargin_3,\n    varargout_1, varargout_2, varargout_3);\n}\n\nreal_T rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u)\n{\n  uint32_T hi;\n  uint32_T lo;\n\n  // Uniform random number generator (random number between 0 and 1)\n\n  // #define IA      16807                      magic multiplier = 7^5\n  // #define IM      2147483647                 modulus = 2^31-1\n  // #define IQ      127773                     IM div IA\n  // #define IR      2836                       IM modulo IA\n  // #define S       4.656612875245797e-10      reciprocal of 2^31-1\n  // test = IA * (seed % IQ) - IR * (seed/IQ)\n  // seed = test < 0 ? (test + IM) : test\n  // return (seed*S)\n\n  lo = *u % 127773U * 16807U;\n  hi = *u / 127773U * 2836U;\n  if (lo < hi) {\n    *u = 2147483647U - (hi - lo);\n  } else {\n    *u = lo - hi;\n  }\n\n  return static_cast<real_T>(*u) * 4.6566128752457969E-10;\n}\n\nreal_T rt_nrand_Upu32_Yd_f_pw_snf(uint32_T *u)\n{\n  real_T si;\n  real_T sr;\n  real_T y;\n\n  // Normal (Gaussian) random number generator\n  do {\n    sr = 2.0 * rt_urand_Upu32_Yd_f_pw_snf(u) - 1.0;\n    si = 2.0 * rt_urand_Upu32_Yd_f_pw_snf(u) - 1.0;\n    si = sr * sr + si * si;\n  } while (si > 1.0);\n\n  y = std::sqrt(-2.0 * std::log(si) / si) * sr;\n  return y;\n}\n\nstatic void simulation_SystemCore_setup(fusion_simulink_imuSensor_sim_T *obj)\n{\n  static const char_T tmp[12]{ 'd', 'o', 'u', 'b', 'l', 'e', '-', 's', 'i', 'd',\n    'e', 'd' };\n\n  g_fusion_internal_Acceleromet_T *obj_0;\n  h_fusion_internal_GyroscopeSi_T *obj_1;\n  i_fusion_internal_Magnetomete_T *obj_2;\n  real_T ap_AxesMisalignment[9];\n  real_T ap_BiasInstability[3];\n  real_T ap_ConstantBias[3];\n  real_T ap_NoiseDensity[3];\n  real_T ap_RandomWalk[3];\n  real_T ap_TemperatureBias[3];\n  real_T ap_TemperatureScaleFactor[3];\n  real_T gp_AccelerationBias[3];\n  real_T ap_BiasInstabilityCoefficients_[2];\n  real_T b_Numerator;\n  real_T val;\n  real_T val_0;\n  int32_T i;\n  char_T ap_NoiseType_Value[12];\n  boolean_T flag;\n  obj->isInitialized = 1;\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  val = obj->AccelParamsMeasurementRange;\n  val_0 = obj->AccelParamsResolution;\n  ap_ConstantBias[0] = obj->AccelParamsConstantBias[0];\n  ap_ConstantBias[1] = obj->AccelParamsConstantBias[1];\n  ap_ConstantBias[2] = obj->AccelParamsConstantBias[2];\n  for (i = 0; i < 9; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    ap_AxesMisalignment[i] = obj->AccelParamsAxesMisalignment[i];\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  ap_NoiseDensity[0] = obj->AccelParamsNoiseDensity[0];\n  ap_NoiseDensity[1] = obj->AccelParamsNoiseDensity[1];\n  ap_NoiseDensity[2] = obj->AccelParamsNoiseDensity[2];\n  ap_BiasInstability[0] = obj->AccelParamsBiasInstability[0];\n  ap_BiasInstability[1] = obj->AccelParamsBiasInstability[1];\n  ap_BiasInstability[2] = obj->AccelParamsBiasInstability[2];\n  ap_RandomWalk[0] = obj->AccelParamsRandomWalk[0];\n  ap_RandomWalk[1] = obj->AccelParamsRandomWalk[1];\n  ap_RandomWalk[2] = obj->AccelParamsRandomWalk[2];\n  for (i = 0; i < 12; i++) {\n    ap_NoiseType_Value[i] = tmp[i];\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  ap_TemperatureBias[0] = obj->AccelParamsTemperatureBias[0];\n  ap_TemperatureBias[1] = obj->AccelParamsTemperatureBias[1];\n  ap_TemperatureBias[2] = obj->AccelParamsTemperatureBias[2];\n  ap_TemperatureScaleFactor[0] = obj->AccelParamsTemperatureScaleFactor[0];\n  ap_TemperatureScaleFactor[1] = obj->AccelParamsTemperatureScaleFactor[1];\n  ap_TemperatureScaleFactor[2] = obj->AccelParamsTemperatureScaleFactor[2];\n  b_Numerator = obj->AccelParamsBiasInstabilityNumerator;\n  ap_BiasInstabilityCoefficients_[0] =\n    obj->AccelParamsBiasInstabilityDenominator[0];\n  ap_BiasInstabilityCoefficients_[1] =\n    obj->AccelParamsBiasInstabilityDenominator[1];\n  obj->_pobj2.isInitialized = 0;\n  for (i = 0; i < 12; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj->_pobj2.tunablePropertyChanged[i] = false;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  IMUSensorParameters_updateSyste(val, val_0, ap_ConstantBias,\n    ap_AxesMisalignment, ap_NoiseDensity, ap_BiasInstability, ap_RandomWalk,\n    b_Numerator, ap_BiasInstabilityCoefficients_, ap_NoiseType_Value,\n    ap_TemperatureBias, ap_TemperatureScaleFactor, &obj->_pobj2);\n  obj->pAccel = &obj->_pobj2;\n  obj_0 = obj->pAccel;\n  flag = (obj_0->isInitialized == 1);\n  if (flag) {\n    obj_0->TunablePropsChanged = true;\n    obj_0->tunablePropertyChanged[11] = true;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  obj->pAccel->Temperature = obj->Temperature;\n  val = obj->GyroParamsMeasurementRange;\n  val_0 = obj->GyroParamsResolution;\n  ap_ConstantBias[0] = obj->GyroParamsConstantBias[0];\n  ap_ConstantBias[1] = obj->GyroParamsConstantBias[1];\n  ap_ConstantBias[2] = obj->GyroParamsConstantBias[2];\n  for (i = 0; i < 9; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    ap_AxesMisalignment[i] = obj->GyroParamsAxesMisalignment[i];\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  ap_NoiseDensity[0] = obj->GyroParamsNoiseDensity[0];\n  ap_NoiseDensity[1] = obj->GyroParamsNoiseDensity[1];\n  ap_NoiseDensity[2] = obj->GyroParamsNoiseDensity[2];\n  ap_BiasInstability[0] = obj->GyroParamsBiasInstability[0];\n  ap_BiasInstability[1] = obj->GyroParamsBiasInstability[1];\n  ap_BiasInstability[2] = obj->GyroParamsBiasInstability[2];\n  ap_RandomWalk[0] = obj->GyroParamsRandomWalk[0];\n  ap_RandomWalk[1] = obj->GyroParamsRandomWalk[1];\n  ap_RandomWalk[2] = obj->GyroParamsRandomWalk[2];\n  for (i = 0; i < 12; i++) {\n    ap_NoiseType_Value[i] = tmp[i];\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  ap_TemperatureBias[0] = obj->GyroParamsTemperatureBias[0];\n  ap_TemperatureBias[1] = obj->GyroParamsTemperatureBias[1];\n  ap_TemperatureBias[2] = obj->GyroParamsTemperatureBias[2];\n  ap_TemperatureScaleFactor[0] = obj->GyroParamsTemperatureScaleFactor[0];\n  ap_TemperatureScaleFactor[1] = obj->GyroParamsTemperatureScaleFactor[1];\n  ap_TemperatureScaleFactor[2] = obj->GyroParamsTemperatureScaleFactor[2];\n  gp_AccelerationBias[0] = obj->GyroParamsAccelerationBias[0];\n  gp_AccelerationBias[1] = obj->GyroParamsAccelerationBias[1];\n  gp_AccelerationBias[2] = obj->GyroParamsAccelerationBias[2];\n  b_Numerator = obj->GyroParamsBiasInstabilityNumerator;\n  ap_BiasInstabilityCoefficients_[0] = obj->\n    GyroParamsBiasInstabilityDenominator[0];\n  ap_BiasInstabilityCoefficients_[1] = obj->\n    GyroParamsBiasInstabilityDenominator[1];\n  obj->_pobj1.isInitialized = 0;\n  for (i = 0; i < 13; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj->_pobj1.tunablePropertyChanged[i] = false;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  IMUSensorParameters_updateSys_o(val, val_0, ap_ConstantBias,\n    ap_AxesMisalignment, ap_NoiseDensity, ap_BiasInstability, ap_RandomWalk,\n    b_Numerator, ap_BiasInstabilityCoefficients_, ap_NoiseType_Value,\n    ap_TemperatureBias, ap_TemperatureScaleFactor, gp_AccelerationBias,\n    &obj->_pobj1);\n  obj->pGyro = &obj->_pobj1;\n  obj_1 = obj->pGyro;\n  flag = (obj_1->isInitialized == 1);\n  if (flag) {\n    obj_1->TunablePropsChanged = true;\n    obj_1->tunablePropertyChanged[12] = true;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  obj->pGyro->Temperature = obj->Temperature;\n  val = obj->MagParamsMeasurementRange;\n  val_0 = obj->MagParamsResolution;\n  ap_ConstantBias[0] = obj->MagParamsConstantBias[0];\n  ap_ConstantBias[1] = obj->MagParamsConstantBias[1];\n  ap_ConstantBias[2] = obj->MagParamsConstantBias[2];\n  for (i = 0; i < 9; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    ap_AxesMisalignment[i] = obj->MagParamsAxesMisalignment[i];\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  ap_NoiseDensity[0] = obj->MagParamsNoiseDensity[0];\n  ap_NoiseDensity[1] = obj->MagParamsNoiseDensity[1];\n  ap_NoiseDensity[2] = obj->MagParamsNoiseDensity[2];\n  ap_BiasInstability[0] = obj->MagParamsBiasInstability[0];\n  ap_BiasInstability[1] = obj->MagParamsBiasInstability[1];\n  ap_BiasInstability[2] = obj->MagParamsBiasInstability[2];\n  ap_RandomWalk[0] = obj->MagParamsRandomWalk[0];\n  ap_RandomWalk[1] = obj->MagParamsRandomWalk[1];\n  ap_RandomWalk[2] = obj->MagParamsRandomWalk[2];\n  for (i = 0; i < 12; i++) {\n    ap_NoiseType_Value[i] = tmp[i];\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  ap_TemperatureBias[0] = obj->MagParamsTemperatureBias[0];\n  ap_TemperatureBias[1] = obj->MagParamsTemperatureBias[1];\n  ap_TemperatureBias[2] = obj->MagParamsTemperatureBias[2];\n  ap_TemperatureScaleFactor[0] = obj->MagParamsTemperatureScaleFactor[0];\n  ap_TemperatureScaleFactor[1] = obj->MagParamsTemperatureScaleFactor[1];\n  ap_TemperatureScaleFactor[2] = obj->MagParamsTemperatureScaleFactor[2];\n  b_Numerator = obj->MagParamsBiasInstabilityNumerator;\n  ap_BiasInstabilityCoefficients_[0] = obj->MagParamsBiasInstabilityDenominator\n    [0];\n  ap_BiasInstabilityCoefficients_[1] = obj->MagParamsBiasInstabilityDenominator\n    [1];\n  obj->_pobj0.isInitialized = 0;\n  for (i = 0; i < 12; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj->_pobj0.tunablePropertyChanged[i] = false;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  IMUSensorParameters_updateSy_oi(val, val_0, ap_ConstantBias,\n    ap_AxesMisalignment, ap_NoiseDensity, ap_BiasInstability, ap_RandomWalk,\n    b_Numerator, ap_BiasInstabilityCoefficients_, ap_NoiseType_Value,\n    ap_TemperatureBias, ap_TemperatureScaleFactor, &obj->_pobj0);\n  obj->pMag = &obj->_pobj0;\n  obj_2 = obj->pMag;\n  flag = (obj_2->isInitialized == 1);\n  if (flag) {\n    obj_2->TunablePropsChanged = true;\n    obj_2->tunablePropertyChanged[11] = true;\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  obj->pMag->Temperature = obj->Temperature;\n  obj->TunablePropsChanged = false;\n}\n\nstatic void simulat_IMUSensorBase_resetImpl(fusion_simulink_imuSensor_sim_T *obj)\n{\n  g_fusion_internal_Acceleromet_T *obj_0;\n  h_fusion_internal_GyroscopeSi_T *obj_1;\n  i_fusion_internal_Magnetomete_T *obj_2;\n  uint32_T b_state[625];\n  uint32_T r;\n  boolean_T flag;\n  for (int32_T i{0}; i < 625; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj->pStreamState[i] = 0U;\n  }\n\n  for (int32_T i{0}; i < 625; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    b_state[i] = obj->pStreamState[i];\n  }\n\n  r = 67U;\n  b_state[0] = 67U;\n  for (int32_T i{0}; i < 623; i++) {\n    int32_T tmp;\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    tmp = i + 1;\n    r = (r >> 30U ^ r) * 1812433253U + static_cast<uint32_T>(tmp);\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    b_state[i + 1] = r;\n  }\n\n  b_state[624] = 624U;\n  for (int32_T i{0}; i < 625; i++) {\n    // Start for MATLABSystem: '<S17>/IMU'\n    obj->pStreamState[i] = b_state[i];\n  }\n\n  // Start for MATLABSystem: '<S17>/IMU'\n  flag = (obj->isInitialized == 1);\n  if (flag) {\n    obj_0 = obj->pAccel;\n    if (obj_0->isInitialized == 1) {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj_0->pBiasInstFilterStates[0] = 0.0;\n      obj_0->pRandWalkFilterStates[0] = 0.0;\n      obj_0->pBiasInstFilterStates[1] = 0.0;\n      obj_0->pRandWalkFilterStates[1] = 0.0;\n      obj_0->pBiasInstFilterStates[2] = 0.0;\n      obj_0->pRandWalkFilterStates[2] = 0.0;\n    }\n\n    obj_1 = obj->pGyro;\n    if (obj_1->isInitialized == 1) {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj_1->pBiasInstFilterStates[0] = 0.0;\n      obj_1->pRandWalkFilterStates[0] = 0.0;\n      obj_1->pBiasInstFilterStates[1] = 0.0;\n      obj_1->pRandWalkFilterStates[1] = 0.0;\n      obj_1->pBiasInstFilterStates[2] = 0.0;\n      obj_1->pRandWalkFilterStates[2] = 0.0;\n    }\n\n    obj_2 = obj->pMag;\n    if (obj_2->isInitialized == 1) {\n      // Start for MATLABSystem: '<S17>/IMU'\n      obj_2->pBiasInstFilterStates[0] = 0.0;\n      obj_2->pRandWalkFilterStates[0] = 0.0;\n      obj_2->pBiasInstFilterStates[1] = 0.0;\n      obj_2->pRandWalkFilterStates[1] = 0.0;\n      obj_2->pBiasInstFilterStates[2] = 0.0;\n      obj_2->pRandWalkFilterStates[2] = 0.0;\n    }\n  }\n}\n\n// Model step function\nvoid simulation_step(void)\n{\n  if (rtmIsMajorTimeStep(simulation_M)) {\n    // set solver stop time\n    rtsiSetSolverStopTime(&simulation_M->solverInfo,\n                          ((simulation_M->Timing.clockTick0+1)*\n      simulation_M->Timing.stepSize0));\n  }                                    // end MajorTimeStep\n\n  // Update absolute time of base rate at minor time step\n  if (rtmIsMinorTimeStep(simulation_M)) {\n    simulation_M->Timing.t[0] = rtsiGetT(&simulation_M->solverInfo);\n  }\n\n  {\n    NeslSimulationData *simulationData;\n    NeslSimulator *simulator;\n    NeuDiagnosticManager *diagnosticManager;\n    NeuDiagnosticTree *diagnosticTree;\n    char *msg;\n    real_T tmp_1[47];\n    real_T tmp_3[47];\n    real_T tmp[20];\n    real_T x[6];\n    real_T y[6];\n    real_T tmp_5[3];\n    real_T tmp_6[3];\n    real_T tmp_7[3];\n    real_T time;\n    real_T time_0;\n    real_T time_1;\n    real_T time_2;\n    real_T time_3;\n    real_T time_4;\n    real_T tmp_8;\n    real_T xtmp;\n    int32_T exitg1;\n    int32_T high_i;\n    int32_T low_i;\n    int32_T low_ip1;\n    int32_T mid_i;\n    int_T tmp_2[7];\n    int_T tmp_4[7];\n    int_T tmp_0[6];\n    int8_T rtAction;\n    boolean_T first_output;\n    if (rtmIsMajorTimeStep(simulation_M) &&\n        simulation_M->Timing.TaskCounters.TID[2] == 0) {\n      // RandomNumber: '<S36>/Random Number'\n      simulation_B.RandomNumber = simulation_DW.NextOutput;\n    }\n\n    if (rtmIsMajorTimeStep(simulation_M) &&\n        simulation_M->Timing.TaskCounters.TID[1] == 0) {\n      // UnitDelay: '<S62>/Unit Delay'\n      simulation_B.UnitDelay = simulation_DW.UnitDelay_DSTATE;\n    }\n\n    // Abs: '<S62>/Abs' incorporates:\n    //   Inport: '<Root>/tvc x angle'\n\n    simulation_B.Abs = std::abs(simulation_U.tvcxangle);\n\n    // Switch: '<S62>/Switch'\n    if (simulation_B.Abs > 0.15) {\n      // Switch: '<S62>/Switch'\n      simulation_B.Switch = simulation_B.UnitDelay;\n    } else {\n      // Switch: '<S62>/Switch' incorporates:\n      //   Inport: '<Root>/tvc x angle'\n\n      simulation_B.Switch = simulation_U.tvcxangle;\n    }\n\n    // End of Switch: '<S62>/Switch'\n\n    // SimscapeInputBlock: '<S69>/INPUT_4_1_1'\n    if (simulation_DW.INPUT_4_1_1_FirstOutput == 0.0) {\n      simulation_DW.INPUT_4_1_1_FirstOutput = 1.0;\n      simulation_X.simulationPlantTVC_PhysicsSimul[0] = simulation_B.Switch;\n      simulation_X.simulationPlantTVC_PhysicsSimul[1] = 0.0;\n    }\n\n    simulation_B.INPUT_4_1_1[0] = simulation_X.simulationPlantTVC_PhysicsSimul[0];\n    simulation_B.INPUT_4_1_1[1] = simulation_X.simulationPlantTVC_PhysicsSimul[1];\n    simulation_B.INPUT_4_1_1[2] = ((simulation_B.Switch -\n      simulation_X.simulationPlantTVC_PhysicsSimul[0]) * 20.0 - 2.0 *\n      simulation_X.simulationPlantTVC_PhysicsSimul[1]) * 20.0;\n    simulation_B.INPUT_4_1_1[3] = 0.0;\n\n    // End of SimscapeInputBlock: '<S69>/INPUT_4_1_1'\n    if (rtmIsMajorTimeStep(simulation_M) &&\n        simulation_M->Timing.TaskCounters.TID[1] == 0) {\n      // UnitDelay: '<S62>/Unit Delay1'\n      simulation_B.UnitDelay1 = simulation_DW.UnitDelay1_DSTATE;\n    }\n\n    // Abs: '<S62>/Abs1' incorporates:\n    //   Inport: '<Root>/tvc y angle'\n\n    simulation_B.Abs1 = std::abs(simulation_U.tvcyangle);\n\n    // Switch: '<S62>/Switch1'\n    if (simulation_B.Abs1 > 0.15) {\n      // Switch: '<S62>/Switch1'\n      simulation_B.Switch1 = simulation_B.UnitDelay1;\n    } else {\n      // Switch: '<S62>/Switch1' incorporates:\n      //   Inport: '<Root>/tvc y angle'\n\n      simulation_B.Switch1 = simulation_U.tvcyangle;\n    }\n\n    // End of Switch: '<S62>/Switch1'\n\n    // SimscapeInputBlock: '<S69>/INPUT_5_1_1'\n    if (simulation_DW.INPUT_5_1_1_FirstOutput == 0.0) {\n      simulation_DW.INPUT_5_1_1_FirstOutput = 1.0;\n      simulation_X.simulationPlantTVC_PhysicsSim_a[0] = simulation_B.Switch1;\n      simulation_X.simulationPlantTVC_PhysicsSim_a[1] = 0.0;\n    }\n\n    simulation_B.INPUT_5_1_1[0] = simulation_X.simulationPlantTVC_PhysicsSim_a[0];\n    simulation_B.INPUT_5_1_1[1] = simulation_X.simulationPlantTVC_PhysicsSim_a[1];\n    simulation_B.INPUT_5_1_1[2] = ((simulation_B.Switch1 -\n      simulation_X.simulationPlantTVC_PhysicsSim_a[0]) * 20.0 - 2.0 *\n      simulation_X.simulationPlantTVC_PhysicsSim_a[1]) * 20.0;\n    simulation_B.INPUT_5_1_1[3] = 0.0;\n\n    // End of SimscapeInputBlock: '<S69>/INPUT_5_1_1'\n    if (rtmIsMajorTimeStep(simulation_M) &&\n        simulation_M->Timing.TaskCounters.TID[1] == 0) {\n      // UnitDelay: '<S5>/Unit Delay'\n      simulation_B.UnitDelay_k = simulation_DW.UnitDelay_DSTATE_m;\n\n      // UnitDelay: '<S5>/Unit Delay1'\n      simulation_B.UnitDelay1_p = simulation_DW.UnitDelay1_DSTATE_j;\n\n      // Chart: '<S5>/Discretizer' incorporates:\n      //   Inport: '<Root>/ignite_s1'\n      //   Inport: '<Root>/ignite_s2'\n\n      if (simulation_DW.temporalCounter_i1 < MAX_uint32_T) {\n        simulation_DW.temporalCounter_i1++;\n      }\n\n      if (simulation_DW.is_active_c3_simulation == 0U) {\n        simulation_DW.is_active_c3_simulation = 1U;\n        simulation_DW.is_c3_simulation = simulation_IN_S0;\n        simulation_B.attached = 0.0;\n        simulation_B.s1_et = 0.0;\n        simulation_B.s2_et = 0.0;\n      } else {\n        switch (simulation_DW.is_c3_simulation) {\n         case simulation_IN_Detached:\n          simulation_B.attached = -1.0;\n          if (simulation_U.ignite_s2 != 0.0) {\n            simulation_DW.temporalCounter_i1 = 0U;\n            simulation_DW.is_c3_simulation = simulation_IN_S2_Fire;\n          }\n          break;\n\n         case simulation_IN_Idle:\n          break;\n\n         case simulation_IN_S0:\n          simulation_B.attached = 0.0;\n          if (simulation_U.ignite_s1 != 0.0) {\n            simulation_DW.temporalCounter_i1 = 0U;\n            simulation_DW.is_c3_simulation = simulation_IN_S1_fire;\n            simulation_DW.is_S1_fire = simulation_IN_S1_Ignite;\n          }\n          break;\n\n         case simulation_IN_S1_fire:\n          simulation_B.s1_et = static_cast<real_T>\n            (simulation_DW.temporalCounter_i1) * 0.001;\n          if (simulation_DW.is_S1_fire == simulation_IN_S1_Ignite) {\n            if (simulation_B.UnitDelay_k > 0.0) {\n              simulation_DW.is_S1_fire = simulation_IN_S1_engaged;\n            }\n\n            // case IN_S1_engaged:\n          } else if (simulation_B.UnitDelay_k <= 0.0) {\n            simulation_DW.is_S1_fire = simulation_IN_NO_ACTIVE_CHILD;\n            simulation_DW.is_c3_simulation = simulation_IN_Detached;\n            simulation_B.attached = -1.0;\n          }\n          break;\n\n         default:\n          // case IN_S2_Fire:\n          if (simulation_B.UnitDelay1_p < 0.0) {\n            simulation_DW.is_c3_simulation = simulation_IN_Idle;\n          } else {\n            simulation_B.s2_et = static_cast<real_T>\n              (simulation_DW.temporalCounter_i1) * 0.001;\n          }\n          break;\n        }\n      }\n\n      // End of Chart: '<S5>/Discretizer'\n    }\n\n    // SimscapeInputBlock: '<S69>/INPUT_1_1_1'\n    simulation_B.INPUT_1_1_1[0] = simulation_B.attached;\n    simulation_B.INPUT_1_1_1[1] = 0.0;\n    simulation_B.INPUT_1_1_1[2] = 0.0;\n    if (rtmIsMajorTimeStep(simulation_M)) {\n      simulation_DW.INPUT_1_1_1_Discrete[0] = !(simulation_B.INPUT_1_1_1[0] ==\n        simulation_DW.INPUT_1_1_1_Discrete[1]);\n      simulation_DW.INPUT_1_1_1_Discrete[1] = simulation_B.INPUT_1_1_1[0];\n    }\n\n    simulation_B.INPUT_1_1_1[0] = simulation_DW.INPUT_1_1_1_Discrete[1];\n    simulation_B.INPUT_1_1_1[3] = simulation_DW.INPUT_1_1_1_Discrete[0];\n\n    // End of SimscapeInputBlock: '<S69>/INPUT_1_1_1'\n\n    // SimscapeExecutionBlock: '<S69>/STATE_1'\n    simulationData = static_cast<NeslSimulationData *>\n      (simulation_DW.STATE_1_SimData);\n    time = simulation_M->Timing.t[0];\n    simulationData->mData->mTime.mN = 1;\n    simulationData->mData->mTime.mX = &time;\n    simulationData->mData->mContStates.mN = 26;\n    simulationData->mData->mContStates.mX =\n      &simulation_X.simulationPlantRocket_BodyFree_[0];\n    simulationData->mData->mDiscStates.mN = 0;\n    simulationData->mData->mDiscStates.mX = &simulation_DW.STATE_1_Discrete;\n    simulationData->mData->mModeVector.mN = 1;\n    simulationData->mData->mModeVector.mX = &simulation_DW.STATE_1_Modes;\n    first_output = false;\n    simulationData->mData->mFoundZcEvents = first_output;\n    simulationData->mData->mIsMajorTimeStep = rtmIsMajorTimeStep(simulation_M);\n    first_output = false;\n    simulationData->mData->mIsSolverAssertCheck = first_output;\n    simulationData->mData->mIsSolverCheckingCIC = false;\n    first_output = rtsiIsSolverComputingJacobian(&simulation_M->solverInfo);\n    simulationData->mData->mIsComputingJacobian = first_output;\n    simulationData->mData->mIsEvaluatingF0 = false;\n    simulationData->mData->mIsSolverRequestingReset = false;\n    simulationData->mData->mIsModeUpdateTimeStep = rtsiIsModeUpdateTimeStep\n      (&simulation_M->solverInfo);\n    tmp_0[0] = 0;\n    tmp[0] = simulation_B.INPUT_4_1_1[0];\n    tmp[1] = simulation_B.INPUT_4_1_1[1];\n    tmp[2] = simulation_B.INPUT_4_1_1[2];\n    tmp[3] = simulation_B.INPUT_4_1_1[3];\n    tmp_0[1] = 4;\n    tmp[4] = simulation_B.INPUT_5_1_1[0];\n    tmp[5] = simulation_B.INPUT_5_1_1[1];\n    tmp[6] = simulation_B.INPUT_5_1_1[2];\n    tmp[7] = simulation_B.INPUT_5_1_1[3];\n    tmp_0[2] = 8;\n    tmp[8] = simulation_B.INPUT_1_1_1[0];\n    tmp[9] = simulation_B.INPUT_1_1_1[1];\n    tmp[10] = simulation_B.INPUT_1_1_1[2];\n    tmp[11] = simulation_B.INPUT_1_1_1[3];\n    tmp_0[3] = 12;\n    tmp[12] = simulation_B.INPUT_2_1_1[0];\n    tmp[13] = simulation_B.INPUT_2_1_1[1];\n    tmp[14] = simulation_B.INPUT_2_1_1[2];\n    tmp[15] = simulation_B.INPUT_2_1_1[3];\n    tmp_0[4] = 16;\n    tmp[16] = simulation_B.INPUT_3_1_1[0];\n    tmp[17] = simulation_B.INPUT_3_1_1[1];\n    tmp[18] = simulation_B.INPUT_3_1_1[2];\n    tmp[19] = simulation_B.INPUT_3_1_1[3];\n    tmp_0[5] = 20;\n    simulationData->mData->mInputValues.mN = 20;\n    simulationData->mData->mInputValues.mX = &tmp[0];\n    simulationData->mData->mInputOffsets.mN = 6;\n    simulationData->mData->mInputOffsets.mX = &tmp_0[0];\n    simulationData->mData->mOutputs.mN = 27;\n    simulationData->mData->mOutputs.mX = &simulation_B.STATE_1[0];\n    simulationData->mData->mTolerances.mN = 0;\n    simulationData->mData->mTolerances.mX = nullptr;\n    simulationData->mData->mCstateHasChanged = false;\n    time_0 = simulation_M->Timing.t[0];\n    simulationData->mData->mTime.mN = 1;\n    simulationData->mData->mTime.mX = &time_0;\n    simulationData->mData->mSampleHits.mN = 0;\n    simulationData->mData->mSampleHits.mX = nullptr;\n    simulationData->mData->mIsFundamentalSampleHit = false;\n    simulator = static_cast<NeslSimulator *>(simulation_DW.STATE_1_Simulator);\n    diagnosticManager = static_cast<NeuDiagnosticManager *>\n      (simulation_DW.STATE_1_DiagMgr);\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\n    high_i = ne_simulator_method(simulator, NESL_SIM_OUTPUTS, simulationData,\n      diagnosticManager);\n    if (high_i != 0) {\n      first_output = error_buffer_is_empty(rtmGetErrorStatus(simulation_M));\n      if (first_output) {\n        msg = rtw_diagnostics_msg(diagnosticTree);\n        rtmSetErrorStatus(simulation_M, msg);\n      }\n    }\n\n    // End of SimscapeExecutionBlock: '<S69>/STATE_1'\n\n    // SimscapeExecutionBlock: '<S69>/OUTPUT_1_0'\n    simulationData = static_cast<NeslSimulationData *>\n      (simulation_DW.OUTPUT_1_0_SimData);\n    time_1 = simulation_M->Timing.t[0];\n    simulationData->mData->mTime.mN = 1;\n    simulationData->mData->mTime.mX = &time_1;\n    simulationData->mData->mContStates.mN = 0;\n    simulationData->mData->mContStates.mX = nullptr;\n    simulationData->mData->mDiscStates.mN = 0;\n    simulationData->mData->mDiscStates.mX = &simulation_DW.OUTPUT_1_0_Discrete;\n    simulationData->mData->mModeVector.mN = 0;\n    simulationData->mData->mModeVector.mX = &simulation_DW.OUTPUT_1_0_Modes;\n    first_output = false;\n    simulationData->mData->mFoundZcEvents = first_output;\n    simulationData->mData->mIsMajorTimeStep = rtmIsMajorTimeStep(simulation_M);\n    first_output = false;\n    simulationData->mData->mIsSolverAssertCheck = first_output;\n    simulationData->mData->mIsSolverCheckingCIC = false;\n    simulationData->mData->mIsComputingJacobian = false;\n    simulationData->mData->mIsEvaluatingF0 = false;\n    simulationData->mData->mIsSolverRequestingReset = false;\n    simulationData->mData->mIsModeUpdateTimeStep = rtsiIsModeUpdateTimeStep\n      (&simulation_M->solverInfo);\n    tmp_2[0] = 0;\n    tmp_1[0] = simulation_B.INPUT_4_1_1[0];\n    tmp_1[1] = simulation_B.INPUT_4_1_1[1];\n    tmp_1[2] = simulation_B.INPUT_4_1_1[2];\n    tmp_1[3] = simulation_B.INPUT_4_1_1[3];\n    tmp_2[1] = 4;\n    tmp_1[4] = simulation_B.INPUT_5_1_1[0];\n    tmp_1[5] = simulation_B.INPUT_5_1_1[1];\n    tmp_1[6] = simulation_B.INPUT_5_1_1[2];\n    tmp_1[7] = simulation_B.INPUT_5_1_1[3];\n    tmp_2[2] = 8;\n    tmp_1[8] = simulation_B.INPUT_1_1_1[0];\n    tmp_1[9] = simulation_B.INPUT_1_1_1[1];\n    tmp_1[10] = simulation_B.INPUT_1_1_1[2];\n    tmp_1[11] = simulation_B.INPUT_1_1_1[3];\n    tmp_2[3] = 12;\n    tmp_1[12] = simulation_B.INPUT_2_1_1[0];\n    tmp_1[13] = simulation_B.INPUT_2_1_1[1];\n    tmp_1[14] = simulation_B.INPUT_2_1_1[2];\n    tmp_1[15] = simulation_B.INPUT_2_1_1[3];\n    tmp_2[4] = 16;\n    tmp_1[16] = simulation_B.INPUT_3_1_1[0];\n    tmp_1[17] = simulation_B.INPUT_3_1_1[1];\n    tmp_1[18] = simulation_B.INPUT_3_1_1[2];\n    tmp_1[19] = simulation_B.INPUT_3_1_1[3];\n    tmp_2[5] = 20;\n    tmp_1[20] = simulation_B.STATE_1[0];\n    tmp_1[21] = simulation_B.STATE_1[1];\n    tmp_1[22] = simulation_B.STATE_1[2];\n    tmp_1[23] = simulation_B.STATE_1[3];\n    tmp_1[24] = simulation_B.STATE_1[4];\n    tmp_1[25] = simulation_B.STATE_1[5];\n    tmp_1[26] = simulation_B.STATE_1[6];\n    tmp_1[27] = simulation_B.STATE_1[7];\n    tmp_1[28] = simulation_B.STATE_1[8];\n    tmp_1[29] = simulation_B.STATE_1[9];\n    tmp_1[30] = simulation_B.STATE_1[10];\n    tmp_1[31] = simulation_B.STATE_1[11];\n    tmp_1[32] = simulation_B.STATE_1[12];\n    tmp_1[33] = simulation_B.STATE_1[13];\n    tmp_1[34] = simulation_B.STATE_1[14];\n    tmp_1[35] = simulation_B.STATE_1[15];\n    tmp_1[36] = simulation_B.STATE_1[16];\n    tmp_1[37] = simulation_B.STATE_1[17];\n    tmp_1[38] = simulation_B.STATE_1[18];\n    tmp_1[39] = simulation_B.STATE_1[19];\n    tmp_1[40] = simulation_B.STATE_1[20];\n    tmp_1[41] = simulation_B.STATE_1[21];\n    tmp_1[42] = simulation_B.STATE_1[22];\n    tmp_1[43] = simulation_B.STATE_1[23];\n    tmp_1[44] = simulation_B.STATE_1[24];\n    tmp_1[45] = simulation_B.STATE_1[25];\n    tmp_1[46] = simulation_B.STATE_1[26];\n    tmp_2[6] = 47;\n    simulationData->mData->mInputValues.mN = 47;\n    simulationData->mData->mInputValues.mX = &tmp_1[0];\n    simulationData->mData->mInputOffsets.mN = 7;\n    simulationData->mData->mInputOffsets.mX = &tmp_2[0];\n    simulationData->mData->mOutputs.mN = 18;\n    simulationData->mData->mOutputs.mX = &simulation_B.OUTPUT_1_0[0];\n    simulationData->mData->mTolerances.mN = 0;\n    simulationData->mData->mTolerances.mX = nullptr;\n    simulationData->mData->mCstateHasChanged = false;\n    time_2 = simulation_M->Timing.t[0];\n    simulationData->mData->mTime.mN = 1;\n    simulationData->mData->mTime.mX = &time_2;\n    simulationData->mData->mSampleHits.mN = 0;\n    simulationData->mData->mSampleHits.mX = nullptr;\n    simulationData->mData->mIsFundamentalSampleHit = false;\n    simulator = static_cast<NeslSimulator *>(simulation_DW.OUTPUT_1_0_Simulator);\n    diagnosticManager = static_cast<NeuDiagnosticManager *>\n      (simulation_DW.OUTPUT_1_0_DiagMgr);\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\n    high_i = ne_simulator_method(simulator, NESL_SIM_OUTPUTS, simulationData,\n      diagnosticManager);\n    if (high_i != 0) {\n      first_output = error_buffer_is_empty(rtmGetErrorStatus(simulation_M));\n      if (first_output) {\n        msg = rtw_diagnostics_msg(diagnosticTree);\n        rtmSetErrorStatus(simulation_M, msg);\n      }\n    }\n\n    // End of SimscapeExecutionBlock: '<S69>/OUTPUT_1_0'\n\n    // Product: '<S56>/Product'\n    simulation_B.Product = simulation_B.OUTPUT_1_0[6] * simulation_B.OUTPUT_1_0\n      [6];\n\n    // Product: '<S56>/Product1'\n    simulation_B.Product1 = simulation_B.OUTPUT_1_0[7] *\n      simulation_B.OUTPUT_1_0[7];\n\n    // Product: '<S56>/Product2'\n    simulation_B.Product2 = simulation_B.OUTPUT_1_0[8] *\n      simulation_B.OUTPUT_1_0[8];\n\n    // Product: '<S56>/Product3'\n    simulation_B.Product3 = simulation_B.OUTPUT_1_0[9] *\n      simulation_B.OUTPUT_1_0[9];\n\n    // Sum: '<S56>/Sum'\n    simulation_B.Sum = ((simulation_B.Product + simulation_B.Product1) +\n                        simulation_B.Product2) + simulation_B.Product3;\n\n    // Sqrt: '<S55>/sqrt'\n    simulation_B.sqrt_n = std::sqrt(simulation_B.Sum);\n\n    // Product: '<S50>/Product'\n    simulation_B.Product_d = simulation_B.OUTPUT_1_0[6] / simulation_B.sqrt_n;\n\n    // Product: '<S50>/Product1'\n    simulation_B.Product1_c = simulation_B.OUTPUT_1_0[7] / simulation_B.sqrt_n;\n\n    // Product: '<S50>/Product2'\n    simulation_B.Product2_l = simulation_B.OUTPUT_1_0[8] / simulation_B.sqrt_n;\n\n    // Product: '<S50>/Product3'\n    simulation_B.Product3_l = simulation_B.OUTPUT_1_0[9] / simulation_B.sqrt_n;\n\n    // Fcn: '<S46>/fcn1'\n    simulation_B.fcn1 = (simulation_B.Product2_l * simulation_B.Product3_l -\n                         simulation_B.Product_d * simulation_B.Product1_c) *\n      -2.0;\n\n    // Fcn: '<S46>/fcn2'\n    simulation_B.fcn2 = ((simulation_B.Product_d * simulation_B.Product_d -\n                          simulation_B.Product1_c * simulation_B.Product1_c) -\n                         simulation_B.Product2_l * simulation_B.Product2_l) +\n      simulation_B.Product3_l * simulation_B.Product3_l;\n\n    // Trigonometry: '<S49>/Trigonometric Function1' incorporates:\n    //   Concatenate: '<S49>/Vector Concatenate'\n\n    simulation_B.VectorConcatenate[0] = rt_atan2d_snf(simulation_B.fcn1,\n      simulation_B.fcn2);\n\n    // Fcn: '<S46>/fcn3'\n    simulation_B.fcn3 = (simulation_B.Product1_c * simulation_B.Product3_l +\n                         simulation_B.Product_d * simulation_B.Product2_l) * 2.0;\n\n    // If: '<S51>/If'\n    if (rtsiIsModeUpdateTimeStep(&simulation_M->solverInfo)) {\n      if (simulation_B.fcn3 > 1.0) {\n        rtAction = 0;\n      } else if (simulation_B.fcn3 < -1.0) {\n        rtAction = 1;\n      } else {\n        rtAction = 2;\n      }\n\n      simulation_DW.If_ActiveSubsystem = rtAction;\n    } else {\n      rtAction = simulation_DW.If_ActiveSubsystem;\n    }\n\n    switch (rtAction) {\n     case 0:\n      // Outputs for IfAction SubSystem: '<S51>/If Action Subsystem' incorporates:\n      //   ActionPort: '<S52>/Action Port'\n\n      if (rtmIsMajorTimeStep(simulation_M) &&\n          simulation_M->Timing.TaskCounters.TID[1] == 0) {\n        // Merge: '<S51>/Merge' incorporates:\n        //   Constant: '<S52>/Constant'\n\n        simulation_B.Merge = 1.0;\n      }\n\n      // End of Outputs for SubSystem: '<S51>/If Action Subsystem'\n      break;\n\n     case 1:\n      // Outputs for IfAction SubSystem: '<S51>/If Action Subsystem1' incorporates:\n      //   ActionPort: '<S53>/Action Port'\n\n      if (rtmIsMajorTimeStep(simulation_M) &&\n          simulation_M->Timing.TaskCounters.TID[1] == 0) {\n        // Merge: '<S51>/Merge' incorporates:\n        //   Constant: '<S53>/Constant'\n\n        simulation_B.Merge = 1.0;\n      }\n\n      // End of Outputs for SubSystem: '<S51>/If Action Subsystem1'\n      break;\n\n     default:\n      // Outputs for IfAction SubSystem: '<S51>/If Action Subsystem2' incorporates:\n      //   ActionPort: '<S54>/Action Port'\n\n      // Merge: '<S51>/Merge' incorporates:\n      //   SignalConversion generated from: '<S54>/In'\n\n      simulation_B.Merge = simulation_B.fcn3;\n\n      // End of Outputs for SubSystem: '<S51>/If Action Subsystem2'\n      break;\n    }\n\n    // End of If: '<S51>/If'\n\n    // Trigonometry: '<S49>/trigFcn' incorporates:\n    //   Concatenate: '<S49>/Vector Concatenate'\n\n    xtmp = simulation_B.Merge;\n    if (xtmp > 1.0) {\n      xtmp = 1.0;\n    } else if (xtmp < -1.0) {\n      xtmp = -1.0;\n    }\n\n    simulation_B.VectorConcatenate[1] = std::asin(xtmp);\n\n    // End of Trigonometry: '<S49>/trigFcn'\n\n    // Fcn: '<S46>/fcn4'\n    simulation_B.fcn4 = (simulation_B.Product1_c * simulation_B.Product2_l -\n                         simulation_B.Product_d * simulation_B.Product3_l) *\n      -2.0;\n\n    // Fcn: '<S46>/fcn5'\n    simulation_B.fcn5 = ((simulation_B.Product_d * simulation_B.Product_d +\n                          simulation_B.Product1_c * simulation_B.Product1_c) -\n                         simulation_B.Product2_l * simulation_B.Product2_l) -\n      simulation_B.Product3_l * simulation_B.Product3_l;\n\n    // Trigonometry: '<S49>/Trigonometric Function3' incorporates:\n    //   Concatenate: '<S49>/Vector Concatenate'\n\n    simulation_B.VectorConcatenate[2] = rt_atan2d_snf(simulation_B.fcn4,\n      simulation_B.fcn5);\n\n    // Abs: '<S36>/Abs'\n    simulation_B.Abs_m = std::abs(simulation_B.VectorConcatenate[0]);\n\n    // Trigonometry: '<S36>/Cos'\n    simulation_B.Cos = std::cos(simulation_B.Abs_m);\n\n    // Abs: '<S36>/Abs1'\n    simulation_B.Abs1_h = std::abs(simulation_B.VectorConcatenate[1]);\n\n    // Trigonometry: '<S36>/Cos1'\n    simulation_B.Cos1 = std::cos(simulation_B.Abs1_h);\n\n    // Product: '<S36>/multiply'\n    simulation_B.multiply = simulation_B.Cos * simulation_B.Cos1;\n\n    // Product: '<S36>/Divide'\n    simulation_B.Divide = simulation_B.OUTPUT_1_0[4] / simulation_B.multiply;\n\n    // Sum: '<S36>/Plus'\n    simulation_B.Plus = simulation_B.RandomNumber + simulation_B.Divide;\n\n    // Outport: '<Root>/lidar'\n    simulation_Y.lidar = simulation_B.Plus;\n    if (rtmIsMajorTimeStep(simulation_M) &&\n        simulation_M->Timing.TaskCounters.TID[1] == 0) {\n      // MATLAB Function: '<S5>/stage1_thrust_calculate' incorporates:\n      //   Constant: '<S5>/series'\n\n      for (high_i = 0; high_i < 6; high_i++) {\n        low_i = high_i << 1;\n        x[high_i] = simulation_ConstP.pooled7[low_i];\n        y[high_i] = simulation_ConstP.pooled7[low_i + 1];\n      }\n\n      simulation_B.thrust_j = (rtNaN);\n      high_i = 0;\n      do {\n        exitg1 = 0;\n        if (high_i < 6) {\n          if (std::isnan(simulation_ConstP.pooled7[high_i << 1])) {\n            exitg1 = 1;\n          } else {\n            high_i++;\n          }\n        } else {\n          simulation_B.thrust_j = (rtNaN);\n          if (std::isnan(simulation_B.s1_et)) {\n            simulation_B.thrust_j = (rtNaN);\n          } else if ((!(simulation_B.s1_et > x[5])) && (!(simulation_B.s1_et <\n                       x[0]))) {\n            low_i = 1;\n            low_ip1 = 2;\n            while (high_i > low_ip1) {\n              mid_i = (low_i + high_i) >> 1;\n              if (simulation_B.s1_et >= x[mid_i - 1]) {\n                low_i = mid_i;\n                low_ip1 = mid_i + 1;\n              } else {\n                high_i = mid_i;\n              }\n            }\n\n            xtmp = x[low_i - 1];\n            xtmp = (simulation_B.s1_et - xtmp) / (x[low_i] - xtmp);\n            if (xtmp == 0.0) {\n              simulation_B.thrust_j = y[low_i - 1];\n            } else if (xtmp == 1.0) {\n              simulation_B.thrust_j = y[low_i];\n            } else {\n              tmp_8 = y[low_i - 1];\n              if (tmp_8 == y[low_i]) {\n                simulation_B.thrust_j = tmp_8;\n              } else {\n                simulation_B.thrust_j = (1.0 - xtmp) * tmp_8 + xtmp * y[low_i];\n              }\n            }\n          }\n\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n\n      // End of MATLAB Function: '<S5>/stage1_thrust_calculate'\n    }\n\n    // SimscapeInputBlock: '<S69>/INPUT_2_1_1'\n    simulation_B.INPUT_2_1_1[0] = simulation_B.thrust_j;\n    simulation_B.INPUT_2_1_1[1] = 0.0;\n    simulation_B.INPUT_2_1_1[2] = 0.0;\n    if (rtmIsMajorTimeStep(simulation_M)) {\n      simulation_DW.INPUT_2_1_1_Discrete[0] = !(simulation_B.INPUT_2_1_1[0] ==\n        simulation_DW.INPUT_2_1_1_Discrete[1]);\n      simulation_DW.INPUT_2_1_1_Discrete[1] = simulation_B.INPUT_2_1_1[0];\n    }\n\n    simulation_B.INPUT_2_1_1[0] = simulation_DW.INPUT_2_1_1_Discrete[1];\n    simulation_B.INPUT_2_1_1[3] = simulation_DW.INPUT_2_1_1_Discrete[0];\n\n    // End of SimscapeInputBlock: '<S69>/INPUT_2_1_1'\n    if (rtmIsMajorTimeStep(simulation_M) &&\n        simulation_M->Timing.TaskCounters.TID[1] == 0) {\n      // MATLAB Function: '<S5>/stage2_thrust_calculate' incorporates:\n      //   Constant: '<S5>/series1'\n\n      for (high_i = 0; high_i < 6; high_i++) {\n        low_i = high_i << 1;\n        x[high_i] = simulation_ConstP.pooled7[low_i];\n        y[high_i] = simulation_ConstP.pooled7[low_i + 1];\n      }\n\n      simulation_B.thrust = (rtNaN);\n      high_i = 0;\n      do {\n        exitg1 = 0;\n        if (high_i < 6) {\n          if (std::isnan(simulation_ConstP.pooled7[high_i << 1])) {\n            exitg1 = 1;\n          } else {\n            high_i++;\n          }\n        } else {\n          simulation_B.thrust = (rtNaN);\n          if (std::isnan(simulation_B.s2_et)) {\n            simulation_B.thrust = (rtNaN);\n          } else if ((!(simulation_B.s2_et > x[5])) && (!(simulation_B.s2_et <\n                       x[0]))) {\n            low_i = 1;\n            low_ip1 = 2;\n            while (high_i > low_ip1) {\n              mid_i = (low_i + high_i) >> 1;\n              if (simulation_B.s2_et >= x[mid_i - 1]) {\n                low_i = mid_i;\n                low_ip1 = mid_i + 1;\n              } else {\n                high_i = mid_i;\n              }\n            }\n\n            xtmp = x[low_i - 1];\n            xtmp = (simulation_B.s2_et - xtmp) / (x[low_i] - xtmp);\n            if (xtmp == 0.0) {\n              simulation_B.thrust = y[low_i - 1];\n            } else if (xtmp == 1.0) {\n              simulation_B.thrust = y[low_i];\n            } else {\n              tmp_8 = y[low_i - 1];\n              if (tmp_8 == y[low_i]) {\n                simulation_B.thrust = tmp_8;\n              } else {\n                simulation_B.thrust = (1.0 - xtmp) * tmp_8 + xtmp * y[low_i];\n              }\n            }\n          }\n\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n\n      // End of MATLAB Function: '<S5>/stage2_thrust_calculate'\n    }\n\n    // SimscapeInputBlock: '<S69>/INPUT_3_1_1'\n    simulation_B.INPUT_3_1_1[0] = simulation_B.thrust;\n    simulation_B.INPUT_3_1_1[1] = 0.0;\n    simulation_B.INPUT_3_1_1[2] = 0.0;\n    if (rtmIsMajorTimeStep(simulation_M)) {\n      simulation_DW.INPUT_3_1_1_Discrete[0] = !(simulation_B.INPUT_3_1_1[0] ==\n        simulation_DW.INPUT_3_1_1_Discrete[1]);\n      simulation_DW.INPUT_3_1_1_Discrete[1] = simulation_B.INPUT_3_1_1[0];\n    }\n\n    simulation_B.INPUT_3_1_1[0] = simulation_DW.INPUT_3_1_1_Discrete[1];\n    simulation_B.INPUT_3_1_1[3] = simulation_DW.INPUT_3_1_1_Discrete[0];\n\n    // End of SimscapeInputBlock: '<S69>/INPUT_3_1_1'\n\n    // SimscapeExecutionBlock: '<S69>/OUTPUT_1_1'\n    simulationData = static_cast<NeslSimulationData *>\n      (simulation_DW.OUTPUT_1_1_SimData);\n    time_3 = simulation_M->Timing.t[0];\n    simulationData->mData->mTime.mN = 1;\n    simulationData->mData->mTime.mX = &time_3;\n    simulationData->mData->mContStates.mN = 0;\n    simulationData->mData->mContStates.mX = nullptr;\n    simulationData->mData->mDiscStates.mN = 0;\n    simulationData->mData->mDiscStates.mX = &simulation_DW.OUTPUT_1_1_Discrete;\n    simulationData->mData->mModeVector.mN = 0;\n    simulationData->mData->mModeVector.mX = &simulation_DW.OUTPUT_1_1_Modes;\n    first_output = false;\n    simulationData->mData->mFoundZcEvents = first_output;\n    simulationData->mData->mIsMajorTimeStep = rtmIsMajorTimeStep(simulation_M);\n    first_output = false;\n    simulationData->mData->mIsSolverAssertCheck = first_output;\n    simulationData->mData->mIsSolverCheckingCIC = false;\n    simulationData->mData->mIsComputingJacobian = false;\n    simulationData->mData->mIsEvaluatingF0 = false;\n    simulationData->mData->mIsSolverRequestingReset = false;\n    simulationData->mData->mIsModeUpdateTimeStep = rtsiIsModeUpdateTimeStep\n      (&simulation_M->solverInfo);\n    tmp_4[0] = 0;\n    tmp_3[0] = simulation_B.INPUT_4_1_1[0];\n    tmp_3[1] = simulation_B.INPUT_4_1_1[1];\n    tmp_3[2] = simulation_B.INPUT_4_1_1[2];\n    tmp_3[3] = simulation_B.INPUT_4_1_1[3];\n    tmp_4[1] = 4;\n    tmp_3[4] = simulation_B.INPUT_5_1_1[0];\n    tmp_3[5] = simulation_B.INPUT_5_1_1[1];\n    tmp_3[6] = simulation_B.INPUT_5_1_1[2];\n    tmp_3[7] = simulation_B.INPUT_5_1_1[3];\n    tmp_4[2] = 8;\n    tmp_3[8] = simulation_B.INPUT_1_1_1[0];\n    tmp_3[9] = simulation_B.INPUT_1_1_1[1];\n    tmp_3[10] = simulation_B.INPUT_1_1_1[2];\n    tmp_3[11] = simulation_B.INPUT_1_1_1[3];\n    tmp_4[3] = 12;\n    tmp_3[12] = simulation_B.INPUT_2_1_1[0];\n    tmp_3[13] = simulation_B.INPUT_2_1_1[1];\n    tmp_3[14] = simulation_B.INPUT_2_1_1[2];\n    tmp_3[15] = simulation_B.INPUT_2_1_1[3];\n    tmp_4[4] = 16;\n    tmp_3[16] = simulation_B.INPUT_3_1_1[0];\n    tmp_3[17] = simulation_B.INPUT_3_1_1[1];\n    tmp_3[18] = simulation_B.INPUT_3_1_1[2];\n    tmp_3[19] = simulation_B.INPUT_3_1_1[3];\n    tmp_4[5] = 20;\n    tmp_3[20] = simulation_B.STATE_1[0];\n    tmp_3[21] = simulation_B.STATE_1[1];\n    tmp_3[22] = simulation_B.STATE_1[2];\n    tmp_3[23] = simulation_B.STATE_1[3];\n    tmp_3[24] = simulation_B.STATE_1[4];\n    tmp_3[25] = simulation_B.STATE_1[5];\n    tmp_3[26] = simulation_B.STATE_1[6];\n    tmp_3[27] = simulation_B.STATE_1[7];\n    tmp_3[28] = simulation_B.STATE_1[8];\n    tmp_3[29] = simulation_B.STATE_1[9];\n    tmp_3[30] = simulation_B.STATE_1[10];\n    tmp_3[31] = simulation_B.STATE_1[11];\n    tmp_3[32] = simulation_B.STATE_1[12];\n    tmp_3[33] = simulation_B.STATE_1[13];\n    tmp_3[34] = simulation_B.STATE_1[14];\n    tmp_3[35] = simulation_B.STATE_1[15];\n    tmp_3[36] = simulation_B.STATE_1[16];\n    tmp_3[37] = simulation_B.STATE_1[17];\n    tmp_3[38] = simulation_B.STATE_1[18];\n    tmp_3[39] = simulation_B.STATE_1[19];\n    tmp_3[40] = simulation_B.STATE_1[20];\n    tmp_3[41] = simulation_B.STATE_1[21];\n    tmp_3[42] = simulation_B.STATE_1[22];\n    tmp_3[43] = simulation_B.STATE_1[23];\n    tmp_3[44] = simulation_B.STATE_1[24];\n    tmp_3[45] = simulation_B.STATE_1[25];\n    tmp_3[46] = simulation_B.STATE_1[26];\n    tmp_4[6] = 47;\n    simulationData->mData->mInputValues.mN = 47;\n    simulationData->mData->mInputValues.mX = &tmp_3[0];\n    simulationData->mData->mInputOffsets.mN = 7;\n    simulationData->mData->mInputOffsets.mX = &tmp_4[0];\n    simulationData->mData->mOutputs.mN = 6;\n    simulationData->mData->mOutputs.mX = &simulation_B.OUTPUT_1_1[0];\n    simulationData->mData->mTolerances.mN = 0;\n    simulationData->mData->mTolerances.mX = nullptr;\n    simulationData->mData->mCstateHasChanged = false;\n    time_4 = simulation_M->Timing.t[0];\n    simulationData->mData->mTime.mN = 1;\n    simulationData->mData->mTime.mX = &time_4;\n    simulationData->mData->mSampleHits.mN = 0;\n    simulationData->mData->mSampleHits.mX = nullptr;\n    simulationData->mData->mIsFundamentalSampleHit = false;\n    simulator = static_cast<NeslSimulator *>(simulation_DW.OUTPUT_1_1_Simulator);\n    diagnosticManager = static_cast<NeuDiagnosticManager *>\n      (simulation_DW.OUTPUT_1_1_DiagMgr);\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\n    high_i = ne_simulator_method(simulator, NESL_SIM_OUTPUTS, simulationData,\n      diagnosticManager);\n    if (high_i != 0) {\n      first_output = error_buffer_is_empty(rtmGetErrorStatus(simulation_M));\n      if (first_output) {\n        msg = rtw_diagnostics_msg(diagnosticTree);\n        rtmSetErrorStatus(simulation_M, msg);\n      }\n    }\n\n    // End of SimscapeExecutionBlock: '<S69>/OUTPUT_1_1'\n    if (rtmIsMajorTimeStep(simulation_M) &&\n        simulation_M->Timing.TaskCounters.TID[1] == 0) {\n      // ZeroOrderHold: '<S17>/Zero-Order Hold1'\n      simulation_B.ZeroOrderHold1[0] = simulation_B.OUTPUT_1_1[3];\n\n      // ZeroOrderHold: '<S17>/Zero-Order Hold2'\n      simulation_B.ZeroOrderHold2[0] = simulation_B.OUTPUT_1_0[15];\n\n      // ZeroOrderHold: '<S17>/Zero-Order Hold1'\n      simulation_B.ZeroOrderHold1[1] = simulation_B.OUTPUT_1_1[4];\n\n      // ZeroOrderHold: '<S17>/Zero-Order Hold2'\n      simulation_B.ZeroOrderHold2[1] = simulation_B.OUTPUT_1_0[16];\n\n      // ZeroOrderHold: '<S17>/Zero-Order Hold1'\n      simulation_B.ZeroOrderHold1[2] = simulation_B.OUTPUT_1_1[5];\n\n      // ZeroOrderHold: '<S17>/Zero-Order Hold2'\n      simulation_B.ZeroOrderHold2[2] = simulation_B.OUTPUT_1_0[17];\n\n      // ZeroOrderHold: '<S17>/Zero-Order Hold'\n      simulation_B.ZeroOrderHold[0] = simulation_B.OUTPUT_1_0[11];\n      simulation_B.ZeroOrderHold[1] = simulation_B.OUTPUT_1_0[12];\n      simulation_B.ZeroOrderHold[2] = simulation_B.OUTPUT_1_0[13];\n      simulation_B.ZeroOrderHold[3] = simulation_B.OUTPUT_1_0[14];\n\n      // MATLABSystem: '<S17>/IMU' incorporates:\n      //   ZeroOrderHold: '<S17>/Zero-Order Hold'\n      //   ZeroOrderHold: '<S17>/Zero-Order Hold1'\n      //   ZeroOrderHold: '<S17>/Zero-Order Hold2'\n\n      if (simulation_DW.obj.Temperature != 25.0) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[37] = true;\n        }\n\n        simulation_DW.obj.Temperature = 25.0;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.MagneticFieldNED,\n           simulation_ConstP.IMU_MagneticFieldNED)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[0] = true;\n        }\n\n        imuSensor_set_MagneticFieldNED(&simulation_DW.obj,\n          simulation_ConstP.IMU_MagneticFieldNED);\n      }\n\n      if (simulation_DW.obj.AccelParamsMeasurementRange != (rtInf)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[3] = true;\n        }\n\n        simulation_DW.obj.AccelParamsMeasurementRange = (rtInf);\n      }\n\n      if (simulation_DW.obj.AccelParamsResolution != 0.0) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[4] = true;\n        }\n\n        simulation_DW.obj.AccelParamsResolution = 0.0;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.AccelParamsConstantBias,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[5] = true;\n        }\n\n        simulation_DW.obj.AccelParamsConstantBias[0] = 0.0;\n        simulation_DW.obj.AccelParamsConstantBias[1] = 0.0;\n        simulation_DW.obj.AccelParamsConstantBias[2] = 0.0;\n      }\n\n      if (!simulation_isequal_oi(simulation_DW.obj.AccelParamsAxesMisalignment,\n           simulation_ConstP.pooled4)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[6] = true;\n        }\n\n        for (high_i = 0; high_i < 9; high_i++) {\n          simulation_DW.obj.AccelParamsAxesMisalignment[high_i] =\n            simulation_ConstP.pooled4[high_i];\n        }\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.AccelParamsNoiseDensity,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[7] = true;\n        }\n\n        simulation_DW.obj.AccelParamsNoiseDensity[0] = 0.0;\n        simulation_DW.obj.AccelParamsNoiseDensity[1] = 0.0;\n        simulation_DW.obj.AccelParamsNoiseDensity[2] = 0.0;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.AccelParamsBiasInstability,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[8] = true;\n        }\n\n        simulation_DW.obj.AccelParamsBiasInstability[0] = 0.0;\n        simulation_DW.obj.AccelParamsBiasInstability[1] = 0.0;\n        simulation_DW.obj.AccelParamsBiasInstability[2] = 0.0;\n      }\n\n      if (simulation_DW.obj.AccelParamsBiasInstabilityNumerator != 1.0) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[9] = true;\n        }\n\n        simulation_DW.obj.AccelParamsBiasInstabilityNumerator = 1.0;\n      }\n\n      if (!simulation_isequal\n          (simulation_DW.obj.AccelParamsBiasInstabilityDenominator,\n           simulation_ConstP.pooled6)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[10] = true;\n        }\n\n        simulation_DW.obj.AccelParamsBiasInstabilityDenominator[0] = 1.0;\n        simulation_DW.obj.AccelParamsBiasInstabilityDenominator[1] = -0.5;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.AccelParamsRandomWalk,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[11] = true;\n        }\n\n        simulation_DW.obj.AccelParamsRandomWalk[0] = 0.0;\n        simulation_DW.obj.AccelParamsRandomWalk[1] = 0.0;\n        simulation_DW.obj.AccelParamsRandomWalk[2] = 0.0;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.AccelParamsTemperatureBias,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[12] = true;\n        }\n\n        simulation_DW.obj.AccelParamsTemperatureBias[0] = 0.0;\n        simulation_DW.obj.AccelParamsTemperatureBias[1] = 0.0;\n        simulation_DW.obj.AccelParamsTemperatureBias[2] = 0.0;\n      }\n\n      if (!simulation_isequal_o\n          (simulation_DW.obj.AccelParamsTemperatureScaleFactor,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[13] = true;\n        }\n\n        simulation_DW.obj.AccelParamsTemperatureScaleFactor[0] = 0.0;\n        simulation_DW.obj.AccelParamsTemperatureScaleFactor[1] = 0.0;\n        simulation_DW.obj.AccelParamsTemperatureScaleFactor[2] = 0.0;\n      }\n\n      if (simulation_DW.obj.GyroParamsMeasurementRange != (rtInf)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[14] = true;\n        }\n\n        simulation_DW.obj.GyroParamsMeasurementRange = (rtInf);\n      }\n\n      if (simulation_DW.obj.GyroParamsResolution != 0.0) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[15] = true;\n        }\n\n        simulation_DW.obj.GyroParamsResolution = 0.0;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.GyroParamsConstantBias,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[16] = true;\n        }\n\n        simulation_DW.obj.GyroParamsConstantBias[0] = 0.0;\n        simulation_DW.obj.GyroParamsConstantBias[1] = 0.0;\n        simulation_DW.obj.GyroParamsConstantBias[2] = 0.0;\n      }\n\n      if (!simulation_isequal_oi(simulation_DW.obj.GyroParamsAxesMisalignment,\n           simulation_ConstP.pooled4)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[17] = true;\n        }\n\n        for (high_i = 0; high_i < 9; high_i++) {\n          simulation_DW.obj.GyroParamsAxesMisalignment[high_i] =\n            simulation_ConstP.pooled4[high_i];\n        }\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.GyroParamsAccelerationBias,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[25] = true;\n        }\n\n        simulation_DW.obj.GyroParamsAccelerationBias[0] = 0.0;\n        simulation_DW.obj.GyroParamsAccelerationBias[1] = 0.0;\n        simulation_DW.obj.GyroParamsAccelerationBias[2] = 0.0;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.GyroParamsNoiseDensity,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[18] = true;\n        }\n\n        simulation_DW.obj.GyroParamsNoiseDensity[0] = 0.0;\n        simulation_DW.obj.GyroParamsNoiseDensity[1] = 0.0;\n        simulation_DW.obj.GyroParamsNoiseDensity[2] = 0.0;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.GyroParamsBiasInstability,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[19] = true;\n        }\n\n        simulation_DW.obj.GyroParamsBiasInstability[0] = 0.0;\n        simulation_DW.obj.GyroParamsBiasInstability[1] = 0.0;\n        simulation_DW.obj.GyroParamsBiasInstability[2] = 0.0;\n      }\n\n      if (simulation_DW.obj.GyroParamsBiasInstabilityNumerator != 1.0) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[20] = true;\n        }\n\n        simulation_DW.obj.GyroParamsBiasInstabilityNumerator = 1.0;\n      }\n\n      if (!simulation_isequal\n          (simulation_DW.obj.GyroParamsBiasInstabilityDenominator,\n           simulation_ConstP.pooled6)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[21] = true;\n        }\n\n        simulation_DW.obj.GyroParamsBiasInstabilityDenominator[0] = 1.0;\n        simulation_DW.obj.GyroParamsBiasInstabilityDenominator[1] = -0.5;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.GyroParamsRandomWalk,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[22] = true;\n        }\n\n        simulation_DW.obj.GyroParamsRandomWalk[0] = 0.0;\n        simulation_DW.obj.GyroParamsRandomWalk[1] = 0.0;\n        simulation_DW.obj.GyroParamsRandomWalk[2] = 0.0;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.GyroParamsTemperatureBias,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[23] = true;\n        }\n\n        simulation_DW.obj.GyroParamsTemperatureBias[0] = 0.0;\n        simulation_DW.obj.GyroParamsTemperatureBias[1] = 0.0;\n        simulation_DW.obj.GyroParamsTemperatureBias[2] = 0.0;\n      }\n\n      if (!simulation_isequal_o\n          (simulation_DW.obj.GyroParamsTemperatureScaleFactor,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[24] = true;\n        }\n\n        simulation_DW.obj.GyroParamsTemperatureScaleFactor[0] = 0.0;\n        simulation_DW.obj.GyroParamsTemperatureScaleFactor[1] = 0.0;\n        simulation_DW.obj.GyroParamsTemperatureScaleFactor[2] = 0.0;\n      }\n\n      if (simulation_DW.obj.MagParamsMeasurementRange != (rtInf)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[26] = true;\n        }\n\n        simulation_DW.obj.MagParamsMeasurementRange = (rtInf);\n      }\n\n      if (simulation_DW.obj.MagParamsResolution != 0.0) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[27] = true;\n        }\n\n        simulation_DW.obj.MagParamsResolution = 0.0;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.MagParamsConstantBias,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[28] = true;\n        }\n\n        simulation_DW.obj.MagParamsConstantBias[0] = 0.0;\n        simulation_DW.obj.MagParamsConstantBias[1] = 0.0;\n        simulation_DW.obj.MagParamsConstantBias[2] = 0.0;\n      }\n\n      if (!simulation_isequal_oi(simulation_DW.obj.MagParamsAxesMisalignment,\n           simulation_ConstP.pooled4)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[29] = true;\n        }\n\n        for (high_i = 0; high_i < 9; high_i++) {\n          simulation_DW.obj.MagParamsAxesMisalignment[high_i] =\n            simulation_ConstP.pooled4[high_i];\n        }\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.MagParamsNoiseDensity,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[30] = true;\n        }\n\n        simulation_DW.obj.MagParamsNoiseDensity[0] = 0.0;\n        simulation_DW.obj.MagParamsNoiseDensity[1] = 0.0;\n        simulation_DW.obj.MagParamsNoiseDensity[2] = 0.0;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.MagParamsBiasInstability,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[31] = true;\n        }\n\n        simulation_DW.obj.MagParamsBiasInstability[0] = 0.0;\n        simulation_DW.obj.MagParamsBiasInstability[1] = 0.0;\n        simulation_DW.obj.MagParamsBiasInstability[2] = 0.0;\n      }\n\n      if (simulation_DW.obj.MagParamsBiasInstabilityNumerator != 1.0) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[32] = true;\n        }\n\n        simulation_DW.obj.MagParamsBiasInstabilityNumerator = 1.0;\n      }\n\n      if (!simulation_isequal\n          (simulation_DW.obj.MagParamsBiasInstabilityDenominator,\n           simulation_ConstP.pooled6)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[33] = true;\n        }\n\n        simulation_DW.obj.MagParamsBiasInstabilityDenominator[0] = 1.0;\n        simulation_DW.obj.MagParamsBiasInstabilityDenominator[1] = -0.5;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.MagParamsRandomWalk,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[34] = true;\n        }\n\n        simulation_DW.obj.MagParamsRandomWalk[0] = 0.0;\n        simulation_DW.obj.MagParamsRandomWalk[1] = 0.0;\n        simulation_DW.obj.MagParamsRandomWalk[2] = 0.0;\n      }\n\n      if (!simulation_isequal_o(simulation_DW.obj.MagParamsTemperatureBias,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[35] = true;\n        }\n\n        simulation_DW.obj.MagParamsTemperatureBias[0] = 0.0;\n        simulation_DW.obj.MagParamsTemperatureBias[1] = 0.0;\n        simulation_DW.obj.MagParamsTemperatureBias[2] = 0.0;\n      }\n\n      if (!simulation_isequal_o\n          (simulation_DW.obj.MagParamsTemperatureScaleFactor,\n           simulation_ConstP.pooled3)) {\n        first_output = (simulation_DW.obj.isInitialized == 1);\n        if (first_output) {\n          simulation_DW.obj.TunablePropsChanged = true;\n          simulation_DW.obj.tunablePropertyChanged[36] = true;\n        }\n\n        simulation_DW.obj.MagParamsTemperatureScaleFactor[0] = 0.0;\n        simulation_DW.obj.MagParamsTemperatureScaleFactor[1] = 0.0;\n        simulation_DW.obj.MagParamsTemperatureScaleFactor[2] = 0.0;\n      }\n\n      simulation_SystemCore_step(&simulation_DW.obj, simulation_B.ZeroOrderHold1,\n        simulation_B.ZeroOrderHold2, simulation_B.ZeroOrderHold, tmp_5, tmp_6,\n        tmp_7);\n\n      // Outport: '<Root>/acceleration' incorporates:\n      //   MATLABSystem: '<S17>/IMU'\n\n      simulation_Y.acceleration[0] = tmp_5[0];\n\n      // Outport: '<Root>/omega' incorporates:\n      //   MATLABSystem: '<S17>/IMU'\n\n      simulation_Y.omega[0] = tmp_6[0];\n\n      // Outport: '<Root>/mag' incorporates:\n      //   MATLABSystem: '<S17>/IMU'\n\n      simulation_Y.mag[0] = tmp_7[0];\n\n      // Outport: '<Root>/acceleration' incorporates:\n      //   MATLABSystem: '<S17>/IMU'\n\n      simulation_Y.acceleration[1] = tmp_5[1];\n\n      // Outport: '<Root>/omega' incorporates:\n      //   MATLABSystem: '<S17>/IMU'\n\n      simulation_Y.omega[1] = tmp_6[1];\n\n      // Outport: '<Root>/mag' incorporates:\n      //   MATLABSystem: '<S17>/IMU'\n\n      simulation_Y.mag[1] = tmp_7[1];\n\n      // Outport: '<Root>/acceleration' incorporates:\n      //   MATLABSystem: '<S17>/IMU'\n\n      simulation_Y.acceleration[2] = tmp_5[2];\n\n      // Outport: '<Root>/omega' incorporates:\n      //   MATLABSystem: '<S17>/IMU'\n\n      simulation_Y.omega[2] = tmp_6[2];\n\n      // Outport: '<Root>/mag' incorporates:\n      //   MATLABSystem: '<S17>/IMU'\n\n      simulation_Y.mag[2] = tmp_7[2];\n    }\n\n    // Outport: '<Root>/true state'\n    for (high_i = 0; high_i < 10; high_i++) {\n      simulation_Y.truestate[high_i] = simulation_B.OUTPUT_1_0[high_i];\n    }\n\n    simulation_Y.truestate[10] = simulation_B.OUTPUT_1_1[0];\n    simulation_Y.truestate[11] = simulation_B.OUTPUT_1_1[1];\n    simulation_Y.truestate[12] = simulation_B.OUTPUT_1_1[2];\n    simulation_Y.truestate[13] = simulation_B.OUTPUT_1_0[10];\n\n    // End of Outport: '<Root>/true state'\n  }\n\n  if (rtmIsMajorTimeStep(simulation_M)) {\n    NeslSimulationData *simulationData;\n    NeslSimulator *simulator;\n    NeuDiagnosticManager *diagnosticManager;\n    NeuDiagnosticTree *diagnosticTree;\n    char *msg;\n    real_T tmp_0[20];\n    real_T time;\n    int32_T tmp_2;\n    int_T tmp_1[6];\n    boolean_T tmp;\n    if (rtmIsMajorTimeStep(simulation_M) &&\n        simulation_M->Timing.TaskCounters.TID[2] == 0) {\n      // Update for RandomNumber: '<S36>/Random Number'\n      simulation_DW.NextOutput = rt_nrand_Upu32_Yd_f_pw_snf\n        (&simulation_DW.RandSeed) * 0.0;\n    }\n\n    if (rtmIsMajorTimeStep(simulation_M) &&\n        simulation_M->Timing.TaskCounters.TID[1] == 0) {\n      // Update for UnitDelay: '<S62>/Unit Delay'\n      simulation_DW.UnitDelay_DSTATE = simulation_B.Switch;\n\n      // Update for UnitDelay: '<S62>/Unit Delay1'\n      simulation_DW.UnitDelay1_DSTATE = simulation_B.Switch1;\n\n      // Update for UnitDelay: '<S5>/Unit Delay'\n      simulation_DW.UnitDelay_DSTATE_m = simulation_B.thrust_j;\n\n      // Update for UnitDelay: '<S5>/Unit Delay1'\n      simulation_DW.UnitDelay1_DSTATE_j = simulation_B.thrust;\n    }\n\n    // Update for SimscapeExecutionBlock: '<S69>/STATE_1'\n    simulationData = static_cast<NeslSimulationData *>\n      (simulation_DW.STATE_1_SimData);\n    time = simulation_M->Timing.t[0];\n    simulationData->mData->mTime.mN = 1;\n    simulationData->mData->mTime.mX = &time;\n    simulationData->mData->mContStates.mN = 26;\n    simulationData->mData->mContStates.mX =\n      &simulation_X.simulationPlantRocket_BodyFree_[0];\n    simulationData->mData->mDiscStates.mN = 0;\n    simulationData->mData->mDiscStates.mX = &simulation_DW.STATE_1_Discrete;\n    simulationData->mData->mModeVector.mN = 1;\n    simulationData->mData->mModeVector.mX = &simulation_DW.STATE_1_Modes;\n    tmp = false;\n    simulationData->mData->mFoundZcEvents = tmp;\n    simulationData->mData->mIsMajorTimeStep = rtmIsMajorTimeStep(simulation_M);\n    tmp = false;\n    simulationData->mData->mIsSolverAssertCheck = tmp;\n    simulationData->mData->mIsSolverCheckingCIC = false;\n    tmp = rtsiIsSolverComputingJacobian(&simulation_M->solverInfo);\n    simulationData->mData->mIsComputingJacobian = tmp;\n    simulationData->mData->mIsEvaluatingF0 = false;\n    simulationData->mData->mIsSolverRequestingReset = false;\n    simulationData->mData->mIsModeUpdateTimeStep = rtsiIsModeUpdateTimeStep\n      (&simulation_M->solverInfo);\n    tmp_1[0] = 0;\n    tmp_0[0] = simulation_B.INPUT_4_1_1[0];\n    tmp_0[1] = simulation_B.INPUT_4_1_1[1];\n    tmp_0[2] = simulation_B.INPUT_4_1_1[2];\n    tmp_0[3] = simulation_B.INPUT_4_1_1[3];\n    tmp_1[1] = 4;\n    tmp_0[4] = simulation_B.INPUT_5_1_1[0];\n    tmp_0[5] = simulation_B.INPUT_5_1_1[1];\n    tmp_0[6] = simulation_B.INPUT_5_1_1[2];\n    tmp_0[7] = simulation_B.INPUT_5_1_1[3];\n    tmp_1[2] = 8;\n    tmp_0[8] = simulation_B.INPUT_1_1_1[0];\n    tmp_0[9] = simulation_B.INPUT_1_1_1[1];\n    tmp_0[10] = simulation_B.INPUT_1_1_1[2];\n    tmp_0[11] = simulation_B.INPUT_1_1_1[3];\n    tmp_1[3] = 12;\n    tmp_0[12] = simulation_B.INPUT_2_1_1[0];\n    tmp_0[13] = simulation_B.INPUT_2_1_1[1];\n    tmp_0[14] = simulation_B.INPUT_2_1_1[2];\n    tmp_0[15] = simulation_B.INPUT_2_1_1[3];\n    tmp_1[4] = 16;\n    tmp_0[16] = simulation_B.INPUT_3_1_1[0];\n    tmp_0[17] = simulation_B.INPUT_3_1_1[1];\n    tmp_0[18] = simulation_B.INPUT_3_1_1[2];\n    tmp_0[19] = simulation_B.INPUT_3_1_1[3];\n    tmp_1[5] = 20;\n    simulationData->mData->mInputValues.mN = 20;\n    simulationData->mData->mInputValues.mX = &tmp_0[0];\n    simulationData->mData->mInputOffsets.mN = 6;\n    simulationData->mData->mInputOffsets.mX = &tmp_1[0];\n    simulator = static_cast<NeslSimulator *>(simulation_DW.STATE_1_Simulator);\n    diagnosticManager = static_cast<NeuDiagnosticManager *>\n      (simulation_DW.STATE_1_DiagMgr);\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\n    tmp_2 = ne_simulator_method(simulator, NESL_SIM_UPDATE, simulationData,\n      diagnosticManager);\n    if (tmp_2 != 0) {\n      tmp = error_buffer_is_empty(rtmGetErrorStatus(simulation_M));\n      if (tmp) {\n        msg = rtw_diagnostics_msg(diagnosticTree);\n        rtmSetErrorStatus(simulation_M, msg);\n      }\n    }\n\n    // End of Update for SimscapeExecutionBlock: '<S69>/STATE_1'\n  }                                    // end MajorTimeStep\n\n  if (rtmIsMajorTimeStep(simulation_M)) {\n    rt_ertODEUpdateContinuousStates(&simulation_M->solverInfo);\n\n    // Update absolute time for base rate\n    // The \"clockTick0\" counts the number of times the code of this task has\n    //  been executed. The absolute time is the multiplication of \"clockTick0\"\n    //  and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n    //  overflow during the application lifespan selected.\n\n    ++simulation_M->Timing.clockTick0;\n    simulation_M->Timing.t[0] = rtsiGetSolverStopTime(&simulation_M->solverInfo);\n\n    {\n      // Update absolute timer for sample time: [0.001s, 0.0s]\n      // The \"clockTick1\" counts the number of times the code of this task has\n      //  been executed. The resolution of this integer timer is 0.001, which is the step size\n      //  of the task. Size of \"clockTick1\" ensures timer will not overflow during the\n      //  application lifespan selected.\n\n      simulation_M->Timing.clockTick1++;\n    }\n\n    rate_scheduler();\n  }                                    // end MajorTimeStep\n}\n\n// Derivatives for root system: '<Root>'\nvoid simulation_derivatives(void)\n{\n  NeslSimulationData *simulationData;\n  NeslSimulator *simulator;\n  NeuDiagnosticManager *diagnosticManager;\n  NeuDiagnosticTree *diagnosticTree;\n  XDot_simulation_T *_rtXdot;\n  char *msg;\n  real_T tmp_0[20];\n  real_T time;\n  int32_T tmp_2;\n  int_T tmp_1[6];\n  boolean_T tmp;\n  _rtXdot = ((XDot_simulation_T *) simulation_M->derivs);\n\n  // Derivatives for SimscapeInputBlock: '<S69>/INPUT_4_1_1'\n  _rtXdot->simulationPlantTVC_PhysicsSimul[0] =\n    simulation_X.simulationPlantTVC_PhysicsSimul[1];\n  _rtXdot->simulationPlantTVC_PhysicsSimul[1] = ((simulation_B.Switch -\n    simulation_X.simulationPlantTVC_PhysicsSimul[0]) * 20.0 - 2.0 *\n    simulation_X.simulationPlantTVC_PhysicsSimul[1]) * 20.0;\n\n  // Derivatives for SimscapeInputBlock: '<S69>/INPUT_5_1_1'\n  _rtXdot->simulationPlantTVC_PhysicsSim_a[0] =\n    simulation_X.simulationPlantTVC_PhysicsSim_a[1];\n  _rtXdot->simulationPlantTVC_PhysicsSim_a[1] = ((simulation_B.Switch1 -\n    simulation_X.simulationPlantTVC_PhysicsSim_a[0]) * 20.0 - 2.0 *\n    simulation_X.simulationPlantTVC_PhysicsSim_a[1]) * 20.0;\n\n  // Derivatives for SimscapeExecutionBlock: '<S69>/STATE_1'\n  simulationData = static_cast<NeslSimulationData *>\n    (simulation_DW.STATE_1_SimData);\n  time = simulation_M->Timing.t[0];\n  simulationData->mData->mTime.mN = 1;\n  simulationData->mData->mTime.mX = &time;\n  simulationData->mData->mContStates.mN = 26;\n  simulationData->mData->mContStates.mX =\n    &simulation_X.simulationPlantRocket_BodyFree_[0];\n  simulationData->mData->mDiscStates.mN = 0;\n  simulationData->mData->mDiscStates.mX = &simulation_DW.STATE_1_Discrete;\n  simulationData->mData->mModeVector.mN = 1;\n  simulationData->mData->mModeVector.mX = &simulation_DW.STATE_1_Modes;\n  tmp = false;\n  simulationData->mData->mFoundZcEvents = tmp;\n  simulationData->mData->mIsMajorTimeStep = rtmIsMajorTimeStep(simulation_M);\n  tmp = false;\n  simulationData->mData->mIsSolverAssertCheck = tmp;\n  simulationData->mData->mIsSolverCheckingCIC = false;\n  tmp = rtsiIsSolverComputingJacobian(&simulation_M->solverInfo);\n  simulationData->mData->mIsComputingJacobian = tmp;\n  simulationData->mData->mIsEvaluatingF0 = false;\n  simulationData->mData->mIsSolverRequestingReset = false;\n  simulationData->mData->mIsModeUpdateTimeStep = rtsiIsModeUpdateTimeStep\n    (&simulation_M->solverInfo);\n  tmp_1[0] = 0;\n  tmp_0[0] = simulation_B.INPUT_4_1_1[0];\n  tmp_0[1] = simulation_B.INPUT_4_1_1[1];\n  tmp_0[2] = simulation_B.INPUT_4_1_1[2];\n  tmp_0[3] = simulation_B.INPUT_4_1_1[3];\n  tmp_1[1] = 4;\n  tmp_0[4] = simulation_B.INPUT_5_1_1[0];\n  tmp_0[5] = simulation_B.INPUT_5_1_1[1];\n  tmp_0[6] = simulation_B.INPUT_5_1_1[2];\n  tmp_0[7] = simulation_B.INPUT_5_1_1[3];\n  tmp_1[2] = 8;\n  tmp_0[8] = simulation_B.INPUT_1_1_1[0];\n  tmp_0[9] = simulation_B.INPUT_1_1_1[1];\n  tmp_0[10] = simulation_B.INPUT_1_1_1[2];\n  tmp_0[11] = simulation_B.INPUT_1_1_1[3];\n  tmp_1[3] = 12;\n  tmp_0[12] = simulation_B.INPUT_2_1_1[0];\n  tmp_0[13] = simulation_B.INPUT_2_1_1[1];\n  tmp_0[14] = simulation_B.INPUT_2_1_1[2];\n  tmp_0[15] = simulation_B.INPUT_2_1_1[3];\n  tmp_1[4] = 16;\n  tmp_0[16] = simulation_B.INPUT_3_1_1[0];\n  tmp_0[17] = simulation_B.INPUT_3_1_1[1];\n  tmp_0[18] = simulation_B.INPUT_3_1_1[2];\n  tmp_0[19] = simulation_B.INPUT_3_1_1[3];\n  tmp_1[5] = 20;\n  simulationData->mData->mInputValues.mN = 20;\n  simulationData->mData->mInputValues.mX = &tmp_0[0];\n  simulationData->mData->mInputOffsets.mN = 6;\n  simulationData->mData->mInputOffsets.mX = &tmp_1[0];\n  simulationData->mData->mDx.mN = 26;\n  simulationData->mData->mDx.mX = &_rtXdot->simulationPlantRocket_BodyFree_[0];\n  simulator = static_cast<NeslSimulator *>(simulation_DW.STATE_1_Simulator);\n  diagnosticManager = static_cast<NeuDiagnosticManager *>\n    (simulation_DW.STATE_1_DiagMgr);\n  diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\n  tmp_2 = ne_simulator_method(simulator, NESL_SIM_DERIVATIVES, simulationData,\n    diagnosticManager);\n  if (tmp_2 != 0) {\n    tmp = error_buffer_is_empty(rtmGetErrorStatus(simulation_M));\n    if (tmp) {\n      msg = rtw_diagnostics_msg(diagnosticTree);\n      rtmSetErrorStatus(simulation_M, msg);\n    }\n  }\n\n  // End of Derivatives for SimscapeExecutionBlock: '<S69>/STATE_1'\n}\n\n// Model initialize function\nvoid simulation_initialize(void)\n{\n  // Registration code\n\n  // initialize non-finites\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  {\n    // Setup solver object\n    rtsiSetSimTimeStepPtr(&simulation_M->solverInfo,\n                          &simulation_M->Timing.simTimeStep);\n    rtsiSetTPtr(&simulation_M->solverInfo, &rtmGetTPtr(simulation_M));\n    rtsiSetStepSizePtr(&simulation_M->solverInfo,\n                       &simulation_M->Timing.stepSize0);\n    rtsiSetdXPtr(&simulation_M->solverInfo, &simulation_M->derivs);\n    rtsiSetContStatesPtr(&simulation_M->solverInfo, (real_T **)\n                         &simulation_M->contStates);\n    rtsiSetNumContStatesPtr(&simulation_M->solverInfo,\n      &simulation_M->Sizes.numContStates);\n    rtsiSetNumPeriodicContStatesPtr(&simulation_M->solverInfo,\n      &simulation_M->Sizes.numPeriodicContStates);\n    rtsiSetPeriodicContStateIndicesPtr(&simulation_M->solverInfo,\n      &simulation_M->periodicContStateIndices);\n    rtsiSetPeriodicContStateRangesPtr(&simulation_M->solverInfo,\n      &simulation_M->periodicContStateRanges);\n    rtsiSetContStateDisabledPtr(&simulation_M->solverInfo, (boolean_T**)\n      &simulation_M->contStateDisabled);\n    rtsiSetErrorStatusPtr(&simulation_M->solverInfo, (&rtmGetErrorStatus\n      (simulation_M)));\n    rtsiSetRTModelPtr(&simulation_M->solverInfo, simulation_M);\n  }\n\n  rtsiSetSimTimeStep(&simulation_M->solverInfo, MAJOR_TIME_STEP);\n  simulation_M->intgData.y = simulation_M->odeY;\n  simulation_M->intgData.f[0] = simulation_M->odeF[0];\n  simulation_M->intgData.f[1] = simulation_M->odeF[1];\n  simulation_M->intgData.f[2] = simulation_M->odeF[2];\n  simulation_M->contStates = ((X_simulation_T *) &simulation_X);\n  simulation_M->contStateDisabled = ((XDis_simulation_T *) &simulation_XDis);\n  simulation_M->Timing.tStart = (0.0);\n  rtsiSetSolverData(&simulation_M->solverInfo, static_cast<void *>\n                    (&simulation_M->intgData));\n  rtsiSetIsMinorTimeStepWithModeChange(&simulation_M->solverInfo, false);\n  rtsiSetSolverName(&simulation_M->solverInfo,\"ode3\");\n  rtmSetTPtr(simulation_M, &simulation_M->Timing.tArray[0]);\n  simulation_M->Timing.stepSize0 = 0.001;\n\n  {\n    NeModelParameters modelParameters;\n    NeModelParameters modelParameters_0;\n    NeModelParameters modelParameters_1;\n    NeslSimulationData *tmp;\n    NeslSimulator *simulator;\n    NeuDiagnosticManager *diagnosticManager;\n    NeuDiagnosticTree *diagnosticTree;\n    char *msg;\n    real_T tmp_0;\n    int32_T i;\n    boolean_T zcDisabled;\n\n    // Start for SimscapeExecutionBlock: '<S69>/STATE_1'\n    simulator = nesl_lease_simulator(\n      \"simulation/Plant/ World Setup/Solver Configuration_1\", 0, 0);\n    simulation_DW.STATE_1_Simulator = (void *)simulator;\n    zcDisabled = pointer_is_null(simulation_DW.STATE_1_Simulator);\n    if (zcDisabled) {\n      simulation_b048d748_1_gateway();\n      simulator = nesl_lease_simulator(\n        \"simulation/Plant/ World Setup/Solver Configuration_1\", 0, 0);\n      simulation_DW.STATE_1_Simulator = (void *)simulator;\n    }\n\n    tmp = nesl_create_simulation_data();\n    simulation_DW.STATE_1_SimData = (void *)tmp;\n    diagnosticManager = rtw_create_diagnostics();\n    simulation_DW.STATE_1_DiagMgr = (void *)diagnosticManager;\n    modelParameters.mSolverType = NE_SOLVER_TYPE_DAE;\n    modelParameters.mSolverAbsTol = 0.001;\n    modelParameters.mSolverRelTol = 0.001;\n    modelParameters.mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_NO;\n    modelParameters.mStartTime = 0.0;\n    modelParameters.mLoadInitialState = false;\n    modelParameters.mUseSimState = false;\n    modelParameters.mLinTrimCompile = false;\n    modelParameters.mLoggingMode = SSC_LOGGING_OFF;\n    modelParameters.mRTWModifiedTimeStamp = 6.21213981E+8;\n    modelParameters.mUseModelRefSolver = false;\n    modelParameters.mTargetFPGAHIL = false;\n    tmp_0 = 0.001;\n    modelParameters.mSolverTolerance = tmp_0;\n    tmp_0 = 0.001;\n    modelParameters.mFixedStepSize = tmp_0;\n    zcDisabled = false;\n    modelParameters.mVariableStepSolver = zcDisabled;\n    zcDisabled = false;\n    modelParameters.mIsUsingODEN = zcDisabled;\n    modelParameters.mZcDisabled = true;\n    simulator = static_cast<NeslSimulator *>(simulation_DW.STATE_1_Simulator);\n    diagnosticManager = static_cast<NeuDiagnosticManager *>\n      (simulation_DW.STATE_1_DiagMgr);\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\n    i = nesl_initialize_simulator(simulator, &modelParameters, diagnosticManager);\n    if (i != 0) {\n      zcDisabled = error_buffer_is_empty(rtmGetErrorStatus(simulation_M));\n      if (zcDisabled) {\n        msg = rtw_diagnostics_msg(diagnosticTree);\n        rtmSetErrorStatus(simulation_M, msg);\n      }\n    }\n\n    // End of Start for SimscapeExecutionBlock: '<S69>/STATE_1'\n\n    // Start for SimscapeExecutionBlock: '<S69>/OUTPUT_1_0'\n    simulator = nesl_lease_simulator(\n      \"simulation/Plant/ World Setup/Solver Configuration_1\", 1, 0);\n    simulation_DW.OUTPUT_1_0_Simulator = (void *)simulator;\n    zcDisabled = pointer_is_null(simulation_DW.OUTPUT_1_0_Simulator);\n    if (zcDisabled) {\n      simulation_b048d748_1_gateway();\n      simulator = nesl_lease_simulator(\n        \"simulation/Plant/ World Setup/Solver Configuration_1\", 1, 0);\n      simulation_DW.OUTPUT_1_0_Simulator = (void *)simulator;\n    }\n\n    tmp = nesl_create_simulation_data();\n    simulation_DW.OUTPUT_1_0_SimData = (void *)tmp;\n    diagnosticManager = rtw_create_diagnostics();\n    simulation_DW.OUTPUT_1_0_DiagMgr = (void *)diagnosticManager;\n    modelParameters_0.mSolverType = NE_SOLVER_TYPE_DAE;\n    modelParameters_0.mSolverAbsTol = 0.001;\n    modelParameters_0.mSolverRelTol = 0.001;\n    modelParameters_0.mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_NO;\n    modelParameters_0.mStartTime = 0.0;\n    modelParameters_0.mLoadInitialState = false;\n    modelParameters_0.mUseSimState = false;\n    modelParameters_0.mLinTrimCompile = false;\n    modelParameters_0.mLoggingMode = SSC_LOGGING_OFF;\n    modelParameters_0.mRTWModifiedTimeStamp = 6.21213981E+8;\n    modelParameters_0.mUseModelRefSolver = false;\n    modelParameters_0.mTargetFPGAHIL = false;\n    tmp_0 = 0.001;\n    modelParameters_0.mSolverTolerance = tmp_0;\n    tmp_0 = 0.001;\n    modelParameters_0.mFixedStepSize = tmp_0;\n    zcDisabled = false;\n    modelParameters_0.mVariableStepSolver = zcDisabled;\n    zcDisabled = false;\n    modelParameters_0.mIsUsingODEN = zcDisabled;\n    modelParameters_0.mZcDisabled = true;\n    simulator = static_cast<NeslSimulator *>(simulation_DW.OUTPUT_1_0_Simulator);\n    diagnosticManager = static_cast<NeuDiagnosticManager *>\n      (simulation_DW.OUTPUT_1_0_DiagMgr);\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\n    i = nesl_initialize_simulator(simulator, &modelParameters_0,\n      diagnosticManager);\n    if (i != 0) {\n      zcDisabled = error_buffer_is_empty(rtmGetErrorStatus(simulation_M));\n      if (zcDisabled) {\n        msg = rtw_diagnostics_msg(diagnosticTree);\n        rtmSetErrorStatus(simulation_M, msg);\n      }\n    }\n\n    // End of Start for SimscapeExecutionBlock: '<S69>/OUTPUT_1_0'\n\n    // Start for If: '<S51>/If'\n    simulation_DW.If_ActiveSubsystem = -1;\n\n    // Start for SimscapeExecutionBlock: '<S69>/OUTPUT_1_1'\n    simulator = nesl_lease_simulator(\n      \"simulation/Plant/ World Setup/Solver Configuration_1\", 1, 1);\n    simulation_DW.OUTPUT_1_1_Simulator = (void *)simulator;\n    zcDisabled = pointer_is_null(simulation_DW.OUTPUT_1_1_Simulator);\n    if (zcDisabled) {\n      simulation_b048d748_1_gateway();\n      simulator = nesl_lease_simulator(\n        \"simulation/Plant/ World Setup/Solver Configuration_1\", 1, 1);\n      simulation_DW.OUTPUT_1_1_Simulator = (void *)simulator;\n    }\n\n    tmp = nesl_create_simulation_data();\n    simulation_DW.OUTPUT_1_1_SimData = (void *)tmp;\n    diagnosticManager = rtw_create_diagnostics();\n    simulation_DW.OUTPUT_1_1_DiagMgr = (void *)diagnosticManager;\n    modelParameters_1.mSolverType = NE_SOLVER_TYPE_DAE;\n    modelParameters_1.mSolverAbsTol = 0.001;\n    modelParameters_1.mSolverRelTol = 0.001;\n    modelParameters_1.mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_NO;\n    modelParameters_1.mStartTime = 0.0;\n    modelParameters_1.mLoadInitialState = false;\n    modelParameters_1.mUseSimState = false;\n    modelParameters_1.mLinTrimCompile = false;\n    modelParameters_1.mLoggingMode = SSC_LOGGING_OFF;\n    modelParameters_1.mRTWModifiedTimeStamp = 6.21213981E+8;\n    modelParameters_1.mUseModelRefSolver = false;\n    modelParameters_1.mTargetFPGAHIL = false;\n    tmp_0 = 0.001;\n    modelParameters_1.mSolverTolerance = tmp_0;\n    tmp_0 = 0.001;\n    modelParameters_1.mFixedStepSize = tmp_0;\n    zcDisabled = false;\n    modelParameters_1.mVariableStepSolver = zcDisabled;\n    zcDisabled = false;\n    modelParameters_1.mIsUsingODEN = zcDisabled;\n    modelParameters_1.mZcDisabled = true;\n    simulator = static_cast<NeslSimulator *>(simulation_DW.OUTPUT_1_1_Simulator);\n    diagnosticManager = static_cast<NeuDiagnosticManager *>\n      (simulation_DW.OUTPUT_1_1_DiagMgr);\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\n    i = nesl_initialize_simulator(simulator, &modelParameters_1,\n      diagnosticManager);\n    if (i != 0) {\n      zcDisabled = error_buffer_is_empty(rtmGetErrorStatus(simulation_M));\n      if (zcDisabled) {\n        msg = rtw_diagnostics_msg(diagnosticTree);\n        rtmSetErrorStatus(simulation_M, msg);\n      }\n    }\n\n    // End of Start for SimscapeExecutionBlock: '<S69>/OUTPUT_1_1'\n\n    // InitializeConditions for RandomNumber: '<S36>/Random Number'\n    simulation_DW.RandSeed = 597884928U;\n    simulation_DW.NextOutput = rt_nrand_Upu32_Yd_f_pw_snf\n      (&simulation_DW.RandSeed) * 0.0;\n\n    // Start for MATLABSystem: '<S17>/IMU'\n    simulation_DW.obj.MagneticFieldNED[0] = 27.555;\n    simulation_DW.obj.MagneticFieldNED[1] = -2.4169;\n    simulation_DW.obj.MagneticFieldNED[2] = -16.0849;\n    simulation_DW.obj.isInitialized = 0;\n    for (i = 0; i < 38; i++) {\n      simulation_DW.obj.tunablePropertyChanged[i] = false;\n    }\n\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[2] = true;\n    }\n\n    simulation_DW.objisempty = true;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[37] = true;\n    }\n\n    simulation_DW.obj.Temperature = 25.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[0] = true;\n    }\n\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[2] = true;\n    }\n\n    simulation_DW.obj.MagneticField[0] = 27.555;\n    simulation_DW.obj.MagneticField[1] = -2.4169;\n    simulation_DW.obj.MagneticField[2] = -16.0849;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[3] = true;\n    }\n\n    simulation_DW.obj.AccelParamsMeasurementRange = (rtInf);\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[4] = true;\n    }\n\n    simulation_DW.obj.AccelParamsResolution = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[5] = true;\n    }\n\n    simulation_DW.obj.AccelParamsConstantBias[0] = 0.0;\n    simulation_DW.obj.AccelParamsConstantBias[1] = 0.0;\n    simulation_DW.obj.AccelParamsConstantBias[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[6] = true;\n    }\n\n    for (i = 0; i < 9; i++) {\n      simulation_DW.obj.AccelParamsAxesMisalignment[i] =\n        simulation_ConstP.pooled4[i];\n    }\n\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[7] = true;\n    }\n\n    simulation_DW.obj.AccelParamsNoiseDensity[0] = 0.0;\n    simulation_DW.obj.AccelParamsNoiseDensity[1] = 0.0;\n    simulation_DW.obj.AccelParamsNoiseDensity[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[8] = true;\n    }\n\n    simulation_DW.obj.AccelParamsBiasInstability[0] = 0.0;\n    simulation_DW.obj.AccelParamsBiasInstability[1] = 0.0;\n    simulation_DW.obj.AccelParamsBiasInstability[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[9] = true;\n    }\n\n    simulation_DW.obj.AccelParamsBiasInstabilityNumerator = 1.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[10] = true;\n    }\n\n    simulation_DW.obj.AccelParamsBiasInstabilityDenominator[0] = 1.0;\n    simulation_DW.obj.AccelParamsBiasInstabilityDenominator[1] = -0.5;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[11] = true;\n    }\n\n    simulation_DW.obj.AccelParamsRandomWalk[0] = 0.0;\n    simulation_DW.obj.AccelParamsRandomWalk[1] = 0.0;\n    simulation_DW.obj.AccelParamsRandomWalk[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[12] = true;\n    }\n\n    simulation_DW.obj.AccelParamsTemperatureBias[0] = 0.0;\n    simulation_DW.obj.AccelParamsTemperatureBias[1] = 0.0;\n    simulation_DW.obj.AccelParamsTemperatureBias[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[13] = true;\n    }\n\n    simulation_DW.obj.AccelParamsTemperatureScaleFactor[0] = 0.0;\n    simulation_DW.obj.AccelParamsTemperatureScaleFactor[1] = 0.0;\n    simulation_DW.obj.AccelParamsTemperatureScaleFactor[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[14] = true;\n    }\n\n    simulation_DW.obj.GyroParamsMeasurementRange = (rtInf);\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[15] = true;\n    }\n\n    simulation_DW.obj.GyroParamsResolution = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[16] = true;\n    }\n\n    simulation_DW.obj.GyroParamsConstantBias[0] = 0.0;\n    simulation_DW.obj.GyroParamsConstantBias[1] = 0.0;\n    simulation_DW.obj.GyroParamsConstantBias[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[17] = true;\n    }\n\n    for (i = 0; i < 9; i++) {\n      simulation_DW.obj.GyroParamsAxesMisalignment[i] =\n        simulation_ConstP.pooled4[i];\n    }\n\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[25] = true;\n    }\n\n    simulation_DW.obj.GyroParamsAccelerationBias[0] = 0.0;\n    simulation_DW.obj.GyroParamsAccelerationBias[1] = 0.0;\n    simulation_DW.obj.GyroParamsAccelerationBias[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[18] = true;\n    }\n\n    simulation_DW.obj.GyroParamsNoiseDensity[0] = 0.0;\n    simulation_DW.obj.GyroParamsNoiseDensity[1] = 0.0;\n    simulation_DW.obj.GyroParamsNoiseDensity[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[19] = true;\n    }\n\n    simulation_DW.obj.GyroParamsBiasInstability[0] = 0.0;\n    simulation_DW.obj.GyroParamsBiasInstability[1] = 0.0;\n    simulation_DW.obj.GyroParamsBiasInstability[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[20] = true;\n    }\n\n    simulation_DW.obj.GyroParamsBiasInstabilityNumerator = 1.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[21] = true;\n    }\n\n    simulation_DW.obj.GyroParamsBiasInstabilityDenominator[0] = 1.0;\n    simulation_DW.obj.GyroParamsBiasInstabilityDenominator[1] = -0.5;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[22] = true;\n    }\n\n    simulation_DW.obj.GyroParamsRandomWalk[0] = 0.0;\n    simulation_DW.obj.GyroParamsRandomWalk[1] = 0.0;\n    simulation_DW.obj.GyroParamsRandomWalk[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[23] = true;\n    }\n\n    simulation_DW.obj.GyroParamsTemperatureBias[0] = 0.0;\n    simulation_DW.obj.GyroParamsTemperatureBias[1] = 0.0;\n    simulation_DW.obj.GyroParamsTemperatureBias[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[24] = true;\n    }\n\n    simulation_DW.obj.GyroParamsTemperatureScaleFactor[0] = 0.0;\n    simulation_DW.obj.GyroParamsTemperatureScaleFactor[1] = 0.0;\n    simulation_DW.obj.GyroParamsTemperatureScaleFactor[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[26] = true;\n    }\n\n    simulation_DW.obj.MagParamsMeasurementRange = (rtInf);\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[27] = true;\n    }\n\n    simulation_DW.obj.MagParamsResolution = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[28] = true;\n    }\n\n    simulation_DW.obj.MagParamsConstantBias[0] = 0.0;\n    simulation_DW.obj.MagParamsConstantBias[1] = 0.0;\n    simulation_DW.obj.MagParamsConstantBias[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[29] = true;\n    }\n\n    for (i = 0; i < 9; i++) {\n      simulation_DW.obj.MagParamsAxesMisalignment[i] =\n        simulation_ConstP.pooled4[i];\n    }\n\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[30] = true;\n    }\n\n    simulation_DW.obj.MagParamsNoiseDensity[0] = 0.0;\n    simulation_DW.obj.MagParamsNoiseDensity[1] = 0.0;\n    simulation_DW.obj.MagParamsNoiseDensity[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[31] = true;\n    }\n\n    simulation_DW.obj.MagParamsBiasInstability[0] = 0.0;\n    simulation_DW.obj.MagParamsBiasInstability[1] = 0.0;\n    simulation_DW.obj.MagParamsBiasInstability[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[32] = true;\n    }\n\n    simulation_DW.obj.MagParamsBiasInstabilityNumerator = 1.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[33] = true;\n    }\n\n    simulation_DW.obj.MagParamsBiasInstabilityDenominator[0] = 1.0;\n    simulation_DW.obj.MagParamsBiasInstabilityDenominator[1] = -0.5;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[34] = true;\n    }\n\n    simulation_DW.obj.MagParamsRandomWalk[0] = 0.0;\n    simulation_DW.obj.MagParamsRandomWalk[1] = 0.0;\n    simulation_DW.obj.MagParamsRandomWalk[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[35] = true;\n    }\n\n    simulation_DW.obj.MagParamsTemperatureBias[0] = 0.0;\n    simulation_DW.obj.MagParamsTemperatureBias[1] = 0.0;\n    simulation_DW.obj.MagParamsTemperatureBias[2] = 0.0;\n    zcDisabled = (simulation_DW.obj.isInitialized == 1);\n    if (zcDisabled) {\n      simulation_DW.obj.TunablePropsChanged = true;\n      simulation_DW.obj.tunablePropertyChanged[36] = true;\n    }\n\n    simulation_DW.obj.MagParamsTemperatureScaleFactor[0] = 0.0;\n    simulation_DW.obj.MagParamsTemperatureScaleFactor[1] = 0.0;\n    simulation_DW.obj.MagParamsTemperatureScaleFactor[2] = 0.0;\n    simulation_SystemCore_setup(&simulation_DW.obj);\n\n    // InitializeConditions for MATLABSystem: '<S17>/IMU'\n    simulat_IMUSensorBase_resetImpl(&simulation_DW.obj);\n  }\n}\n\n// Model terminate function\nvoid simulation_terminate(void)\n{\n  NeslSimulationData *simulationData;\n  NeuDiagnosticManager *diagnosticManager;\n\n  // Terminate for SimscapeExecutionBlock: '<S69>/STATE_1'\n  diagnosticManager = static_cast<NeuDiagnosticManager *>\n    (simulation_DW.STATE_1_DiagMgr);\n  neu_destroy_diagnostic_manager(diagnosticManager);\n  simulationData = static_cast<NeslSimulationData *>\n    (simulation_DW.STATE_1_SimData);\n  nesl_destroy_simulation_data(simulationData);\n  nesl_erase_simulator(\"simulation/Plant/ World Setup/Solver Configuration_1\");\n  nesl_destroy_registry();\n\n  // Terminate for SimscapeExecutionBlock: '<S69>/OUTPUT_1_0'\n  diagnosticManager = static_cast<NeuDiagnosticManager *>\n    (simulation_DW.OUTPUT_1_0_DiagMgr);\n  neu_destroy_diagnostic_manager(diagnosticManager);\n  simulationData = static_cast<NeslSimulationData *>\n    (simulation_DW.OUTPUT_1_0_SimData);\n  nesl_destroy_simulation_data(simulationData);\n  nesl_erase_simulator(\"simulation/Plant/ World Setup/Solver Configuration_1\");\n  nesl_destroy_registry();\n\n  // Terminate for SimscapeExecutionBlock: '<S69>/OUTPUT_1_1'\n  diagnosticManager = static_cast<NeuDiagnosticManager *>\n    (simulation_DW.OUTPUT_1_1_DiagMgr);\n  neu_destroy_diagnostic_manager(diagnosticManager);\n  simulationData = static_cast<NeslSimulationData *>\n    (simulation_DW.OUTPUT_1_1_SimData);\n  nesl_destroy_simulation_data(simulationData);\n  nesl_erase_simulator(\"simulation/Plant/ World Setup/Solver Configuration_1\");\n  nesl_destroy_registry();\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"simulation.h","type":"header","group":"model","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// File: simulation.h\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_simulation_h_\n#define RTW_HEADER_simulation_h_\n#include \"rtwtypes.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#include \"nesl_rtw.h\"\n#include \"simulation_b048d748_1_gateway.h\"\n#include \"simulation_types.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <cstring>\n\n// Macros for accessing real-time model data structure\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n#ifndef rtmGetTStart\n#define rtmGetTStart(rtm)              ((rtm)->Timing.tStart)\n#endif\n\n// Block signals (default storage)\nstruct B_simulation_T {\n  real_T RandomNumber;                 // '<S36>/Random Number'\n  real_T UnitDelay;                    // '<S62>/Unit Delay'\n  real_T Abs;                          // '<S62>/Abs'\n  real_T Switch;                       // '<S62>/Switch'\n  real_T INPUT_4_1_1[4];               // '<S69>/INPUT_4_1_1'\n  real_T UnitDelay1;                   // '<S62>/Unit Delay1'\n  real_T Abs1;                         // '<S62>/Abs1'\n  real_T Switch1;                      // '<S62>/Switch1'\n  real_T INPUT_5_1_1[4];               // '<S69>/INPUT_5_1_1'\n  real_T UnitDelay_k;                  // '<S5>/Unit Delay'\n  real_T UnitDelay1_p;                 // '<S5>/Unit Delay1'\n  real_T INPUT_1_1_1[4];               // '<S69>/INPUT_1_1_1'\n  real_T STATE_1[27];                  // '<S69>/STATE_1'\n  real_T OUTPUT_1_0[18];               // '<S69>/OUTPUT_1_0'\n  real_T Product;                      // '<S56>/Product'\n  real_T Product1;                     // '<S56>/Product1'\n  real_T Product2;                     // '<S56>/Product2'\n  real_T Product3;                     // '<S56>/Product3'\n  real_T Sum;                          // '<S56>/Sum'\n  real_T sqrt_n;                       // '<S55>/sqrt'\n  real_T Product_d;                    // '<S50>/Product'\n  real_T Product1_c;                   // '<S50>/Product1'\n  real_T Product2_l;                   // '<S50>/Product2'\n  real_T Product3_l;                   // '<S50>/Product3'\n  real_T fcn1;                         // '<S46>/fcn1'\n  real_T fcn2;                         // '<S46>/fcn2'\n  real_T fcn3;                         // '<S46>/fcn3'\n  real_T Merge;                        // '<S51>/Merge'\n  real_T fcn4;                         // '<S46>/fcn4'\n  real_T fcn5;                         // '<S46>/fcn5'\n  real_T VectorConcatenate[3];         // '<S49>/Vector Concatenate'\n  real_T Abs_m;                        // '<S36>/Abs'\n  real_T Cos;                          // '<S36>/Cos'\n  real_T Abs1_h;                       // '<S36>/Abs1'\n  real_T Cos1;                         // '<S36>/Cos1'\n  real_T multiply;                     // '<S36>/multiply'\n  real_T Divide;                       // '<S36>/Divide'\n  real_T Plus;                         // '<S36>/Plus'\n  real_T INPUT_2_1_1[4];               // '<S69>/INPUT_2_1_1'\n  real_T INPUT_3_1_1[4];               // '<S69>/INPUT_3_1_1'\n  real_T OUTPUT_1_1[6];                // '<S69>/OUTPUT_1_1'\n  real_T ZeroOrderHold1[3];            // '<S17>/Zero-Order Hold1'\n  real_T ZeroOrderHold2[3];            // '<S17>/Zero-Order Hold2'\n  real_T ZeroOrderHold[4];             // '<S17>/Zero-Order Hold'\n  real_T thrust;                       // '<S5>/stage2_thrust_calculate'\n  real_T thrust_j;                     // '<S5>/stage1_thrust_calculate'\n  real_T attached;                     // '<S5>/Discretizer'\n  real_T s1_et;                        // '<S5>/Discretizer'\n  real_T s2_et;                        // '<S5>/Discretizer'\n};\n\n// Block states (default storage) for system '<Root>'\nstruct DW_simulation_T {\n  fusion_simulink_imuSensor_sim_T obj; // '<S17>/IMU'\n  real_T UnitDelay_DSTATE;             // '<S62>/Unit Delay'\n  real_T INPUT_4_1_1_Discrete;         // '<S69>/INPUT_4_1_1'\n  real_T INPUT_4_1_1_FirstOutput;      // '<S69>/INPUT_4_1_1'\n  real_T UnitDelay1_DSTATE;            // '<S62>/Unit Delay1'\n  real_T INPUT_5_1_1_Discrete;         // '<S69>/INPUT_5_1_1'\n  real_T INPUT_5_1_1_FirstOutput;      // '<S69>/INPUT_5_1_1'\n  real_T UnitDelay_DSTATE_m;           // '<S5>/Unit Delay'\n  real_T UnitDelay1_DSTATE_j;          // '<S5>/Unit Delay1'\n  real_T INPUT_1_1_1_Discrete[2];      // '<S69>/INPUT_1_1_1'\n  real_T INPUT_2_1_1_Discrete[2];      // '<S69>/INPUT_2_1_1'\n  real_T INPUT_3_1_1_Discrete[2];      // '<S69>/INPUT_3_1_1'\n  real_T NextOutput;                   // '<S36>/Random Number'\n  real_T STATE_1_Discrete;             // '<S69>/STATE_1'\n  real_T OUTPUT_1_0_Discrete;          // '<S69>/OUTPUT_1_0'\n  real_T OUTPUT_1_1_Discrete;          // '<S69>/OUTPUT_1_1'\n  void* STATE_1_Simulator;             // '<S69>/STATE_1'\n  void* STATE_1_SimData;               // '<S69>/STATE_1'\n  void* STATE_1_DiagMgr;               // '<S69>/STATE_1'\n  void* STATE_1_ZcLogger;              // '<S69>/STATE_1'\n  void* STATE_1_TsInfo;                // '<S69>/STATE_1'\n  void* OUTPUT_1_0_Simulator;          // '<S69>/OUTPUT_1_0'\n  void* OUTPUT_1_0_SimData;            // '<S69>/OUTPUT_1_0'\n  void* OUTPUT_1_0_DiagMgr;            // '<S69>/OUTPUT_1_0'\n  void* OUTPUT_1_0_ZcLogger;           // '<S69>/OUTPUT_1_0'\n  void* OUTPUT_1_0_TsInfo;             // '<S69>/OUTPUT_1_0'\n  void* OUTPUT_1_1_Simulator;          // '<S69>/OUTPUT_1_1'\n  void* OUTPUT_1_1_SimData;            // '<S69>/OUTPUT_1_1'\n  void* OUTPUT_1_1_DiagMgr;            // '<S69>/OUTPUT_1_1'\n  void* OUTPUT_1_1_ZcLogger;           // '<S69>/OUTPUT_1_1'\n  void* OUTPUT_1_1_TsInfo;             // '<S69>/OUTPUT_1_1'\n  void* SINK_1_RtwLogger;              // '<S69>/SINK_1'\n  void* SINK_1_RtwLogBuffer;           // '<S69>/SINK_1'\n  void* SINK_1_RtwLogFcnManager;       // '<S69>/SINK_1'\n  uint32_T RandSeed;                   // '<S36>/Random Number'\n  uint32_T temporalCounter_i1;         // '<S5>/Discretizer'\n  int_T STATE_1_Modes;                 // '<S69>/STATE_1'\n  int_T OUTPUT_1_0_Modes;              // '<S69>/OUTPUT_1_0'\n  int_T OUTPUT_1_1_Modes;              // '<S69>/OUTPUT_1_1'\n  int8_T If_ActiveSubsystem;           // '<S51>/If'\n  uint8_T is_active_c3_simulation;     // '<S5>/Discretizer'\n  uint8_T is_c3_simulation;            // '<S5>/Discretizer'\n  uint8_T is_S1_fire;                  // '<S5>/Discretizer'\n  boolean_T STATE_1_FirstOutput;       // '<S69>/STATE_1'\n  boolean_T OUTPUT_1_0_FirstOutput;    // '<S69>/OUTPUT_1_0'\n  boolean_T OUTPUT_1_1_FirstOutput;    // '<S69>/OUTPUT_1_1'\n  boolean_T objisempty;                // '<S17>/IMU'\n};\n\n// Continuous states (default storage)\nstruct X_simulation_T {\n  real_T simulationPlantTVC_PhysicsSimul[2];// '<S69>/INPUT_4_1_1'\n  real_T simulationPlantTVC_PhysicsSim_a[2];// '<S69>/INPUT_5_1_1'\n  real_T simulationPlantRocket_BodyFree_[26];// '<S69>/STATE_1'\n};\n\n// State derivatives (default storage)\nstruct XDot_simulation_T {\n  real_T simulationPlantTVC_PhysicsSimul[2];// '<S69>/INPUT_4_1_1'\n  real_T simulationPlantTVC_PhysicsSim_a[2];// '<S69>/INPUT_5_1_1'\n  real_T simulationPlantRocket_BodyFree_[26];// '<S69>/STATE_1'\n};\n\n// State disabled\nstruct XDis_simulation_T {\n  boolean_T simulationPlantTVC_PhysicsSimul[2];// '<S69>/INPUT_4_1_1'\n  boolean_T simulationPlantTVC_PhysicsSim_a[2];// '<S69>/INPUT_5_1_1'\n  boolean_T simulationPlantRocket_BodyFree_[26];// '<S69>/STATE_1'\n};\n\n#ifndef ODE3_INTG\n#define ODE3_INTG\n\n// ODE3 Integration Data\nstruct ODE3_IntgData {\n  real_T *y;                           // output\n  real_T *f[3];                        // derivatives\n};\n\n#endif\n\n// Constant parameters (default storage)\nstruct ConstP_simulation_T {\n  // Expression: [ 27.5550, -2.4169, -16.0849 ]\n  //  Referenced by: '<S17>/IMU'\n\n  real_T IMU_MagneticFieldNED[3];\n\n  // Pooled Parameter (Expression: [ 0, 0, 0 ])\n  //  Referenced by: '<S17>/IMU'\n\n  real_T pooled3[3];\n\n  // Pooled Parameter (Expression: [ 100, 0, 0; 0, 100, 0; 0, 0, 100 ])\n  //  Referenced by: '<S17>/IMU'\n\n  real_T pooled4[9];\n\n  // Pooled Parameter (Expression: fractalcoef().Denominator)\n  //  Referenced by: '<S17>/IMU'\n\n  real_T pooled6[2];\n\n  // Pooled Parameter (Expression: stage1_series)\n  //  Referenced by:\n  //    '<S5>/series'\n  //    '<S5>/series1'\n\n  real_T pooled7[12];\n};\n\n// External inputs (root inport signals with default storage)\nstruct ExtU_simulation_T {\n  real_T tvcxangle;                    // '<Root>/tvc x angle'\n  real_T tvcyangle;                    // '<Root>/tvc y angle'\n  real_T ignite_s1;                    // '<Root>/ignite_s1'\n  real_T ignite_s2;                    // '<Root>/ignite_s2'\n};\n\n// External outputs (root outports fed by signals with default storage)\nstruct ExtY_simulation_T {\n  real_T lidar;                        // '<Root>/lidar'\n  real_T omega[3];                     // '<Root>/omega'\n  real_T acceleration[3];              // '<Root>/acceleration'\n  real_T mag[3];                       // '<Root>/mag'\n  real_T truestate[14];                // '<Root>/true state'\n};\n\n// Real-time Model Data Structure\nstruct tag_RTM_simulation_T {\n  const char_T *errorStatus;\n  RTWSolverInfo solverInfo;\n  X_simulation_T *contStates;\n  int_T *periodicContStateIndices;\n  real_T *periodicContStateRanges;\n  real_T *derivs;\n  XDis_simulation_T *contStateDisabled;\n  boolean_T zCCacheNeedsReset;\n  boolean_T derivCacheNeedsReset;\n  boolean_T CTOutputIncnstWithState;\n  real_T odeY[30];\n  real_T odeF[3][30];\n  ODE3_IntgData intgData;\n\n  //\n  //  Sizes:\n  //  The following substructure contains sizes information\n  //  for many of the model attributes such as inputs, outputs,\n  //  dwork, sample times, etc.\n\n  struct {\n    int_T numContStates;\n    int_T numPeriodicContStates;\n    int_T numSampTimes;\n  } Sizes;\n\n  //\n  //  Timing:\n  //  The following substructure contains information regarding\n  //  the timing information for the model.\n\n  struct {\n    uint32_T clockTick0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    struct {\n      uint8_T TID[3];\n    } TaskCounters;\n\n    time_T tStart;\n    SimTimeStep simTimeStep;\n    boolean_T stopRequestedFlag;\n    time_T *t;\n    time_T tArray[3];\n  } Timing;\n};\n\n// Block signals (default storage)\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern struct B_simulation_T simulation_B;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n// Continuous states (default storage)\nextern X_simulation_T simulation_X;\n\n// Disabled states (default storage)\nextern XDis_simulation_T simulation_XDis;\n\n// Block states (default storage)\nextern struct DW_simulation_T simulation_DW;\n\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  // External inputs (root inport signals with default storage)\n  extern struct ExtU_simulation_T simulation_U;\n\n  // External outputs (root outports fed by signals with default storage)\n  extern struct ExtY_simulation_T simulation_Y;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n// Constant parameters (default storage)\nextern const ConstP_simulation_T simulation_ConstP;\n\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  // Model entry point functions\n  extern void simulation_initialize(void);\n  extern void simulation_step(void);\n  extern void simulation_terminate(void);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n// Real-time Model object\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern RT_MODEL_simulation_T *const simulation_M;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n//-\n//  These blocks were eliminated from the model due to optimizations:\n//\n//  Block '<S25>/RESHAPE' : Reshape block reduction\n//  Block '<S43>/RESHAPE' : Reshape block reduction\n//  Block '<S17>/Reshape' : Reshape block reduction\n//  Block '<S17>/Reshape1' : Reshape block reduction\n//  Block '<S17>/Reshape2' : Reshape block reduction\n//  Block '<S47>/RESHAPE' : Reshape block reduction\n\n\n//-\n//  The generated code includes comments that allow you to trace directly\n//  back to the appropriate location in the model.  The basic format\n//  is <system>/block_name, where system is the system number (uniquely\n//  assigned by Simulink) and block_name is the name of the block.\n//\n//  Use the MATLAB hilite_system command to trace the generated code back\n//  to the model.  For example,\n//\n//  hilite_system('<S3>')    - opens system 3\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n//\n//  Here is the system hierarchy for this model\n//\n//  '<Root>' : 'simulation'\n//  '<S1>'   : 'simulation/Plant'\n//  '<S2>'   : 'simulation/Plant/ Rocket Body'\n//  '<S3>'   : 'simulation/Plant/ TVC Physics'\n//  '<S4>'   : 'simulation/Plant/ World Setup'\n//  '<S5>'   : 'simulation/Plant/Thrust Management'\n//  '<S6>'   : 'simulation/Plant/ Rocket Body/PS-Simulink Converter'\n//  '<S7>'   : 'simulation/Plant/ Rocket Body/PS-Simulink Converter1'\n//  '<S8>'   : 'simulation/Plant/ Rocket Body/PS-Simulink Converter10'\n//  '<S9>'   : 'simulation/Plant/ Rocket Body/PS-Simulink Converter2'\n//  '<S10>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter3'\n//  '<S11>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter4'\n//  '<S12>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter5'\n//  '<S13>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter6'\n//  '<S14>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter7'\n//  '<S15>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter8'\n//  '<S16>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter9'\n//  '<S17>'  : 'simulation/Plant/ Rocket Body/Subsystem'\n//  '<S18>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter/EVAL_KEY'\n//  '<S19>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter1/EVAL_KEY'\n//  '<S20>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter10/EVAL_KEY'\n//  '<S21>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter2/EVAL_KEY'\n//  '<S22>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter3/EVAL_KEY'\n//  '<S23>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter4/EVAL_KEY'\n//  '<S24>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter5/EVAL_KEY'\n//  '<S25>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter6/EVAL_KEY'\n//  '<S26>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter7/EVAL_KEY'\n//  '<S27>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter8/EVAL_KEY'\n//  '<S28>'  : 'simulation/Plant/ Rocket Body/PS-Simulink Converter9/EVAL_KEY'\n//  '<S29>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter'\n//  '<S30>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter1'\n//  '<S31>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter2'\n//  '<S32>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter3'\n//  '<S33>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter4'\n//  '<S34>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter5'\n//  '<S35>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter6'\n//  '<S36>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation'\n//  '<S37>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter/EVAL_KEY'\n//  '<S38>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter1/EVAL_KEY'\n//  '<S39>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter2/EVAL_KEY'\n//  '<S40>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter3/EVAL_KEY'\n//  '<S41>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter4/EVAL_KEY'\n//  '<S42>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter5/EVAL_KEY'\n//  '<S43>'  : 'simulation/Plant/ Rocket Body/Subsystem/PS-Simulink Converter6/EVAL_KEY'\n//  '<S44>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/PS-Simulink Converter'\n//  '<S45>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/PS-Simulink Converter1'\n//  '<S46>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/Quaternions to Rotation Angles'\n//  '<S47>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/PS-Simulink Converter/EVAL_KEY'\n//  '<S48>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/PS-Simulink Converter1/EVAL_KEY'\n//  '<S49>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/Quaternions to Rotation Angles/Angle Calculation'\n//  '<S50>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/Quaternions to Rotation Angles/Quaternion Normalize'\n//  '<S51>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/Quaternions to Rotation Angles/Angle Calculation/Protect asincos input'\n//  '<S52>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/Quaternions to Rotation Angles/Angle Calculation/Protect asincos input/If Action Subsystem'\n//  '<S53>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/Quaternions to Rotation Angles/Angle Calculation/Protect asincos input/If Action Subsystem1'\n//  '<S54>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/Quaternions to Rotation Angles/Angle Calculation/Protect asincos input/If Action Subsystem2'\n//  '<S55>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/Quaternions to Rotation Angles/Quaternion Normalize/Quaternion Modulus'\n//  '<S56>'  : 'simulation/Plant/ Rocket Body/Subsystem/lidar calculation/Quaternions to Rotation Angles/Quaternion Normalize/Quaternion Modulus/Quaternion Norm'\n//  '<S57>'  : 'simulation/Plant/ TVC Physics/Simulink-PS Converter'\n//  '<S58>'  : 'simulation/Plant/ TVC Physics/Simulink-PS Converter1'\n//  '<S59>'  : 'simulation/Plant/ TVC Physics/Simulink-PS Converter2'\n//  '<S60>'  : 'simulation/Plant/ TVC Physics/Simulink-PS Converter4'\n//  '<S61>'  : 'simulation/Plant/ TVC Physics/Simulink-PS Converter5'\n//  '<S62>'  : 'simulation/Plant/ TVC Physics/rotation limiter'\n//  '<S63>'  : 'simulation/Plant/ TVC Physics/Simulink-PS Converter/EVAL_KEY'\n//  '<S64>'  : 'simulation/Plant/ TVC Physics/Simulink-PS Converter1/EVAL_KEY'\n//  '<S65>'  : 'simulation/Plant/ TVC Physics/Simulink-PS Converter2/EVAL_KEY'\n//  '<S66>'  : 'simulation/Plant/ TVC Physics/Simulink-PS Converter4/EVAL_KEY'\n//  '<S67>'  : 'simulation/Plant/ TVC Physics/Simulink-PS Converter5/EVAL_KEY'\n//  '<S68>'  : 'simulation/Plant/ World Setup/Solver Configuration'\n//  '<S69>'  : 'simulation/Plant/ World Setup/Solver Configuration/EVAL_KEY'\n//  '<S70>'  : 'simulation/Plant/Thrust Management/Discretizer'\n//  '<S71>'  : 'simulation/Plant/Thrust Management/stage1_thrust_calculate'\n//  '<S72>'  : 'simulation/Plant/Thrust Management/stage2_thrust_calculate'\n\n#endif                                 // RTW_HEADER_simulation_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"simulation_private.h","type":"header","group":"model","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// File: simulation_private.h\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_simulation_private_h_\n#define RTW_HEADER_simulation_private_h_\n#include \"rtwtypes.h\"\n#include \"simulation_types.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n\n// Private macros used by the generated code to access rtModel\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\nextern real_T rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u);\nextern real_T rt_nrand_Upu32_Yd_f_pw_snf(uint32_T *u);\n\n// private model entry point functions\nextern void simulation_derivatives(void);\n\n#endif                                 // RTW_HEADER_simulation_private_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"simulation_types.h","type":"header","group":"model","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// File: simulation_types.h\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_simulation_types_h_\n#define RTW_HEADER_simulation_types_h_\n#include \"rtwtypes.h\"\n#ifndef struct_sI9OZ8YWn5qr2iby6yfJzBB_simul_T\n#define struct_sI9OZ8YWn5qr2iby6yfJzBB_simul_T\n\nstruct sI9OZ8YWn5qr2iby6yfJzBB_simul_T\n{\n  real_T Numerator;\n  real_T Denominator[2];\n};\n\n#endif                                // struct_sI9OZ8YWn5qr2iby6yfJzBB_simul_T\n\n#ifndef struct_rtString_simulation_T\n#define struct_rtString_simulation_T\n\nstruct rtString_simulation_T\n{\n  char_T Value[12];\n};\n\n#endif                                 // struct_rtString_simulation_T\n\n#ifndef struct_g_fusion_internal_Acceleromet_T\n#define struct_g_fusion_internal_Acceleromet_T\n\nstruct g_fusion_internal_Acceleromet_T\n{\n  boolean_T tunablePropertyChanged[12];\n  int32_T isInitialized;\n  boolean_T TunablePropsChanged;\n  real_T MeasurementRange;\n  real_T Resolution;\n  real_T ConstantBias[3];\n  real_T AxesMisalignment[9];\n  real_T NoiseDensity[3];\n  real_T BiasInstability[3];\n  real_T RandomWalk[3];\n  sI9OZ8YWn5qr2iby6yfJzBB_simul_T BiasInstabilityCoefficients;\n  rtString_simulation_T NoiseType;\n  real_T TemperatureBias[3];\n  real_T TemperatureScaleFactor[3];\n  real_T Temperature;\n  real_T pBandwidth;\n  real_T pCorrelationTime;\n  real_T pBiasInstFilterNum;\n  real_T pBiasInstFilterDen[2];\n  real_T pBiasInstFilterStates[3];\n  real_T pStdDevBiasInst[3];\n  real_T pStdDevWhiteNoise[3];\n  real_T pRandWalkFilterStates[3];\n  real_T pStdDevRandWalk[3];\n  real_T pGain[9];\n};\n\n#endif                                // struct_g_fusion_internal_Acceleromet_T\n\n#ifndef struct_h_fusion_internal_GyroscopeSi_T\n#define struct_h_fusion_internal_GyroscopeSi_T\n\nstruct h_fusion_internal_GyroscopeSi_T\n{\n  boolean_T tunablePropertyChanged[13];\n  int32_T isInitialized;\n  boolean_T TunablePropsChanged;\n  real_T MeasurementRange;\n  real_T Resolution;\n  real_T ConstantBias[3];\n  real_T AxesMisalignment[9];\n  real_T NoiseDensity[3];\n  real_T BiasInstability[3];\n  real_T RandomWalk[3];\n  sI9OZ8YWn5qr2iby6yfJzBB_simul_T BiasInstabilityCoefficients;\n  rtString_simulation_T NoiseType;\n  real_T TemperatureBias[3];\n  real_T TemperatureScaleFactor[3];\n  real_T Temperature;\n  real_T pBandwidth;\n  real_T pCorrelationTime;\n  real_T pBiasInstFilterNum;\n  real_T pBiasInstFilterDen[2];\n  real_T pBiasInstFilterStates[3];\n  real_T pStdDevBiasInst[3];\n  real_T pStdDevWhiteNoise[3];\n  real_T pRandWalkFilterStates[3];\n  real_T pStdDevRandWalk[3];\n  real_T pGain[9];\n  real_T AccelerationBias[3];\n  real_T pAcceleration[3];\n};\n\n#endif                                // struct_h_fusion_internal_GyroscopeSi_T\n\n#ifndef struct_i_fusion_internal_Magnetomete_T\n#define struct_i_fusion_internal_Magnetomete_T\n\nstruct i_fusion_internal_Magnetomete_T\n{\n  boolean_T tunablePropertyChanged[12];\n  int32_T isInitialized;\n  boolean_T TunablePropsChanged;\n  real_T MeasurementRange;\n  real_T Resolution;\n  real_T ConstantBias[3];\n  real_T AxesMisalignment[9];\n  real_T NoiseDensity[3];\n  real_T BiasInstability[3];\n  real_T RandomWalk[3];\n  sI9OZ8YWn5qr2iby6yfJzBB_simul_T BiasInstabilityCoefficients;\n  rtString_simulation_T NoiseType;\n  real_T TemperatureBias[3];\n  real_T TemperatureScaleFactor[3];\n  real_T Temperature;\n  real_T pBandwidth;\n  real_T pCorrelationTime;\n  real_T pBiasInstFilterNum;\n  real_T pBiasInstFilterDen[2];\n  real_T pBiasInstFilterStates[3];\n  real_T pStdDevBiasInst[3];\n  real_T pStdDevWhiteNoise[3];\n  real_T pRandWalkFilterStates[3];\n  real_T pStdDevRandWalk[3];\n  real_T pGain[9];\n};\n\n#endif                                // struct_i_fusion_internal_Magnetomete_T\n\n#ifndef struct_fusion_simulink_imuSensor_sim_T\n#define struct_fusion_simulink_imuSensor_sim_T\n\nstruct fusion_simulink_imuSensor_sim_T\n{\n  boolean_T tunablePropertyChanged[38];\n  int32_T isInitialized;\n  boolean_T TunablePropsChanged;\n  real_T Temperature;\n  uint32_T pStreamState[625];\n  g_fusion_internal_Acceleromet_T *pAccel;\n  h_fusion_internal_GyroscopeSi_T *pGyro;\n  i_fusion_internal_Magnetomete_T *pMag;\n  real_T MagneticFieldNED[3];\n  real_T MagneticField[3];\n  real_T AccelParamsMeasurementRange;\n  real_T AccelParamsResolution;\n  real_T AccelParamsConstantBias[3];\n  real_T AccelParamsAxesMisalignment[9];\n  real_T AccelParamsNoiseDensity[3];\n  real_T AccelParamsBiasInstability[3];\n  real_T AccelParamsBiasInstabilityNumerator;\n  real_T AccelParamsBiasInstabilityDenominator[2];\n  real_T AccelParamsRandomWalk[3];\n  real_T AccelParamsTemperatureBias[3];\n  real_T AccelParamsTemperatureScaleFactor[3];\n  real_T GyroParamsMeasurementRange;\n  real_T GyroParamsResolution;\n  real_T GyroParamsConstantBias[3];\n  real_T GyroParamsAxesMisalignment[9];\n  real_T GyroParamsNoiseDensity[3];\n  real_T GyroParamsBiasInstability[3];\n  real_T GyroParamsBiasInstabilityNumerator;\n  real_T GyroParamsBiasInstabilityDenominator[2];\n  real_T GyroParamsRandomWalk[3];\n  real_T GyroParamsTemperatureBias[3];\n  real_T GyroParamsTemperatureScaleFactor[3];\n  real_T GyroParamsAccelerationBias[3];\n  real_T MagParamsMeasurementRange;\n  real_T MagParamsResolution;\n  real_T MagParamsConstantBias[3];\n  real_T MagParamsAxesMisalignment[9];\n  real_T MagParamsNoiseDensity[3];\n  real_T MagParamsBiasInstability[3];\n  real_T MagParamsBiasInstabilityNumerator;\n  real_T MagParamsBiasInstabilityDenominator[2];\n  real_T MagParamsRandomWalk[3];\n  real_T MagParamsTemperatureBias[3];\n  real_T MagParamsTemperatureScaleFactor[3];\n  i_fusion_internal_Magnetomete_T _pobj0;\n  h_fusion_internal_GyroscopeSi_T _pobj1;\n  g_fusion_internal_Acceleromet_T _pobj2;\n};\n\n#endif                                // struct_fusion_simulink_imuSensor_sim_T\n\n// Forward declaration for rtModel\ntypedef struct tag_RTM_simulation_T RT_MODEL_simulation_T;\n\n#endif                                 // RTW_HEADER_simulation_types_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"simulation_data.cpp","type":"source","group":"data","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Data files","code":"//\n// File: simulation_data.cpp\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"simulation.h\"\n\n// Constant parameters (default storage)\nconst ConstP_simulation_T simulation_ConstP{\n  // Expression: [ 27.5550, -2.4169, -16.0849 ]\n  //  Referenced by: '<S17>/IMU'\n\n  { 27.555, -2.4169, -16.0849 },\n\n  // Pooled Parameter (Expression: [ 0, 0, 0 ])\n  //  Referenced by: '<S17>/IMU'\n\n  { 0.0, 0.0, 0.0 },\n\n  // Pooled Parameter (Expression: [ 100, 0, 0; 0, 100, 0; 0, 0, 100 ])\n  //  Referenced by: '<S17>/IMU'\n\n  { 100.0, 0.0, 0.0, 0.0, 100.0, 0.0, 0.0, 0.0, 100.0 },\n\n  // Pooled Parameter (Expression: fractalcoef().Denominator)\n  //  Referenced by: '<S17>/IMU'\n\n  { 1.0, -0.5 },\n\n  // Pooled Parameter (Expression: stage1_series)\n  //  Referenced by:\n  //    '<S5>/series'\n  //    '<S5>/series1'\n\n  { 0.0, 0.0, 0.275, 18.0, 0.35, 18.0, 1.5, 18.0, 4.6, 18.0, 4.65, 0.0 }\n};\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// File: rtGetInf.cpp\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  //\n  // Initialize rtInf needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T inf{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0x7FF00000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      inf = tmpVal.fltVal;\n    }\n\n    return inf;\n  }\n\n  //\n  // Initialize rtInfF needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  //\n  // Initialize rtMinusInf needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T minf{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0xFFF00000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      minf = tmpVal.fltVal;\n    }\n\n    return minf;\n  }\n\n  //\n  // Initialize rtMinusInfF needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// File: rtGetInf.h\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      // extern \"C\"\n\n#endif\n#endif                                 // RTW_HEADER_rtGetInf_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// File: rtGetNaN.cpp\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  //\n  // Initialize rtNaN needed by the generated code.\n  // NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    real_T nan{ 0.0 };\n\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0xFFF80000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      nan = tmpVal.fltVal;\n    }\n\n    return nan;\n  }\n\n  //\n  // Initialize rtNaNF needed by the generated code.\n  // NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF{ { 0.0F } };\n\n    nanF.wordL.wordLuint = 0xFFC00000U;\n    return nanF.wordL.wordLreal;\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// File: rtGetNaN.h\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      // extern \"C\"\n\n#endif\n#endif                                 // RTW_HEADER_rtGetNaN_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// File: rt_defines.h\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_rt_defines_h_\n#define RTW_HEADER_rt_defines_h_\n\n//===========*\n//  Constants *\n// ===========\n#define RT_PI                          3.14159265358979323846\n#define RT_PIF                         3.1415927F\n#define RT_LN_10                       2.30258509299404568402\n#define RT_LN_10F                      2.3025851F\n#define RT_LOG10E                      0.43429448190325182765\n#define RT_LOG10EF                     0.43429449F\n#define RT_E                           2.7182818284590452354\n#define RT_EF                          2.7182817F\n\n//\n//  UNUSED_PARAMETER(x)\n//    Used to specify that a function parameter (argument) is required but not\n//    accessed by the function body.\n\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x)                                      // do nothing\n#else\n\n//\n//  This is the semi-ANSI standard way of indicating that an\n//  unused function parameter is required.\n\n#define UNUSED_PARAMETER(x)            (void) (x)\n#endif\n#endif\n#endif                                 // RTW_HEADER_rt_defines_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// File: rt_nonfinite.cpp\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  //\n  // Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n  // generated code. NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  // Test if value is infinite\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  // Test if single-precision value is infinite\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  // Test if value is not a number\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result{ (boolean_T) 0 };\n\n    size_t bitsPerReal{ sizeof(real_T) * (NumBitsPerChar) };\n\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.fltVal = value;\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                           0x7FF00000 &&\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                            (tmpVal.bitVal.words.wordL != 0) ));\n    }\n\n    return result;\n  }\n\n  // Test if single-precision value is not a number\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// File: rt_nonfinite.h\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      // extern \"C\"\n\n#endif\n#endif                                 // RTW_HEADER_rt_nonfinite_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// File: rtwtypes.h\n//\n// Code generated for Simulink model 'simulation'.\n//\n// Model version                  : 4.1\n// Simulink Coder version         : 23.2 (R2023b) 04-Oct-2023\n// C/C++ source code generated on : Mon Nov  6 23:26:52 2023\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: Intel->x86-64 (Windows64)\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n// Logical type definitions\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n//=======================================================================*\n//  Target hardware information\n//    Device type: Intel->x86-64 (Windows64)\n//    Number of bits:     char:   8    short:   16    int:  32\n//                        long:  32\n//                        native word size:  64\n//    Byte ordering: LittleEndian\n//    Signed integer division rounds to: Zero\n//    Shift right on a signed integer as arithmetic shift: on\n// =======================================================================\n\n//=======================================================================*\n//  Fixed width word size data types:                                     *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\n// =======================================================================\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n//===========================================================================*\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n//                            real_T, time_T, ulong_T.                        *\n// ===========================================================================\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n//===========================================================================*\n//  Complex number type definitions                                           *\n// ===========================================================================\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n//=======================================================================*\n//  Min and Max:                                                          *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n// =======================================================================\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n\n// Block D-Work pointer type\ntypedef void * pointer_T;\n\n#endif                                 // RTWTYPES_H\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_backsubrr_dbl.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\n *\n * File: rt_backsubrr_dbl.c     \n *\n * Abstract:\n *      Simulink Coder support routine which performs\n *      backward substitution: solving Ux=b for real\n *      double precision float operands.\n *\n */\n\n#include \"rt_matrixlib.h\"\n\n/* Function: rt_BackwardSubstitutionRR_Dbl =====================================\n * Abstract: Backward substitution: Solving Ux=b \n *           U: real, double\n *           b: real, double\n *           U is an upper (or unit upper) triangular full matrix.\n *           The entries in the lower triangle are ignored.\n *           U is a NxN matrix\n *           X is a NxP matrix\n *           B is a NxP matrix\n */\nvoid rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\n                                   const real_T    *pb,\n                                   real_T          *x,\n                                   int_T            N,\n                                   int_T            P,\n                                   boolean_T        unit_upper)\n{\n  int_T i,k;\n  for(k=P; k>0; k--) {\n    real_T *pUcol = pU;\n    for(i=0; i<N; i++) {\n      real_T *xj = x + k*N-1;\n      real_T s = 0.0;\n      real_T *pUrow = pUcol--;          /* access current row of U */\n\n      {\n        int_T j = i;\n        while(j-- > 0) {\n          s += *pUrow * *xj--;\n          pUrow -= N;\n        }\n      }\n\n      if (unit_upper) {\n        *xj = *pb-- - s;\n      } else {\n        *xj = (*pb-- - s) / *pUrow;\n      }\n    }\n  }\n}\n\n/* [EOF] rt_backsubrr_dbl.c */\n"},{"name":"rt_forwardsubrr_dbl.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\n *\n * File: rt_forwardsubrr_dbl.c     \n *\n * Abstract:\n *      Simulink Coder support routine which performs\n *      forward substitution: solving Lx=b\n *\n */\n\n#include \"rt_matrixlib.h\"\n\n/* Function: rt_ForwardSubstitutionRR_Dbl ======================================\n * Abstract: Forward substitution: solving Lx=b \n *           L: Real, double\n *           b: Real, double\n *           L is a lower (or unit lower) triangular full matrix.\n *           The entries in the upper triangle are ignored.\n *           L is a NxN matrix\n *           X is a NxP matrix\n *           B is a NxP matrix\n */\nvoid rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\n                                  const real_T  *pb,\n                                  real_T        *x,\n                                  int_T          N,\n                                  int_T          P,\n                                  const int32_T *piv,\n                                  boolean_T      unit_lower)\n{  \n  /* Real inputs: */\n  int_T i, k;\n  for(k=0; k<P; k++) {\n    real_T *pLcol = pL;\n    for(i=0; i<N; i++) {\n      real_T *xj = x + k*N;\n      real_T s = 0.0;\n      real_T *pLrow = pLcol++;          /* access current row of L */\n\n      {\n        int_T j = i;\n        while(j-- > 0) {\n          s += *pLrow * *xj;\n          pLrow += N;\n          xj++;\n        }\n      }\n\n      if (unit_lower) {\n        *xj = pb[piv[i]] - s;\n      } else {\n        *xj = (pb[piv[i]] - s) / *pLrow;\n      }\n    }\n    pb += N;\n  }\n}\n\n/* [EOF] rt_forwardsubrr_dbl.c */\n"},{"name":"rt_lu_real.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\n *\n * File: rt_lu_real.c     \n *\n * Abstract:\n *      Real-Time Workshop support routine for lu_real\n *\n */\n\n#include <math.h>\n#include \"rt_matrixlib.h\"\n\n/* Function: rt_lu_real  =======================================================\n * Abstract: A is real.\n *\n */\nvoid rt_lu_real(real_T      *A,    /* in and out                         */\n                const int_T n,     /* number or rows = number of columns */\n                int32_T     *piv)  /* pivote vector                      */\n{\n  int_T k;\n\n  /* initialize row-pivot indices: */\n  for (k = 0; k < n; k++) {\n    piv[k] = k;\n  }\n\n  /* Loop over each column: */\n  for (k = 0; k < n; k++) {\n    const int_T kn = k*n;\n    int_T p = k;\n\n    /* Scan the lower triangular part of this column only\n     * Record row of largest value\n     */\n    {\n      int_T i;\n      real_T Amax = fabs(A[p+kn]);      /* assume diag is max */\n      for (i = k+1; i < n; i++) {\n        real_T q = fabs(A[i+kn]);\n        if (q > Amax) {p = i; Amax = q;}\n      }\n    }\n\n    /* swap rows if required */\n    if (p != k) {\n      int_T j;\n      int32_T t1;\n      for (j = 0; j < n; j++) {\n        real_T t;\n        const int_T j_n = j*n;\n        t = A[p+j_n]; A[p+j_n] = A[k+j_n]; A[k+j_n] = t;\n      }\n      /* swap pivot row indices */\n      t1 = piv[p]; piv[p] = piv[k]; piv[k] = t1;\n    }\n\n    /* column reduction */\n    {\n      real_T Adiag = A[k+kn];\n      int_T i,j;\n      if (Adiag != 0.0) {               /* non-zero diagonal entry */\n\n        /* divide lower triangular part of column by max */\n        Adiag = 1.0/Adiag;\n        for (i = k+1; i < n; i++) {\n          A[i+kn] *= Adiag;\n        }\n\n        /* subtract multiple of column from remaining columns */\n        for (j = k+1; j < n; j++) {\n          int_T j_n = j*n;\n          for (i = k+1; i < n; i++) {\n            A[i+j_n] -= A[i+kn]*A[k+j_n];\n          }\n        }\n      }\n    }\n  }\n}\n\n/* [EOF] rt_lu_real.c */\n"},{"name":"rt_matrixlib.h","type":"header","group":"other","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef rt_matrixlib_h\n#define rt_matrixlib_h\n\n/* Copyright 2007-2013 The MathWorks, Inc.\n *\n * File    : rt_matrixlib.h\n * Abstract:\n *     Function prototypes for .c sources in rtw/c/src/matrixmath.\n *\n */\n\n\n/*==========*\n * Includes *\n *==========*/\n\n#include \"rtwtypes.h\"\n#include <limits.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Matrix Multiplication Utility Functions */\nextern void rt_MatMultRR_Dbl(real_T         *y, \n                             const real_T   *A, \n                             const real_T   *B, \n                             const int_T dims[3]);\n\n#ifdef CREAL_T\nextern void rt_MatMultRC_Dbl(creal_T       *y,\n                             const real_T  *A,\n                             const creal_T *B,\n                             const int_T dims[3]);\n\nextern void rt_MatMultCR_Dbl(creal_T       *y,\n                             const creal_T *A,\n                             const real_T  *B,\n                             const int_T dims[3]);\n\nextern void rt_MatMultCC_Dbl(creal_T       *y,\n                             const creal_T *A,\n                             const creal_T *B,\n                             const int_T dims[3]);\n#endif\n\nextern void rt_MatMultRR_Sgl(real32_T       *y,\n                             const real32_T *A,\n                             const real32_T *B,\n                             const int_T  dims[3]);\n\n#ifdef CREAL_T\nextern void rt_MatMultRC_Sgl(creal32_T       *y,\n                             const real32_T  *A,\n                             const creal32_T *B,\n                             const int_T   dims[3]);\n\nextern void rt_MatMultCR_Sgl(creal32_T       *y,\n                             const creal32_T *A,\n                             const real32_T  *B,\n                             const int_T   dims[3]);\n\nextern void rt_MatMultCC_Sgl(creal32_T       *y,\n                             const creal32_T *A,\n                             const creal32_T *B,\n                             const int_T   dims[3]);\n#endif\n\nextern void rt_MatMultAndIncRR_Dbl(real_T       *y,\n                                   const real_T *A,\n                                   const real_T *B,\n                                   const int_T dims[3]);\n\n#ifdef CREAL_T\nextern void rt_MatMultAndIncRC_Dbl(creal_T       *y,\n                                   const real_T  *A,\n                                   const creal_T *B,\n                                   const int_T dims[3]);\n\nextern void rt_MatMultAndIncCR_Dbl(creal_T       *y,\n                                   const creal_T *A,\n                                   const real_T  *B,\n                                   const int_T dims[3]);\n\nextern void rt_MatMultAndIncCC_Dbl(creal_T       *y,\n                                   const creal_T *A,\n                                   const creal_T *B,\n                                   const int_T dims[3]);\n#endif\nextern void rt_MatMultAndIncRR_Sgl(real32_T       *y,\n                                   const real32_T *A,\n                                   const real32_T *B,\n                                   const int_T  dims[3]);\n\n#ifdef CREAL_T\nextern void rt_MatMultAndIncRC_Sgl(creal32_T       *y,\n                                   const real32_T  *A,\n                                   const creal32_T *B,\n                                   const int_T   dims[3]);\n\nextern void rt_MatMultAndIncCR_Sgl(creal32_T       *y,\n                                   const creal32_T *A,\n                                   const real32_T  *B,\n                                   const int_T   dims[3]);\n\nextern void rt_MatMultAndIncCC_Sgl(creal32_T       *y,\n                                   const creal32_T *A,\n                                   const creal32_T *B,\n                                   const int_T   dims[3]);\n#endif \n\n/* Matrix Inversion Utility Functions */\nextern void rt_lu_real(real_T      *A,\n                       const int_T n,\n                       int32_T     *piv);\n\n#ifdef CREAL_T\nextern void rt_lu_cplx(creal_T *A,\n                       const int_T n,\n                       int32_T *piv);\n#endif\n\nextern void rt_lu_real_sgl(real32_T      *A,\n                           const int_T n,\n                           int32_T     *piv);\n\n#ifdef CREAL_T\nextern void rt_lu_cplx_sgl(creal32_T *A,\n                           const int_T n,\n                           int32_T *piv);\n#endif\n\nextern void rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\n                                          const real_T    *pb,\n                                          real_T          *x,\n                                          int_T            N,\n                                          int_T            P,\n                                          boolean_T        unit_upper);\n\n#ifdef CREAL_T\nextern void rt_BackwardSubstitutionRC_Dbl(real_T          *pU,\n                                          const creal_T   *pb,\n                                          creal_T         *x,\n                                          int_T            N,\n                                          int_T            P,\n                                          boolean_T        unit_upper);\n\nextern void rt_BackwardSubstitutionCC_Dbl(creal_T         *pU,\n                                          const creal_T   *pb,\n                                          creal_T         *x,\n                                          int_T            N,\n                                          int_T            P,\n                                          boolean_T        unit_upper);\n#endif\n\nextern void rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\n                                         const real_T  *pb,\n                                         real_T        *x,\n                                         int_T          N,\n                                         int_T          P,\n                                         const int32_T *piv,\n                                         boolean_T      unit_lower);\n\n#ifdef CREAL_T\nextern void rt_ForwardSubstitutionRC_Dbl(real_T        *pL,\n                                         const creal_T   *pb,\n                                         creal_T   *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n\nextern void rt_ForwardSubstitutionCR_Dbl(creal_T   *pL,\n                                         const real_T    *pb,\n                                         creal_T   *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n\nextern void rt_ForwardSubstitutionCC_Dbl(creal_T   *pL,\n                                         const creal_T   *pb,\n                                         creal_T   *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n#endif\n\nextern void rt_BackwardSubstitutionRR_Sgl(real32_T          *pU,\n                                          const real32_T    *pb,\n                                          real32_T          *x,\n                                          int_T              N,\n                                          int_T              P,\n                                          boolean_T          unit_upper);\n\n#ifdef CREAL_T\nextern void rt_BackwardSubstitutionRC_Sgl(real32_T          *pU,\n                                          const creal32_T   *pb,\n                                          creal32_T         *x,\n                                          int_T              N,\n                                          int_T              P,\n                                          boolean_T          unit_upper);\n\nextern void rt_BackwardSubstitutionCC_Sgl(creal32_T         *pU,\n                                          const creal32_T   *pb,\n                                          creal32_T         *x,\n                                          int_T              N,\n                                          int_T              P,\n                                          boolean_T          unit_upper);\n#endif\n\nextern void rt_ForwardSubstitutionRR_Sgl(real32_T    *pL,\n                                         const real32_T    *pb,\n                                         real32_T    *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n\n#ifdef CREAL_T\nextern void rt_ForwardSubstitutionRC_Sgl(real32_T    *pL,\n                                         const creal32_T   *pb,\n                                         creal32_T   *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n\nextern void rt_ForwardSubstitutionCR_Sgl(creal32_T   *pL,\n                                         const real32_T    *pb,\n                                         creal32_T   *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n\nextern void rt_ForwardSubstitutionCC_Sgl(creal32_T   *pL,\n                                         const creal32_T   *pb,\n                                         creal32_T   *x,\n                                         int_T     N,\n                                         int_T     P,\n                                         const int32_T   *piv,\n                                         boolean_T unit_lower);\n#endif\n\n\nextern void rt_MatDivRR_Dbl(real_T        *Out,\n                            const real_T  *In1,\n                            const real_T  *In2,\n                            real_T        *lu,\n                            int32_T       *piv,\n                            real_T        *x,\n                            const int_T    dims[3]);\n\n#ifdef CREAL_T\nextern void rt_MatDivRC_Dbl(creal_T       *Out,\n                            const real_T  *In1,\n                            const creal_T *In2,\n                            real_T        *lu,\n                            int32_T       *piv,\n                            creal_T       *x,\n                            const int_T    dims[3]);\n\nextern void rt_MatDivCR_Dbl(creal_T       *Out,\n                            const creal_T *In1,\n                            const real_T  *In2,\n                            creal_T       *lu,\n                            int32_T       *piv,\n                            creal_T       *x,\n                            const int_T    dims[3]);\n\nextern void rt_MatDivCC_Dbl(creal_T       *Out,\n                            const creal_T *In1,\n                            const creal_T *In2,\n                            creal_T       *lu,\n                            int32_T       *piv,\n                            creal_T       *x,\n                            const int_T    dims[3]);\n#endif\n\nextern void rt_MatDivRR_Sgl(real32_T        *Out,\n                            const real32_T  *In1,\n                            const real32_T  *In2,\n                            real32_T        *lu,\n                            int32_T         *piv,\n                            real32_T        *x,\n                            const int_T      dims[3]);\n\n#ifdef CREAL_T\nextern void rt_MatDivRC_Sgl(creal32_T       *Out,\n                            const real32_T  *In1,\n                            const creal32_T *In2,\n                            real32_T        *lu,\n                            int32_T         *piv,\n                            creal32_T       *x,\n                            const int_T      dims[3]);\n\nextern void rt_MatDivCR_Sgl(creal32_T       *Out,\n                            const creal32_T *In1,\n                            const real32_T  *In2,\n                            creal32_T       *lu,\n                            int32_T         *piv,\n                            creal32_T       *x,\n                            const int_T      dims[3]);\n\nextern void rt_MatDivCC_Sgl(creal32_T       *Out,\n                            const creal32_T *In1,\n                            const creal32_T *In2,\n                            creal32_T       *lu,\n                            int32_T         *piv,\n                            creal32_T       *x,\n                            const int_T      dims[3]);\n#endif\n\n\n/* Matrix multiplication defines */\n\n/* Quick (approximate) complex absolute value: */\n#define CQABS(X) (fabs((X).re) + fabs((X).im))\n\n/* Quick (approximate) complex absolute value for singles: */\n#define CQABSSGL(X) (real32_T)(fabs( (real_T) (X).re) + fabs( (real_T) (X).im)) \n\n#ifdef CREAL_T\nextern void rt_ComplexTimes_Dbl(creal_T       *Out,\n                                const creal_T In1,\n                                const creal_T In2);\n\nextern void rt_ComplexRDivide_Dbl(creal_T       *Out,\n                                  const creal_T In1,\n                                  const creal_T In2);\n\nextern void rt_ComplexReciprocal_Dbl(creal_T       *Out,\n                                     const creal_T In1);\n\nextern void rt_ComplexTimes_Sgl(creal32_T       *Out,\n                                const creal32_T In1,\n                                const creal32_T In2);\n\nextern void rt_ComplexRDivide_Sgl(creal32_T       *Out,\n                                  const creal32_T In1,\n                                  const creal32_T In2);\n\nextern void rt_ComplexReciprocal_Sgl(creal32_T       *Out,\n                                     const creal32_T In1);\n\n#endif\n\nextern real_T rt_Hypot_Dbl(real_T In1,\n                           real_T In2);\n\nextern real32_T rt_Hypot_Sgl(real32_T In1,\n                             real32_T In2);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* rt_matrixlib_h */\n"},{"name":"rt_matrixlib_dbl.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2013 The MathWorks, Inc.\n *\n * File: rt_matrixlib_dbl.c\n *\n * Abstract:\n *      Simulink Coder utility functions\n *\n */\n\n#include <math.h>\n#include \"rt_matrixlib.h\"\n\n#ifdef CREAL_T\nvoid rt_ComplexTimes_Dbl(creal_T* c,\n                         const creal_T a,\n                         const creal_T b)\n{\n    if (a.im == 0.0) {\n        c->re = a.re * b.re;\n        c->im = a.re * b.im;\n        if (b.im == 0.0) {\n            c->im = 0.0;\n        } else if (b.re == 0.0 || a.re == 0.0) {\n            c->re = 0.0;\n        }\n    } else if (b.im == 0.0) {\n        c->re = a.re * b.re;\n        c->im = a.im * b.re;\n        if (b.re == 0.0 || a.re == 0.0) { \n            c->re = 0.0;\n        }\n    } else if (a.re == 0.0) {\n        c->re = -a.im * b.im;\n        c->im = a.im * b.re;\n        if (b.re == 0.0) {\n            c->im = 0.0;\n        }\n    } else if (b.re == 0.0) {\n        c->re = -a.im * b.im;\n        c->im = a.re * b.im;\n    } else {\n        c->re = a.re * b.re - a.im * b.im;\n        c->im = a.re * b.im + a.im * b.re;\n    }\n}\n\nvoid rt_ComplexRDivide_Dbl(creal_T* c,\n                           const creal_T a,\n                           const creal_T b)\n{\n    if (b.im == 0.0) {\n        c->re = a.re / b.re;\n        if (a.im == 0.0) {\n            c->im = 0.0;\n        } else { /* a.im != 0.0 */\n            c->im = a.im / b.re;\n            if (a.re == 0.0) {\n                c->re = 0.0;\n            }\n        }\n    } else if (b.re == 0.0) { /* b.im != 0.0 */\n        c->re = a.im / b.im;\n        c->im = -a.re / b.im;\n        if (a.re == 0.0) {\n            c->im = 0.0;\n        } else if (a.im == 0.0) {\n            c->re = 0.0;\n        }\n    } else {\n        real_T brm = fabs(b.re);\n        real_T bim = fabs(b.im);\n        if (brm > bim) {\n            real_T s = b.im / b.re;\n            real_T d = b.re + s * b.im;\n            c->im = (a.im - s * a.re) / d;\n            c->re = (a.re + s * a.im) / d;\n        } else if (brm == bim) {\n            real_T half = 0.5;\n            real_T sgnbr = b.re > 0.0 ? half : -half;\n            real_T sgnbi = b.im > 0.0 ? half : -half;\n            c->im = (a.im*sgnbr - a.re*sgnbi)/brm;\n            c->re = (a.re*sgnbr + a.im*sgnbi)/brm;\n        } else {\n            real_T s = b.re / b.im;\n            real_T d = b.im + s * b.re;\n            c->im = (s * a.im - a.re) / d;\n            c->re = (s * a.re + a.im) / d;\n        }\n    }\n}\n\nvoid rt_ComplexReciprocal_Dbl(creal_T* Out,\n                              const creal_T In1)\n{\n    creal_T y;\n    y.re = 1.0;\n    y.im = 0.0;\n\n    rt_ComplexRDivide_Dbl(Out, y, In1);\n}\n\n#endif\n\n\nreal_T rt_Hypot_Dbl(real_T a, real_T b)\n{\n    real_T y;\n    if (a != a || b != b) {\n        y = a + b;\n    } else {\n        real_T t;\n        if (fabs(a) > fabs(b)) {\n            t = b/a;\n            y = fabs(a)*sqrt(1.0 + t*t);\n        } else {\n            if (b == 0.0) {\n                y = 0.0;\n            } else {\n                t = a/b;\n                y = fabs(b)*sqrt(1.0 + t*t);\n            }\n        }\n    }\n    \n    return y;\n}\n"},{"name":"simulation_b048d748_1.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include \"ne_std.h\"\n#include \"pm_default_allocator.h\"\n#include \"ne_dae.h\"\n#include \"ne_solverparameters.h\"\n#include \"sm_ssci_NeDaePrivateData.h\"\n\nNeDae *sm_ssci_constructDae(NeDaePrivateData *smData);\nvoid simulation_b048d748_1_NeDaePrivateData_create(NeDaePrivateData *smData);\nvoid simulation_b048d748_1_dae(\n  NeDae **dae,\n  const NeModelParameters *modelParams,\n  const NeSolverParameters *solverParams)\n{\n  PmAllocator *alloc = pm_default_allocator();\n  NeDaePrivateData *smData =\n    (NeDaePrivateData *) alloc->mCallocFcn(alloc, sizeof(NeDaePrivateData), 1);\n  (void) modelParams;\n  (void) solverParams;\n  simulation_b048d748_1_NeDaePrivateData_create(smData);\n  *dae = sm_ssci_constructDae(smData);\n}\n"},{"name":"simulation_b048d748_1.h","type":"header","group":"other","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"// Simscape target specific file.\n//  This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n\n\n#ifndef __simulation_b048d748_1_h__\n#define __simulation_b048d748_1_h__\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern void simulation_b048d748_1_dae( NeDae **dae, const NeModelParameters\n    *modelParams,\n    const NeSolverParameters *solverParams);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n#endif\n"},{"name":"simulation_b048d748_1_asm_delegate.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include <math.h>\n#include <string.h>\n#include \"pm_std.h\"\n#include \"sm_std.h\"\n#include \"ne_std.h\"\n#include \"ne_dae.h\"\n#include \"sm_ssci_run_time_errors.h\"\n#include \"sm_RuntimeDerivedValuesBundle.h\"\n#include \"sm_CTarget.h\"\n\nvoid simulation_b048d748_1_setTargets(const RuntimeDerivedValuesBundle *rtdv,\n  CTarget *targets)\n{\n  (void) rtdv;\n  (void) targets;\n}\n\nvoid simulation_b048d748_1_resetAsmStateVector(const void *mech, double *state)\n{\n  double xx[2];\n  (void) mech;\n  xx[0] = 0.0;\n  xx[1] = 1.0;\n  state[0] = xx[0];\n  state[1] = xx[0];\n  state[2] = xx[0];\n  state[3] = xx[1];\n  state[4] = xx[0];\n  state[5] = xx[0];\n  state[6] = xx[0];\n  state[7] = xx[0];\n  state[8] = xx[0];\n  state[9] = xx[0];\n  state[10] = xx[0];\n  state[11] = xx[0];\n  state[12] = xx[0];\n  state[13] = xx[0];\n  state[14] = xx[0];\n  state[15] = xx[0];\n  state[16] = xx[0];\n  state[17] = xx[0];\n  state[18] = xx[0];\n  state[19] = xx[0];\n  state[20] = xx[1];\n  state[21] = xx[0];\n  state[22] = xx[0];\n  state[23] = xx[0];\n  state[24] = xx[0];\n  state[25] = xx[0];\n  state[26] = xx[0];\n  state[27] = xx[0];\n  state[28] = xx[0];\n  state[29] = xx[0];\n}\n\nvoid simulation_b048d748_1_initializeTrackedAngleState(const void *mech, const\n  RuntimeDerivedValuesBundle *rtdv, const int *modeVector, const double\n  *motionData, double *state)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  (void) mech;\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) state;\n  (void) modeVector;\n  (void) motionData;\n}\n\nvoid simulation_b048d748_1_computeDiscreteState(const void *mech, const\n  RuntimeDerivedValuesBundle *rtdv, double *state)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  (void) mech;\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) state;\n}\n\nvoid simulation_b048d748_1_adjustPosition(const void *mech, const double\n  *dofDeltas, double *state)\n{\n  double xx[17];\n  (void) mech;\n  xx[0] = state[3];\n  xx[1] = state[4];\n  xx[2] = state[5];\n  xx[3] = state[6];\n  xx[4] = dofDeltas[3];\n  xx[5] = dofDeltas[4];\n  xx[6] = dofDeltas[5];\n  pm_math_Quaternion_compDeriv_ra(xx + 0, xx + 4, xx + 7);\n  xx[0] = state[3] + xx[7];\n  xx[1] = state[4] + xx[8];\n  xx[2] = state[5] + xx[9];\n  xx[3] = state[6] + xx[10];\n  xx[4] = 1.0e-64;\n  xx[5] = sqrt(xx[0] * xx[0] + xx[1] * xx[1] + xx[2] * xx[2] + xx[3] * xx[3]);\n  if (xx[4] > xx[5])\n    xx[5] = xx[4];\n  xx[6] = state[20];\n  xx[7] = state[21];\n  xx[8] = state[22];\n  xx[9] = state[23];\n  xx[10] = dofDeltas[11];\n  xx[11] = dofDeltas[12];\n  xx[12] = dofDeltas[13];\n  pm_math_Quaternion_compDeriv_ra(xx + 6, xx + 10, xx + 13);\n  xx[6] = state[20] + xx[13];\n  xx[7] = state[21] + xx[14];\n  xx[8] = state[22] + xx[15];\n  xx[9] = state[23] + xx[16];\n  xx[10] = sqrt(xx[6] * xx[6] + xx[7] * xx[7] + xx[8] * xx[8] + xx[9] * xx[9]);\n  if (xx[4] > xx[10])\n    xx[10] = xx[4];\n  state[0] = state[0] + dofDeltas[0];\n  state[1] = state[1] + dofDeltas[1];\n  state[2] = state[2] + dofDeltas[2];\n  state[3] = xx[0] / xx[5];\n  state[4] = xx[1] / xx[5];\n  state[5] = xx[2] / xx[5];\n  state[6] = xx[3] / xx[5];\n  state[13] = state[13] + dofDeltas[6];\n  state[14] = state[14] + dofDeltas[7];\n  state[17] = state[17] + dofDeltas[8];\n  state[18] = state[18] + dofDeltas[9];\n  state[19] = state[19] + dofDeltas[10];\n  state[20] = xx[6] / xx[10];\n  state[21] = xx[7] / xx[10];\n  state[22] = xx[8] / xx[10];\n  state[23] = xx[9] / xx[10];\n}\n\nstatic void perturbAsmJointPrimitiveState_0_0(double mag, double *state)\n{\n  state[0] = state[0] + mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_0_0v(double mag, double *state)\n{\n  state[0] = state[0] + mag;\n  state[7] = state[7] - 0.875 * mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_0_1(double mag, double *state)\n{\n  state[1] = state[1] + mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_0_1v(double mag, double *state)\n{\n  state[1] = state[1] + mag;\n  state[8] = state[8] - 0.875 * mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_0_2(double mag, double *state)\n{\n  state[2] = state[2] + mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_0_2v(double mag, double *state)\n{\n  state[2] = state[2] + mag;\n  state[9] = state[9] - 0.875 * mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_0_3(double mag, double *state)\n{\n  double xx[15];\n  xx[0] = 1.0;\n  xx[1] = fabs(mag);\n  xx[2] = xx[0] / (xx[1] - floor(xx[1]) + 1.0e-9);\n  xx[1] = sin(xx[2]);\n  xx[3] = 0.0;\n  xx[4] = cos(xx[2]);\n  xx[5] = sin(2.0 * xx[2]);\n  xx[2] = 0.5 * mag;\n  xx[6] = sqrt(xx[1] * xx[1] + xx[4] * xx[4] + xx[5] * xx[5]);\n  xx[7] = xx[6] == 0.0 ? 0.0 : xx[1] / xx[6];\n  xx[8] = sin(xx[2]);\n  xx[9] = xx[6] == 0.0 ? 0.0 : xx[4] / xx[6];\n  xx[10] = xx[6] == 0.0 ? 0.0 : xx[5] / xx[6];\n  xx[11] = xx[1] == xx[3] && xx[4] == xx[3] && xx[5] == xx[3] ? xx[0] : cos(xx[2]);\n  xx[12] = xx[7] * xx[8];\n  xx[13] = xx[9] * xx[8];\n  xx[14] = xx[10] * xx[8];\n  xx[0] = state[3];\n  xx[1] = state[4];\n  xx[2] = state[5];\n  xx[3] = state[6];\n  pm_math_Quaternion_compose_ra(xx + 11, xx + 0, xx + 4);\n  state[3] = xx[4];\n  state[4] = xx[5];\n  state[5] = xx[6];\n  state[6] = xx[7];\n}\n\nstatic void perturbAsmJointPrimitiveState_0_3v(double mag, double *state)\n{\n  double xx[15];\n  xx[0] = 1.0;\n  xx[1] = fabs(mag);\n  xx[2] = xx[0] / (xx[1] - floor(xx[1]) + 1.0e-9);\n  xx[1] = sin(xx[2]);\n  xx[3] = 0.0;\n  xx[4] = cos(xx[2]);\n  xx[5] = sin(2.0 * xx[2]);\n  xx[2] = 0.5 * mag;\n  xx[6] = sqrt(xx[1] * xx[1] + xx[4] * xx[4] + xx[5] * xx[5]);\n  xx[7] = xx[6] == 0.0 ? 0.0 : xx[1] / xx[6];\n  xx[8] = sin(xx[2]);\n  xx[9] = xx[6] == 0.0 ? 0.0 : xx[4] / xx[6];\n  xx[10] = xx[6] == 0.0 ? 0.0 : xx[5] / xx[6];\n  xx[11] = xx[1] == xx[3] && xx[4] == xx[3] && xx[5] == xx[3] ? xx[0] : cos(xx[2]);\n  xx[12] = xx[7] * xx[8];\n  xx[13] = xx[9] * xx[8];\n  xx[14] = xx[10] * xx[8];\n  xx[3] = state[3];\n  xx[4] = state[4];\n  xx[5] = state[5];\n  xx[6] = state[6];\n  pm_math_Quaternion_compose_ra(xx + 11, xx + 3, xx + 7);\n  state[3] = xx[7];\n  state[4] = xx[8];\n  state[5] = xx[9];\n  state[6] = xx[10];\n  state[10] = state[10] + 1.2 * mag;\n  state[11] = state[11] - xx[2];\n  state[12] = state[12] + 0.9 * mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_1_0(double mag, double *state)\n{\n  state[13] = state[13] + mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_1_0v(double mag, double *state)\n{\n  state[13] = state[13] + mag;\n  state[15] = state[15] - 0.875 * mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_1_1(double mag, double *state)\n{\n  state[14] = state[14] + mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_1_1v(double mag, double *state)\n{\n  state[14] = state[14] + mag;\n  state[16] = state[16] - 0.875 * mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_2_0(double mag, double *state)\n{\n  state[17] = state[17] + mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_2_0v(double mag, double *state)\n{\n  state[17] = state[17] + mag;\n  state[24] = state[24] - 0.875 * mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_2_1(double mag, double *state)\n{\n  state[18] = state[18] + mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_2_1v(double mag, double *state)\n{\n  state[18] = state[18] + mag;\n  state[25] = state[25] - 0.875 * mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_2_2(double mag, double *state)\n{\n  state[19] = state[19] + mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_2_2v(double mag, double *state)\n{\n  state[19] = state[19] + mag;\n  state[26] = state[26] - 0.875 * mag;\n}\n\nstatic void perturbAsmJointPrimitiveState_2_3(double mag, double *state)\n{\n  double xx[15];\n  xx[0] = 1.0;\n  xx[1] = fabs(mag);\n  xx[2] = xx[0] / (xx[1] - floor(xx[1]) + 1.0e-9);\n  xx[1] = sin(xx[2]);\n  xx[3] = 0.0;\n  xx[4] = cos(xx[2]);\n  xx[5] = sin(2.0 * xx[2]);\n  xx[2] = 0.5 * mag;\n  xx[6] = sqrt(xx[1] * xx[1] + xx[4] * xx[4] + xx[5] * xx[5]);\n  xx[7] = xx[6] == 0.0 ? 0.0 : xx[1] / xx[6];\n  xx[8] = sin(xx[2]);\n  xx[9] = xx[6] == 0.0 ? 0.0 : xx[4] / xx[6];\n  xx[10] = xx[6] == 0.0 ? 0.0 : xx[5] / xx[6];\n  xx[11] = xx[1] == xx[3] && xx[4] == xx[3] && xx[5] == xx[3] ? xx[0] : cos(xx[2]);\n  xx[12] = xx[7] * xx[8];\n  xx[13] = xx[9] * xx[8];\n  xx[14] = xx[10] * xx[8];\n  xx[0] = state[20];\n  xx[1] = state[21];\n  xx[2] = state[22];\n  xx[3] = state[23];\n  pm_math_Quaternion_compose_ra(xx + 11, xx + 0, xx + 4);\n  state[20] = xx[4];\n  state[21] = xx[5];\n  state[22] = xx[6];\n  state[23] = xx[7];\n}\n\nstatic void perturbAsmJointPrimitiveState_2_3v(double mag, double *state)\n{\n  double xx[15];\n  xx[0] = 1.0;\n  xx[1] = fabs(mag);\n  xx[2] = xx[0] / (xx[1] - floor(xx[1]) + 1.0e-9);\n  xx[1] = sin(xx[2]);\n  xx[3] = 0.0;\n  xx[4] = cos(xx[2]);\n  xx[5] = sin(2.0 * xx[2]);\n  xx[2] = 0.5 * mag;\n  xx[6] = sqrt(xx[1] * xx[1] + xx[4] * xx[4] + xx[5] * xx[5]);\n  xx[7] = xx[6] == 0.0 ? 0.0 : xx[1] / xx[6];\n  xx[8] = sin(xx[2]);\n  xx[9] = xx[6] == 0.0 ? 0.0 : xx[4] / xx[6];\n  xx[10] = xx[6] == 0.0 ? 0.0 : xx[5] / xx[6];\n  xx[11] = xx[1] == xx[3] && xx[4] == xx[3] && xx[5] == xx[3] ? xx[0] : cos(xx[2]);\n  xx[12] = xx[7] * xx[8];\n  xx[13] = xx[9] * xx[8];\n  xx[14] = xx[10] * xx[8];\n  xx[3] = state[20];\n  xx[4] = state[21];\n  xx[5] = state[22];\n  xx[6] = state[23];\n  pm_math_Quaternion_compose_ra(xx + 11, xx + 3, xx + 7);\n  state[20] = xx[7];\n  state[21] = xx[8];\n  state[22] = xx[9];\n  state[23] = xx[10];\n  state[27] = state[27] + 1.2 * mag;\n  state[28] = state[28] - xx[2];\n  state[29] = state[29] + 0.9 * mag;\n}\n\nvoid simulation_b048d748_1_perturbAsmJointPrimitiveState(const void *mech,\n  size_t stageIdx, size_t primIdx, double mag, boolean_T doPerturbVelocity,\n  double *state)\n{\n  (void) mech;\n  (void) stageIdx;\n  (void) primIdx;\n  (void) mag;\n  (void) doPerturbVelocity;\n  (void) state;\n  switch ((stageIdx * 6 + primIdx) * 2 + (doPerturbVelocity ? 1 : 0))\n  {\n   case 0:\n    perturbAsmJointPrimitiveState_0_0(mag, state);\n    break;\n\n   case 1:\n    perturbAsmJointPrimitiveState_0_0v(mag, state);\n    break;\n\n   case 2:\n    perturbAsmJointPrimitiveState_0_1(mag, state);\n    break;\n\n   case 3:\n    perturbAsmJointPrimitiveState_0_1v(mag, state);\n    break;\n\n   case 4:\n    perturbAsmJointPrimitiveState_0_2(mag, state);\n    break;\n\n   case 5:\n    perturbAsmJointPrimitiveState_0_2v(mag, state);\n    break;\n\n   case 6:\n    perturbAsmJointPrimitiveState_0_3(mag, state);\n    break;\n\n   case 7:\n    perturbAsmJointPrimitiveState_0_3v(mag, state);\n    break;\n\n   case 12:\n    perturbAsmJointPrimitiveState_1_0(mag, state);\n    break;\n\n   case 13:\n    perturbAsmJointPrimitiveState_1_0v(mag, state);\n    break;\n\n   case 14:\n    perturbAsmJointPrimitiveState_1_1(mag, state);\n    break;\n\n   case 15:\n    perturbAsmJointPrimitiveState_1_1v(mag, state);\n    break;\n\n   case 24:\n    perturbAsmJointPrimitiveState_2_0(mag, state);\n    break;\n\n   case 25:\n    perturbAsmJointPrimitiveState_2_0v(mag, state);\n    break;\n\n   case 26:\n    perturbAsmJointPrimitiveState_2_1(mag, state);\n    break;\n\n   case 27:\n    perturbAsmJointPrimitiveState_2_1v(mag, state);\n    break;\n\n   case 28:\n    perturbAsmJointPrimitiveState_2_2(mag, state);\n    break;\n\n   case 29:\n    perturbAsmJointPrimitiveState_2_2v(mag, state);\n    break;\n\n   case 30:\n    perturbAsmJointPrimitiveState_2_3(mag, state);\n    break;\n\n   case 31:\n    perturbAsmJointPrimitiveState_2_3v(mag, state);\n    break;\n  }\n}\n\nstatic void computePosDofBlendMatrix_0_3(const double *state, int partialType,\n  double *matrix)\n{\n  double xx[20];\n  xx[0] = 9.87654321;\n  xx[1] = 2.0;\n  xx[2] = xx[1] * (state[4] * state[5] - state[3] * state[6]);\n  xx[3] = xx[2] * xx[2];\n  xx[4] = 1.0;\n  xx[5] = xx[1] * (state[3] * state[3] + state[4] * state[4]) - xx[4];\n  xx[6] = xx[5] * xx[5];\n  xx[7] = sqrt(xx[3] + xx[6]);\n  xx[8] = xx[7] == 0.0 ? 0.0 : - xx[2] / xx[7];\n  xx[9] = xx[6] + xx[3];\n  xx[3] = sqrt(xx[9]);\n  xx[6] = xx[3] == 0.0 ? 0.0 : xx[5] / xx[3];\n  xx[10] = 0.0;\n  xx[11] = xx[1] * (state[4] * state[6] + state[3] * state[5]);\n  xx[1] = sqrt(xx[9] + xx[11] * xx[11]);\n  xx[12] = xx[1] == 0.0 ? 0.0 : xx[5] / xx[1];\n  xx[14] = xx[8];\n  xx[15] = xx[6];\n  xx[16] = xx[10];\n  xx[17] = xx[8];\n  xx[18] = xx[8];\n  xx[19] = xx[12];\n  xx[6] = xx[13 + (partialType)];\n  xx[8] = xx[7] == 0.0 ? 0.0 : xx[5] / xx[7];\n  xx[7] = xx[3] == 0.0 ? 0.0 : xx[2] / xx[3];\n  xx[3] = xx[1] == 0.0 ? 0.0 : xx[2] / xx[1];\n  xx[13] = xx[8];\n  xx[14] = xx[7];\n  xx[15] = xx[10];\n  xx[16] = xx[8];\n  xx[17] = xx[8];\n  xx[18] = xx[3];\n  xx[2] = xx[12 + (partialType)];\n  xx[3] = xx[1] == 0.0 ? 0.0 : xx[11] / xx[1];\n  xx[13] = xx[10];\n  xx[14] = xx[10];\n  xx[15] = xx[4];\n  xx[16] = xx[10];\n  xx[17] = xx[10];\n  xx[18] = xx[3];\n  xx[1] = xx[12 + (partialType)];\n  xx[3] = xx[11] * xx[5];\n  xx[5] = sqrt(xx[9] * xx[9] + xx[3] * xx[3]);\n  xx[7] = xx[5] == 0.0 ? 0.0 : xx[9] / xx[5];\n  xx[12] = xx[10];\n  xx[13] = xx[10];\n  xx[14] = xx[10];\n  xx[15] = xx[7];\n  xx[16] = xx[10];\n  xx[17] = xx[10];\n  xx[7] = xx[11 + (partialType)];\n  xx[12] = xx[10];\n  xx[13] = xx[10];\n  xx[14] = xx[10];\n  xx[15] = xx[10];\n  xx[16] = xx[10];\n  xx[17] = xx[10];\n  xx[8] = xx[11 + (partialType)];\n  xx[9] = xx[5] == 0.0 ? 0.0 : xx[3] / xx[5];\n  xx[12] = xx[4];\n  xx[13] = xx[4];\n  xx[14] = xx[10];\n  xx[15] = xx[9];\n  xx[16] = xx[10];\n  xx[17] = xx[10];\n  xx[0] = xx[11 + (partialType)];\n  matrix[0] = xx[6];\n  matrix[1] = xx[2];\n  matrix[2] = xx[1];\n  matrix[3] = xx[7];\n  matrix[4] = xx[8];\n  matrix[5] = xx[0];\n  matrix[6] = xx[8];\n  matrix[7] = xx[8];\n  matrix[8] = xx[8];\n}\n\nstatic void computePosDofBlendMatrix_2_3(const double *state, int partialType,\n  double *matrix)\n{\n  double xx[20];\n  xx[0] = 9.87654321;\n  xx[1] = 2.0;\n  xx[2] = xx[1] * (state[21] * state[22] - state[20] * state[23]);\n  xx[3] = xx[2] * xx[2];\n  xx[4] = 1.0;\n  xx[5] = xx[1] * (state[20] * state[20] + state[21] * state[21]) - xx[4];\n  xx[6] = xx[5] * xx[5];\n  xx[7] = sqrt(xx[3] + xx[6]);\n  xx[8] = xx[7] == 0.0 ? 0.0 : - xx[2] / xx[7];\n  xx[9] = xx[6] + xx[3];\n  xx[3] = sqrt(xx[9]);\n  xx[6] = xx[3] == 0.0 ? 0.0 : xx[5] / xx[3];\n  xx[10] = 0.0;\n  xx[11] = xx[1] * (state[21] * state[23] + state[20] * state[22]);\n  xx[1] = sqrt(xx[9] + xx[11] * xx[11]);\n  xx[12] = xx[1] == 0.0 ? 0.0 : xx[5] / xx[1];\n  xx[14] = xx[8];\n  xx[15] = xx[6];\n  xx[16] = xx[10];\n  xx[17] = xx[8];\n  xx[18] = xx[8];\n  xx[19] = xx[12];\n  xx[6] = xx[13 + (partialType)];\n  xx[8] = xx[7] == 0.0 ? 0.0 : xx[5] / xx[7];\n  xx[7] = xx[3] == 0.0 ? 0.0 : xx[2] / xx[3];\n  xx[3] = xx[1] == 0.0 ? 0.0 : xx[2] / xx[1];\n  xx[13] = xx[8];\n  xx[14] = xx[7];\n  xx[15] = xx[10];\n  xx[16] = xx[8];\n  xx[17] = xx[8];\n  xx[18] = xx[3];\n  xx[2] = xx[12 + (partialType)];\n  xx[3] = xx[1] == 0.0 ? 0.0 : xx[11] / xx[1];\n  xx[13] = xx[10];\n  xx[14] = xx[10];\n  xx[15] = xx[4];\n  xx[16] = xx[10];\n  xx[17] = xx[10];\n  xx[18] = xx[3];\n  xx[1] = xx[12 + (partialType)];\n  xx[3] = xx[11] * xx[5];\n  xx[5] = sqrt(xx[9] * xx[9] + xx[3] * xx[3]);\n  xx[7] = xx[5] == 0.0 ? 0.0 : xx[9] / xx[5];\n  xx[12] = xx[10];\n  xx[13] = xx[10];\n  xx[14] = xx[10];\n  xx[15] = xx[7];\n  xx[16] = xx[10];\n  xx[17] = xx[10];\n  xx[7] = xx[11 + (partialType)];\n  xx[12] = xx[10];\n  xx[13] = xx[10];\n  xx[14] = xx[10];\n  xx[15] = xx[10];\n  xx[16] = xx[10];\n  xx[17] = xx[10];\n  xx[8] = xx[11 + (partialType)];\n  xx[9] = xx[5] == 0.0 ? 0.0 : xx[3] / xx[5];\n  xx[12] = xx[4];\n  xx[13] = xx[4];\n  xx[14] = xx[10];\n  xx[15] = xx[9];\n  xx[16] = xx[10];\n  xx[17] = xx[10];\n  xx[0] = xx[11 + (partialType)];\n  matrix[0] = xx[6];\n  matrix[1] = xx[2];\n  matrix[2] = xx[1];\n  matrix[3] = xx[7];\n  matrix[4] = xx[8];\n  matrix[5] = xx[0];\n  matrix[6] = xx[8];\n  matrix[7] = xx[8];\n  matrix[8] = xx[8];\n}\n\nvoid simulation_b048d748_1_computePosDofBlendMatrix(const void *mech, size_t\n  stageIdx, size_t primIdx, const double *state, int partialType, double *matrix)\n{\n  (void) mech;\n  (void) stageIdx;\n  (void) primIdx;\n  (void) state;\n  (void) partialType;\n  (void) matrix;\n  switch ((stageIdx * 6 + primIdx))\n  {\n   case 3:\n    computePosDofBlendMatrix_0_3(state, partialType, matrix);\n    break;\n\n   case 15:\n    computePosDofBlendMatrix_2_3(state, partialType, matrix);\n    break;\n  }\n}\n\nstatic void computeVelDofBlendMatrix_0_3(const double *state, int partialType,\n  double *matrix)\n{\n  double xx[15];\n  (void) state;\n  xx[0] = 9.87654321;\n  xx[1] = 0.0;\n  xx[2] = 1.0;\n  xx[4] = xx[1];\n  xx[5] = xx[2];\n  xx[6] = xx[1];\n  xx[7] = xx[2];\n  xx[8] = xx[1];\n  xx[9] = xx[2];\n  xx[10] = xx[3 + (partialType)];\n  xx[4] = xx[2];\n  xx[5] = xx[1];\n  xx[6] = xx[1];\n  xx[7] = xx[1];\n  xx[8] = xx[2];\n  xx[9] = xx[1];\n  xx[11] = xx[3 + (partialType)];\n  xx[4] = xx[1];\n  xx[5] = xx[1];\n  xx[6] = xx[2];\n  xx[7] = xx[1];\n  xx[8] = xx[1];\n  xx[9] = xx[1];\n  xx[12] = xx[3 + (partialType)];\n  xx[4] = xx[1];\n  xx[5] = xx[1];\n  xx[6] = xx[1];\n  xx[7] = xx[1];\n  xx[8] = xx[1];\n  xx[9] = xx[1];\n  xx[13] = xx[3 + (partialType)];\n  xx[4] = xx[1];\n  xx[5] = xx[1];\n  xx[6] = xx[1];\n  xx[7] = xx[2];\n  xx[8] = xx[1];\n  xx[9] = xx[1];\n  xx[14] = xx[3 + (partialType)];\n  xx[4] = xx[2];\n  xx[5] = xx[2];\n  xx[6] = xx[1];\n  xx[7] = xx[1];\n  xx[8] = xx[1];\n  xx[9] = xx[1];\n  xx[0] = xx[3 + (partialType)];\n  matrix[0] = xx[10];\n  matrix[1] = xx[11];\n  matrix[2] = xx[12];\n  matrix[3] = xx[13];\n  matrix[4] = xx[14];\n  matrix[5] = xx[0];\n  matrix[6] = xx[13];\n  matrix[7] = xx[13];\n  matrix[8] = xx[13];\n}\n\nstatic void computeVelDofBlendMatrix_2_3(const double *state, int partialType,\n  double *matrix)\n{\n  double xx[15];\n  (void) state;\n  xx[0] = 9.87654321;\n  xx[1] = 0.0;\n  xx[2] = 1.0;\n  xx[4] = xx[1];\n  xx[5] = xx[2];\n  xx[6] = xx[1];\n  xx[7] = xx[2];\n  xx[8] = xx[1];\n  xx[9] = xx[2];\n  xx[10] = xx[3 + (partialType)];\n  xx[4] = xx[2];\n  xx[5] = xx[1];\n  xx[6] = xx[1];\n  xx[7] = xx[1];\n  xx[8] = xx[2];\n  xx[9] = xx[1];\n  xx[11] = xx[3 + (partialType)];\n  xx[4] = xx[1];\n  xx[5] = xx[1];\n  xx[6] = xx[2];\n  xx[7] = xx[1];\n  xx[8] = xx[1];\n  xx[9] = xx[1];\n  xx[12] = xx[3 + (partialType)];\n  xx[4] = xx[1];\n  xx[5] = xx[1];\n  xx[6] = xx[1];\n  xx[7] = xx[1];\n  xx[8] = xx[1];\n  xx[9] = xx[1];\n  xx[13] = xx[3 + (partialType)];\n  xx[4] = xx[1];\n  xx[5] = xx[1];\n  xx[6] = xx[1];\n  xx[7] = xx[2];\n  xx[8] = xx[1];\n  xx[9] = xx[1];\n  xx[14] = xx[3 + (partialType)];\n  xx[4] = xx[2];\n  xx[5] = xx[2];\n  xx[6] = xx[1];\n  xx[7] = xx[1];\n  xx[8] = xx[1];\n  xx[9] = xx[1];\n  xx[0] = xx[3 + (partialType)];\n  matrix[0] = xx[10];\n  matrix[1] = xx[11];\n  matrix[2] = xx[12];\n  matrix[3] = xx[13];\n  matrix[4] = xx[14];\n  matrix[5] = xx[0];\n  matrix[6] = xx[13];\n  matrix[7] = xx[13];\n  matrix[8] = xx[13];\n}\n\nvoid simulation_b048d748_1_computeVelDofBlendMatrix(const void *mech, size_t\n  stageIdx, size_t primIdx, const double *state, int partialType, double *matrix)\n{\n  (void) mech;\n  (void) stageIdx;\n  (void) primIdx;\n  (void) state;\n  (void) partialType;\n  (void) matrix;\n  switch ((stageIdx * 6 + primIdx))\n  {\n   case 3:\n    computeVelDofBlendMatrix_0_3(state, partialType, matrix);\n    break;\n\n   case 15:\n    computeVelDofBlendMatrix_2_3(state, partialType, matrix);\n    break;\n  }\n}\n\nstatic void projectPartiallyTargetedPos_0_3(const double *origState, int\n  partialType, double *state)\n{\n  boolean_T bb[2];\n  double xx[17];\n  xx[0] = 2.0;\n  xx[1] = xx[0] * (state[4] * state[6] + state[3] * state[5]);\n  xx[2] = 0.99999999999999;\n  bb[0] = fabs(xx[1]) > xx[2];\n  xx[3] = 1.570796326794897;\n  if (xx[1] < 0.0)\n    xx[4] = -1.0;\n  else if (xx[1] > 0.0)\n    xx[4] = +1.0;\n  else\n    xx[4] = 0.0;\n  xx[5] = fabs(xx[1]) > 1.0 ? atan2(xx[1], 0.0) : asin(xx[1]);\n  xx[1] = bb[0] ? xx[3] * xx[4] : xx[5];\n  xx[5] = xx[0] * (origState[4] * origState[6] + origState[3] * origState[5]);\n  bb[1] = fabs(xx[5]) > xx[2];\n  if (xx[5] < 0.0)\n    xx[2] = -1.0;\n  else if (xx[5] > 0.0)\n    xx[2] = +1.0;\n  else\n    xx[2] = 0.0;\n  xx[6] = fabs(xx[5]) > 1.0 ? atan2(xx[5], 0.0) : asin(xx[5]);\n  xx[5] = bb[1] ? xx[3] * xx[2] : xx[6];\n  xx[6] = xx[1];\n  xx[7] = xx[1];\n  xx[8] = xx[5];\n  xx[9] = xx[5];\n  xx[10] = xx[1];\n  xx[11] = xx[1];\n  xx[12] = xx[5];\n  xx[1] = xx[6 + (partialType)];\n  xx[3] = cos(xx[1]);\n  xx[5] = 0.5;\n  xx[6] = state[5] * state[6];\n  xx[7] = state[3] * state[4];\n  xx[8] = state[3] * state[3];\n  xx[9] = 1.0;\n  xx[10] = xx[0] * (xx[8] + state[5] * state[5]) - xx[9];\n  xx[11] = xx[0] * (xx[6] + xx[7]);\n  xx[10] = (xx[11] == 0.0 && xx[10] == 0.0) ? 0.0 : atan2(xx[11], xx[10]);\n  xx[11] = xx[0] * (xx[8] + state[6] * state[6]) - xx[9];\n  xx[12] = - (xx[0] * (xx[6] - xx[7]));\n  xx[11] = (xx[12] == 0.0 && xx[11] == 0.0) ? 0.0 : atan2(xx[12], xx[11]);\n  xx[6] = bb[0] ? xx[5] * xx[10] : xx[11];\n  xx[7] = xx[0] * (xx[8] + state[4] * state[4]) - xx[9];\n  xx[10] = - (xx[0] * (state[4] * state[5] - state[3] * state[6]));\n  xx[7] = (xx[10] == 0.0 && xx[7] == 0.0) ? 0.0 : atan2(xx[10], xx[7]);\n  xx[8] = bb[0] ? xx[4] * xx[6] : xx[7];\n  xx[4] = origState[5] * origState[6];\n  xx[7] = origState[3] * origState[4];\n  xx[10] = origState[3] * origState[3];\n  xx[11] = xx[0] * (xx[10] + origState[5] * origState[5]) - xx[9];\n  xx[12] = xx[0] * (xx[4] + xx[7]);\n  xx[11] = (xx[12] == 0.0 && xx[11] == 0.0) ? 0.0 : atan2(xx[12], xx[11]);\n  xx[12] = xx[0] * (xx[10] + origState[6] * origState[6]) - xx[9];\n  xx[13] = - (xx[0] * (xx[4] - xx[7]));\n  xx[12] = (xx[13] == 0.0 && xx[12] == 0.0) ? 0.0 : atan2(xx[13], xx[12]);\n  xx[4] = bb[1] ? xx[5] * xx[11] : xx[12];\n  xx[5] = xx[0] * (xx[10] + origState[4] * origState[4]) - xx[9];\n  xx[7] = - (xx[0] * (origState[4] * origState[5] - origState[3] * origState[6]));\n  xx[5] = (xx[7] == 0.0 && xx[5] == 0.0) ? 0.0 : atan2(xx[7], xx[5]);\n  xx[0] = bb[1] ? xx[2] * xx[4] : xx[5];\n  xx[9] = xx[8];\n  xx[10] = xx[8];\n  xx[11] = xx[8];\n  xx[12] = xx[8];\n  xx[13] = xx[0];\n  xx[14] = xx[0];\n  xx[15] = xx[0];\n  xx[0] = xx[9 + (partialType)];\n  xx[2] = cos(xx[0]);\n  xx[5] = sin(xx[0]);\n  xx[0] = sin(xx[1]);\n  xx[7] = xx[6];\n  xx[8] = xx[4];\n  xx[9] = xx[6];\n  xx[10] = xx[4];\n  xx[11] = xx[6];\n  xx[12] = xx[4];\n  xx[13] = xx[6];\n  xx[1] = xx[7 + (partialType)];\n  xx[4] = cos(xx[1]);\n  xx[6] = sin(xx[1]);\n  xx[1] = xx[2] * xx[6];\n  xx[7] = xx[4] * xx[2];\n  xx[8] = xx[3] * xx[2];\n  xx[9] = - (xx[3] * xx[5]);\n  xx[10] = xx[0];\n  xx[11] = xx[4] * xx[5] + xx[1] * xx[0];\n  xx[12] = xx[7] - xx[6] * xx[0] * xx[5];\n  xx[13] = - (xx[3] * xx[6]);\n  xx[14] = xx[6] * xx[5] - xx[7] * xx[0];\n  xx[15] = xx[1] + xx[4] * xx[0] * xx[5];\n  xx[16] = xx[4] * xx[3];\n  pm_math_Quaternion_Matrix3x3Ctor_ra(xx + 8, xx + 0);\n  state[3] = xx[0];\n  state[4] = xx[1];\n  state[5] = xx[2];\n  state[6] = xx[3];\n}\n\nstatic void projectPartiallyTargetedPos_2_3(const double *origState, int\n  partialType, double *state)\n{\n  boolean_T bb[2];\n  double xx[17];\n  xx[0] = 2.0;\n  xx[1] = xx[0] * (state[21] * state[23] + state[20] * state[22]);\n  xx[2] = 0.99999999999999;\n  bb[0] = fabs(xx[1]) > xx[2];\n  xx[3] = 1.570796326794897;\n  if (xx[1] < 0.0)\n    xx[4] = -1.0;\n  else if (xx[1] > 0.0)\n    xx[4] = +1.0;\n  else\n    xx[4] = 0.0;\n  xx[5] = fabs(xx[1]) > 1.0 ? atan2(xx[1], 0.0) : asin(xx[1]);\n  xx[1] = bb[0] ? xx[3] * xx[4] : xx[5];\n  xx[5] = xx[0] * (origState[21] * origState[23] + origState[20] * origState[22]);\n  bb[1] = fabs(xx[5]) > xx[2];\n  if (xx[5] < 0.0)\n    xx[2] = -1.0;\n  else if (xx[5] > 0.0)\n    xx[2] = +1.0;\n  else\n    xx[2] = 0.0;\n  xx[6] = fabs(xx[5]) > 1.0 ? atan2(xx[5], 0.0) : asin(xx[5]);\n  xx[5] = bb[1] ? xx[3] * xx[2] : xx[6];\n  xx[6] = xx[1];\n  xx[7] = xx[1];\n  xx[8] = xx[5];\n  xx[9] = xx[5];\n  xx[10] = xx[1];\n  xx[11] = xx[1];\n  xx[12] = xx[5];\n  xx[1] = xx[6 + (partialType)];\n  xx[3] = cos(xx[1]);\n  xx[5] = 0.5;\n  xx[6] = state[22] * state[23];\n  xx[7] = state[20] * state[21];\n  xx[8] = state[20] * state[20];\n  xx[9] = 1.0;\n  xx[10] = xx[0] * (xx[8] + state[22] * state[22]) - xx[9];\n  xx[11] = xx[0] * (xx[6] + xx[7]);\n  xx[10] = (xx[11] == 0.0 && xx[10] == 0.0) ? 0.0 : atan2(xx[11], xx[10]);\n  xx[11] = xx[0] * (xx[8] + state[23] * state[23]) - xx[9];\n  xx[12] = - (xx[0] * (xx[6] - xx[7]));\n  xx[11] = (xx[12] == 0.0 && xx[11] == 0.0) ? 0.0 : atan2(xx[12], xx[11]);\n  xx[6] = bb[0] ? xx[5] * xx[10] : xx[11];\n  xx[7] = xx[0] * (xx[8] + state[21] * state[21]) - xx[9];\n  xx[10] = - (xx[0] * (state[21] * state[22] - state[20] * state[23]));\n  xx[7] = (xx[10] == 0.0 && xx[7] == 0.0) ? 0.0 : atan2(xx[10], xx[7]);\n  xx[8] = bb[0] ? xx[4] * xx[6] : xx[7];\n  xx[4] = origState[22] * origState[23];\n  xx[7] = origState[20] * origState[21];\n  xx[10] = origState[20] * origState[20];\n  xx[11] = xx[0] * (xx[10] + origState[22] * origState[22]) - xx[9];\n  xx[12] = xx[0] * (xx[4] + xx[7]);\n  xx[11] = (xx[12] == 0.0 && xx[11] == 0.0) ? 0.0 : atan2(xx[12], xx[11]);\n  xx[12] = xx[0] * (xx[10] + origState[23] * origState[23]) - xx[9];\n  xx[13] = - (xx[0] * (xx[4] - xx[7]));\n  xx[12] = (xx[13] == 0.0 && xx[12] == 0.0) ? 0.0 : atan2(xx[13], xx[12]);\n  xx[4] = bb[1] ? xx[5] * xx[11] : xx[12];\n  xx[5] = xx[0] * (xx[10] + origState[21] * origState[21]) - xx[9];\n  xx[7] = - (xx[0] * (origState[21] * origState[22] - origState[20] * origState\n                      [23]));\n  xx[5] = (xx[7] == 0.0 && xx[5] == 0.0) ? 0.0 : atan2(xx[7], xx[5]);\n  xx[0] = bb[1] ? xx[2] * xx[4] : xx[5];\n  xx[9] = xx[8];\n  xx[10] = xx[8];\n  xx[11] = xx[8];\n  xx[12] = xx[8];\n  xx[13] = xx[0];\n  xx[14] = xx[0];\n  xx[15] = xx[0];\n  xx[0] = xx[9 + (partialType)];\n  xx[2] = cos(xx[0]);\n  xx[5] = sin(xx[0]);\n  xx[0] = sin(xx[1]);\n  xx[7] = xx[6];\n  xx[8] = xx[4];\n  xx[9] = xx[6];\n  xx[10] = xx[4];\n  xx[11] = xx[6];\n  xx[12] = xx[4];\n  xx[13] = xx[6];\n  xx[1] = xx[7 + (partialType)];\n  xx[4] = cos(xx[1]);\n  xx[6] = sin(xx[1]);\n  xx[1] = xx[2] * xx[6];\n  xx[7] = xx[4] * xx[2];\n  xx[8] = xx[3] * xx[2];\n  xx[9] = - (xx[3] * xx[5]);\n  xx[10] = xx[0];\n  xx[11] = xx[4] * xx[5] + xx[1] * xx[0];\n  xx[12] = xx[7] - xx[6] * xx[0] * xx[5];\n  xx[13] = - (xx[3] * xx[6]);\n  xx[14] = xx[6] * xx[5] - xx[7] * xx[0];\n  xx[15] = xx[1] + xx[4] * xx[0] * xx[5];\n  xx[16] = xx[4] * xx[3];\n  pm_math_Quaternion_Matrix3x3Ctor_ra(xx + 8, xx + 0);\n  state[20] = xx[0];\n  state[21] = xx[1];\n  state[22] = xx[2];\n  state[23] = xx[3];\n}\n\nvoid simulation_b048d748_1_projectPartiallyTargetedPos(const void *mech, size_t\n  stageIdx, size_t primIdx, const double *origState, int partialType, double\n  *state)\n{\n  (void) mech;\n  (void) stageIdx;\n  (void) primIdx;\n  (void) origState;\n  (void) partialType;\n  (void) state;\n  switch ((stageIdx * 6 + primIdx))\n  {\n   case 3:\n    projectPartiallyTargetedPos_0_3(origState, partialType, state);\n    break;\n\n   case 15:\n    projectPartiallyTargetedPos_2_3(origState, partialType, state);\n    break;\n  }\n}\n\nvoid simulation_b048d748_1_propagateMotion(const void *mech, const\n  RuntimeDerivedValuesBundle *rtdv, const double *state, double *motionData)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  double xx[50];\n  (void) mech;\n  (void) rtdvd;\n  (void) rtdvi;\n  xx[0] = - state[3];\n  xx[1] = - state[4];\n  xx[2] = - state[5];\n  xx[3] = - state[6];\n  xx[4] = 2.0;\n  xx[5] = state[0] + xx[4] * (state[3] * state[5] + state[4] * state[6]);\n  xx[6] = state[1] - xx[4] * (state[3] * state[4] - state[5] * state[6]);\n  xx[7] = 1.0;\n  xx[8] = state[2] - (xx[4] * (state[4] * state[4] + state[5] * state[5]) - xx[7]);\n  xx[9] = 0.5;\n  xx[10] = xx[9] * state[13];\n  xx[11] = cos(xx[10]);\n  xx[12] = xx[9] * state[14];\n  xx[9] = cos(xx[12]);\n  xx[13] = xx[11] * xx[9];\n  xx[14] = - xx[13];\n  xx[15] = sin(xx[10]);\n  xx[10] = xx[9] * xx[15];\n  xx[16] = - xx[10];\n  xx[17] = sin(xx[12]);\n  xx[12] = xx[11] * xx[17];\n  xx[11] = - xx[12];\n  xx[18] = xx[15] * xx[17];\n  xx[15] = - xx[18];\n  xx[19] = 0.04499999999999999;\n  xx[20] = xx[19] * xx[12];\n  xx[21] = xx[19] * xx[10];\n  xx[22] = - (xx[4] * (xx[20] * xx[13] + xx[21] * xx[18]));\n  xx[23] = xx[4] * (xx[21] * xx[13] - xx[20] * xx[18]);\n  xx[13] = xx[4] * (xx[21] * xx[10] + xx[20] * xx[12]) - xx[19] - xx[7];\n  xx[10] = - state[20];\n  xx[12] = - state[21];\n  xx[18] = - state[22];\n  xx[20] = - state[23];\n  xx[24] = xx[14];\n  xx[25] = xx[16];\n  xx[26] = xx[11];\n  xx[27] = xx[15];\n  pm_math_Quaternion_compose_ra(xx + 0, xx + 24, xx + 28);\n  xx[32] = xx[22];\n  xx[33] = xx[23];\n  xx[34] = xx[13];\n  pm_math_Quaternion_xform_ra(xx + 0, xx + 32, xx + 35);\n  xx[38] = state[7];\n  xx[39] = state[8];\n  xx[40] = state[9];\n  pm_math_Quaternion_inverseXform_ra(xx + 0, xx + 38, xx + 41);\n  xx[21] = xx[41] + state[11];\n  xx[38] = xx[42] - state[10];\n  xx[39] = state[10];\n  xx[40] = state[11];\n  xx[41] = state[12];\n  pm_math_Quaternion_inverseXform_ra(xx + 24, xx + 39, xx + 44);\n  xx[42] = (xx[7] - xx[4] * xx[17] * xx[17]) * state[15];\n  pm_math_Vector3_cross_ra(xx + 39, xx + 32, xx + 47);\n  xx[32] = xx[47] + xx[21];\n  xx[33] = xx[48] + xx[38];\n  xx[34] = xx[49] + xx[43];\n  pm_math_Quaternion_inverseXform_ra(xx + 24, xx + 32, xx + 39);\n  xx[24] = xx[10];\n  xx[25] = xx[12];\n  xx[26] = xx[18];\n  xx[27] = xx[20];\n  xx[32] = state[24];\n  xx[33] = state[25];\n  xx[34] = state[26];\n  pm_math_Quaternion_inverseXform_ra(xx + 24, xx + 32, xx + 47);\n  motionData[0] = xx[0];\n  motionData[1] = xx[1];\n  motionData[2] = xx[2];\n  motionData[3] = xx[3];\n  motionData[4] = xx[5];\n  motionData[5] = xx[6];\n  motionData[6] = xx[8];\n  motionData[7] = xx[14];\n  motionData[8] = xx[16];\n  motionData[9] = xx[11];\n  motionData[10] = xx[15];\n  motionData[11] = xx[22];\n  motionData[12] = xx[23];\n  motionData[13] = xx[13];\n  motionData[14] = xx[10];\n  motionData[15] = xx[12];\n  motionData[16] = xx[18];\n  motionData[17] = xx[20];\n  motionData[18] = state[17];\n  motionData[19] = state[18];\n  motionData[20] = state[19];\n  motionData[21] = xx[28];\n  motionData[22] = xx[29];\n  motionData[23] = xx[30];\n  motionData[24] = xx[31];\n  motionData[25] = xx[35] + xx[5];\n  motionData[26] = xx[36] + xx[6];\n  motionData[27] = xx[37] + xx[8];\n  motionData[28] = state[10];\n  motionData[29] = state[11];\n  motionData[30] = state[12];\n  motionData[31] = xx[21];\n  motionData[32] = xx[38];\n  motionData[33] = xx[43];\n  motionData[34] = xx[44] + xx[42];\n  motionData[35] = xx[45] + state[16];\n  motionData[36] = xx[46] + xx[4] * xx[9] * xx[17] * state[15];\n  motionData[37] = xx[39] - xx[19] * state[16];\n  motionData[38] = xx[40] + xx[19] * xx[42];\n  motionData[39] = xx[41];\n  motionData[40] = state[27];\n  motionData[41] = state[28];\n  motionData[42] = state[29];\n  motionData[43] = xx[47];\n  motionData[44] = xx[48];\n  motionData[45] = xx[49];\n}\n\nstatic size_t computeAssemblyError_0(const RuntimeDerivedValuesBundle *rtdv,\n  const int *modeVector, const double *motionData, double *error)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  int ii[1];\n  double xx[18];\n  (void) rtdvd;\n  (void) rtdvi;\n  ii[0] = modeVector[0] == -1 ? 0 : 1;\n  xx[0] = motionData[21];\n  xx[1] = motionData[22];\n  xx[2] = motionData[23];\n  xx[3] = motionData[24];\n  xx[4] = motionData[14];\n  xx[5] = motionData[15];\n  xx[6] = motionData[16];\n  xx[7] = motionData[17];\n  pm_math_Quaternion_inverseCompose_ra(xx + 0, xx + 4, xx + 8);\n  xx[0] = 2.0;\n  xx[1] = 0.0225;\n  xx[2] = xx[1] * motionData[16];\n  xx[3] = xx[1] * motionData[15];\n  xx[1] = 0.04500000000000001;\n  xx[4] = xx[1] * motionData[23];\n  xx[5] = xx[1] * motionData[22];\n  xx[12] = xx[9];\n  xx[13] = xx[10];\n  xx[14] = xx[11];\n  xx[15] = xx[0] * (xx[2] * motionData[14] + xx[3] * motionData[17]) +\n    motionData[18] - (motionData[25] - xx[0] * (xx[4] * motionData[21] + xx[5] *\n    motionData[24]));\n  xx[16] = xx[0] * (xx[2] * motionData[17] - xx[3] * motionData[14]) +\n    motionData[19] - (xx[0] * (xx[5] * motionData[21] - xx[4] * motionData[24])\n                      + motionData[26]);\n  xx[17] = motionData[20] - xx[0] * (xx[3] * motionData[15] + xx[2] *\n    motionData[16]) - (motionData[27] + xx[0] * (xx[5] * motionData[22] + xx[4] *\n    motionData[23])) + 0.0675;\n  zeroMajor(1, 6, ii + 0, xx + 12);\n  error[0] = xx[12];\n  error[1] = xx[13];\n  error[2] = xx[14];\n  error[3] = xx[15];\n  error[4] = xx[16];\n  error[5] = xx[17];\n  return 6;\n}\n\nsize_t simulation_b048d748_1_computeAssemblyError(const void *mech, const\n  RuntimeDerivedValuesBundle *rtdv, size_t constraintIdx, const int *modeVector,\n  const double *motionData, double *error)\n{\n  (void) mech;\n  (void)rtdv;\n  (void) modeVector;\n  (void) motionData;\n  (void) error;\n  switch (constraintIdx)\n  {\n   case 0:\n    return computeAssemblyError_0(rtdv, modeVector, motionData, error);\n  }\n\n  return 0;\n}\n\nstatic size_t computeAssemblyJacobian_0(const RuntimeDerivedValuesBundle *rtdv,\n  const double *state, const int *modeVector, const double *motionData, double\n  *J)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  boolean_T bb[1];\n  double xx[114];\n  (void) rtdvd;\n  (void) rtdvi;\n  bb[0] = modeVector[0] == -1;\n  xx[0] = 0.0;\n  xx[1] = motionData[21];\n  xx[2] = motionData[22];\n  xx[3] = motionData[23];\n  xx[4] = motionData[24];\n  xx[5] = motionData[14];\n  xx[6] = motionData[15];\n  xx[7] = motionData[16];\n  xx[8] = motionData[17];\n  pm_math_Quaternion_inverseCompose_ra(xx + 1, xx + 5, xx + 9);\n  xx[13] = xx[0];\n  xx[14] = xx[0];\n  xx[15] = xx[0];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 13, xx + 16);\n  xx[13] = bb[0] ? xx[0] : xx[17];\n  xx[14] = 1.0;\n  xx[15] = 2.0;\n  xx[20] = motionData[9] * motionData[9];\n  xx[21] = motionData[10] * motionData[10];\n  xx[22] = xx[14] - xx[15] * (xx[20] + xx[21]);\n  xx[23] = motionData[8] * motionData[9];\n  xx[24] = motionData[7] * motionData[10];\n  xx[25] = xx[23] - xx[24];\n  xx[26] = motionData[7] * motionData[9];\n  xx[27] = motionData[8] * motionData[10];\n  xx[28] = xx[22];\n  xx[29] = xx[15] * xx[25];\n  xx[30] = xx[15] * (xx[26] + xx[27]);\n  pm_math_Quaternion_xform_ra(xx + 1, xx + 28, xx + 31);\n  pm_math_Quaternion_inverseXform_ra(xx + 5, xx + 31, xx + 28);\n  xx[31] = - xx[28];\n  xx[32] = - xx[29];\n  xx[33] = - xx[30];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 31, xx + 34);\n  xx[28] = xx[24] + xx[23];\n  xx[23] = motionData[8] * motionData[8];\n  xx[24] = xx[14] - xx[15] * (xx[21] + xx[23]);\n  xx[21] = motionData[9] * motionData[10];\n  xx[29] = motionData[7] * motionData[8];\n  xx[30] = xx[15] * xx[28];\n  xx[31] = xx[24];\n  xx[32] = xx[15] * (xx[21] - xx[29]);\n  pm_math_Quaternion_xform_ra(xx + 1, xx + 30, xx + 38);\n  pm_math_Quaternion_inverseXform_ra(xx + 5, xx + 38, xx + 30);\n  xx[38] = - xx[30];\n  xx[39] = - xx[31];\n  xx[40] = - xx[32];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 38, xx + 30);\n  xx[38] = xx[27] - xx[26];\n  xx[26] = xx[29] + xx[21];\n  xx[39] = xx[15] * xx[38];\n  xx[40] = xx[15] * xx[26];\n  xx[41] = xx[14] - xx[15] * (xx[23] + xx[20]);\n  pm_math_Quaternion_xform_ra(xx + 1, xx + 39, xx + 42);\n  pm_math_Quaternion_inverseXform_ra(xx + 5, xx + 42, xx + 39);\n  xx[42] = - xx[39];\n  xx[43] = - xx[40];\n  xx[44] = - xx[41];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 42, xx + 45);\n  xx[20] = 0.5;\n  xx[21] = xx[20] * state[13];\n  xx[23] = cos(xx[21]);\n  xx[27] = xx[20] * state[14];\n  xx[20] = sin(xx[27]);\n  xx[29] = xx[23] * xx[20];\n  xx[39] = sin(xx[21]);\n  xx[21] = xx[39] * xx[20];\n  xx[20] = xx[14] - xx[15] * (xx[29] * xx[29] + xx[21] * xx[21]);\n  xx[40] = cos(xx[27]);\n  xx[27] = xx[40] * xx[39];\n  xx[39] = xx[23] * xx[40];\n  xx[23] = xx[15] * (xx[29] * xx[27] - xx[39] * xx[21]);\n  xx[40] = xx[20];\n  xx[41] = xx[23];\n  xx[42] = xx[15] * (xx[39] * xx[29] + xx[27] * xx[21]);\n  pm_math_Quaternion_xform_ra(xx + 1, xx + 40, xx + 49);\n  pm_math_Quaternion_inverseXform_ra(xx + 5, xx + 49, xx + 1);\n  xx[40] = - xx[1];\n  xx[41] = - xx[2];\n  xx[42] = - xx[3];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 40, xx + 1);\n  xx[40] = xx[15] * (motionData[22] * motionData[23] - motionData[21] *\n                     motionData[24]);\n  xx[41] = xx[14] - xx[15] * (motionData[24] * motionData[24] + motionData[22] *\n    motionData[22]);\n  xx[42] = xx[15] * (motionData[21] * motionData[22] + motionData[23] *\n                     motionData[24]);\n  pm_math_Quaternion_inverseXform_ra(xx + 5, xx + 40, xx + 49);\n  xx[5] = - xx[49];\n  xx[6] = - xx[50];\n  xx[7] = - xx[51];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 5, xx + 40);\n  xx[5] = xx[14];\n  xx[6] = xx[0];\n  xx[7] = xx[0];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 5, xx + 49);\n  xx[5] = xx[0];\n  xx[6] = xx[14];\n  xx[7] = xx[0];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 5, xx + 53);\n  xx[5] = xx[0];\n  xx[6] = xx[0];\n  xx[7] = xx[14];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 5, xx + 57);\n  xx[5] = bb[0] ? xx[0] : xx[18];\n  xx[6] = bb[0] ? xx[0] : xx[19];\n  xx[1] = bb[0] ? xx[0] : - xx[14];\n  xx[7] = - state[4];\n  xx[8] = - state[5];\n  xx[9] = - state[6];\n  xx[16] = - state[3];\n  xx[17] = xx[7];\n  xx[18] = xx[8];\n  xx[19] = xx[9];\n  xx[61] = motionData[7];\n  xx[62] = motionData[8];\n  xx[63] = motionData[9];\n  xx[64] = motionData[10];\n  pm_math_Quaternion_compose_ra(xx + 16, xx + 61, xx + 65);\n  xx[10] = 0.04500000000000001;\n  xx[11] = xx[10] * xx[22];\n  xx[12] = xx[11] * xx[68];\n  xx[16] = 0.09000000000000001;\n  xx[17] = xx[16] * xx[25];\n  xx[18] = xx[17] * xx[68];\n  xx[19] = xx[11] * xx[66] + xx[17] * xx[67];\n  xx[61] = - xx[12];\n  xx[62] = - xx[18];\n  xx[63] = xx[19];\n  pm_math_Vector3_cross_ra(xx + 66, xx + 61, xx + 69);\n  xx[22] = motionData[12] * state[5];\n  xx[25] = motionData[13] * state[6];\n  xx[30] = xx[22] + xx[25];\n  xx[34] = motionData[12] * state[4];\n  xx[40] = motionData[13] * state[4];\n  xx[61] = - xx[30];\n  xx[62] = xx[34];\n  xx[63] = xx[40];\n  pm_math_Vector3_cross_ra(xx + 7, xx + 61, xx + 72);\n  xx[44] = state[3] * state[6];\n  xx[45] = state[4] * state[5];\n  xx[49] = xx[16] * xx[28];\n  xx[28] = xx[49] * xx[68];\n  xx[53] = xx[10] * xx[24];\n  xx[24] = xx[53] * xx[68];\n  xx[57] = xx[49] * xx[66] + xx[53] * xx[67];\n  xx[61] = - xx[28];\n  xx[62] = - xx[24];\n  xx[63] = xx[57];\n  pm_math_Vector3_cross_ra(xx + 66, xx + 61, xx + 75);\n  xx[61] = motionData[11] * state[5];\n  xx[62] = motionData[11] * state[4];\n  xx[63] = xx[25] + xx[62];\n  xx[25] = motionData[13] * state[5];\n  xx[78] = xx[61];\n  xx[79] = - xx[63];\n  xx[80] = xx[25];\n  pm_math_Vector3_cross_ra(xx + 7, xx + 78, xx + 81);\n  xx[64] = state[6] * state[6];\n  xx[78] = xx[16] * xx[38];\n  xx[38] = xx[78] * xx[68];\n  xx[79] = xx[16] * xx[26];\n  xx[16] = xx[79] * xx[68];\n  xx[26] = xx[78] * xx[66] + xx[79] * xx[67];\n  xx[84] = - xx[38];\n  xx[85] = - xx[16];\n  xx[86] = xx[26];\n  pm_math_Vector3_cross_ra(xx + 66, xx + 84, xx + 87);\n  xx[66] = motionData[11] * state[6];\n  xx[67] = motionData[12] * state[6];\n  xx[68] = xx[62] + xx[22];\n  xx[84] = xx[66];\n  xx[85] = xx[67];\n  xx[86] = - xx[68];\n  pm_math_Vector3_cross_ra(xx + 7, xx + 84, xx + 90);\n  xx[93] = motionData[0];\n  xx[94] = motionData[1];\n  xx[95] = motionData[2];\n  xx[96] = motionData[3];\n  xx[7] = - xx[27];\n  xx[8] = - xx[29];\n  xx[9] = - xx[21];\n  xx[97] = - xx[39];\n  xx[98] = xx[7];\n  xx[99] = xx[8];\n  xx[100] = xx[9];\n  pm_math_Quaternion_compose_ra(xx + 93, xx + 97, xx + 101);\n  xx[22] = xx[10] * xx[20];\n  xx[62] = xx[22] * xx[104];\n  xx[80] = xx[10] * xx[23];\n  xx[84] = xx[80] * xx[104];\n  xx[85] = xx[22] * xx[102] + xx[80] * xx[103];\n  xx[97] = - xx[62];\n  xx[98] = - xx[84];\n  xx[99] = xx[85];\n  pm_math_Vector3_cross_ra(xx + 102, xx + 97, xx + 105);\n  xx[86] = 0.04499999999999999;\n  xx[97] = xx[86] * xx[20];\n  xx[20] = xx[97] * xx[21];\n  xx[98] = xx[86] * xx[23];\n  xx[23] = xx[98] * xx[21];\n  xx[99] = xx[97] * xx[27] + xx[98] * xx[29];\n  xx[108] = xx[20];\n  xx[109] = xx[23];\n  xx[110] = - xx[99];\n  pm_math_Vector3_cross_ra(xx + 7, xx + 108, xx + 111);\n  xx[7] = xx[15] * (xx[111] - xx[20] * xx[39]) - xx[98];\n  xx[8] = xx[15] * (xx[112] - xx[23] * xx[39]) + xx[97];\n  xx[9] = xx[15] * (xx[113] + xx[39] * xx[99]);\n  pm_math_Quaternion_xform_ra(xx + 93, xx + 7, xx + 97);\n  xx[7] = xx[86] * xx[29];\n  xx[8] = xx[86] * xx[21];\n  xx[108] = xx[15] * (xx[7] * xx[29] + xx[8] * xx[21]) - xx[86];\n  xx[109] = - (xx[15] * (xx[8] * xx[39] + xx[7] * xx[27]));\n  xx[110] = xx[15] * (xx[7] * xx[39] - xx[8] * xx[27]);\n  pm_math_Quaternion_xform_ra(xx + 93, xx + 108, xx + 7);\n  xx[20] = xx[10] * xx[103];\n  xx[21] = xx[10] * xx[104];\n  xx[23] = bb[0] ? xx[0] : xx[14];\n  xx[27] = 0.0225;\n  xx[29] = xx[27] * state[23];\n  xx[39] = xx[29] * state[20];\n  xx[86] = xx[27] * state[21];\n  xx[93] = xx[27] * state[22];\n  xx[94] = xx[29] * state[23];\n  J[0] = xx[13];\n  J[1] = xx[13];\n  J[2] = xx[13];\n  J[3] = bb[0] ? xx[0] : xx[35];\n  J[4] = bb[0] ? xx[0] : xx[31];\n  J[5] = bb[0] ? xx[0] : xx[46];\n  J[6] = bb[0] ? xx[0] : xx[2];\n  J[7] = bb[0] ? xx[0] : xx[41];\n  J[8] = xx[13];\n  J[9] = xx[13];\n  J[10] = xx[13];\n  J[11] = bb[0] ? xx[0] : xx[50];\n  J[12] = bb[0] ? xx[0] : xx[54];\n  J[13] = bb[0] ? xx[0] : xx[58];\n  J[14] = xx[5];\n  J[15] = xx[5];\n  J[16] = xx[5];\n  J[17] = bb[0] ? xx[0] : xx[36];\n  J[18] = bb[0] ? xx[0] : xx[32];\n  J[19] = bb[0] ? xx[0] : xx[47];\n  J[20] = bb[0] ? xx[0] : xx[3];\n  J[21] = bb[0] ? xx[0] : xx[42];\n  J[22] = xx[5];\n  J[23] = xx[5];\n  J[24] = xx[5];\n  J[25] = bb[0] ? xx[0] : xx[51];\n  J[26] = bb[0] ? xx[0] : xx[55];\n  J[27] = bb[0] ? xx[0] : xx[59];\n  J[28] = xx[6];\n  J[29] = xx[6];\n  J[30] = xx[6];\n  J[31] = bb[0] ? xx[0] : xx[37];\n  J[32] = bb[0] ? xx[0] : xx[33];\n  J[33] = bb[0] ? xx[0] : xx[48];\n  J[34] = bb[0] ? xx[0] : xx[4];\n  J[35] = bb[0] ? xx[0] : xx[43];\n  J[36] = xx[6];\n  J[37] = xx[6];\n  J[38] = xx[6];\n  J[39] = bb[0] ? xx[0] : xx[52];\n  J[40] = bb[0] ? xx[0] : xx[56];\n  J[41] = bb[0] ? xx[0] : xx[60];\n  J[42] = xx[1];\n  J[43] = xx[0];\n  J[44] = xx[0];\n  J[45] = bb[0] ? xx[0] : - (xx[15] * (xx[69] - xx[12] * xx[65]) - xx[17] + xx\n    [15] * (state[3] * xx[30] + xx[72]) + xx[15] * (xx[44] - xx[45]));\n  J[46] = bb[0] ? xx[0] : - (xx[15] * (xx[75] - xx[28] * xx[65]) - xx[53] +\n    motionData[13] + xx[15] * (xx[81] - xx[61] * state[3]) - xx[15] * (state[5] *\n    state[5] + xx[64]) + xx[14]);\n  J[47] = bb[0] ? xx[0] : - (xx[15] * (xx[87] - xx[38] * xx[65]) - xx[79] + xx\n    [15] * (xx[90] - xx[66] * state[3]) - motionData[12]);\n  J[48] = bb[0] ? xx[0] : - (xx[15] * (xx[105] - xx[62] * xx[101]) - xx[80] +\n    xx[97]);\n  J[49] = bb[0] ? xx[0] : - (xx[7] + xx[15] * (xx[20] * xx[103] + xx[21] * xx\n    [104]) - xx[10]);\n  J[50] = xx[23];\n  J[51] = xx[0];\n  J[52] = xx[0];\n  J[53] = bb[0] ? xx[0] : xx[15] * (xx[39] - xx[86] * state[22]);\n  J[54] = bb[0] ? xx[0] : xx[27] - xx[15] * (xx[93] * state[22] + xx[94]);\n  J[55] = xx[0];\n  J[56] = xx[0];\n  J[57] = xx[1];\n  J[58] = xx[0];\n  J[59] = bb[0] ? xx[0] : - (xx[15] * (xx[70] - xx[18] * xx[65]) + xx[15] * (xx\n    [73] - xx[34] * state[3]) + xx[15] * (xx[64] + state[4] * state[4]) -\n    motionData[13] + xx[11] - xx[14]);\n  J[60] = bb[0] ? xx[0] : - (xx[15] * (xx[76] - xx[24] * xx[65]) + xx[49] + xx\n    [15] * (state[3] * xx[63] + xx[82]) + xx[15] * (xx[44] + xx[45]));\n  J[61] = bb[0] ? xx[0] : - (xx[15] * (xx[88] - xx[16] * xx[65]) + xx[78] +\n    motionData[11] + xx[15] * (xx[91] - xx[67] * state[3]));\n  J[62] = bb[0] ? xx[0] : - (xx[15] * (xx[106] - xx[84] * xx[101]) + xx[22] +\n    xx[98]);\n  J[63] = bb[0] ? xx[0] : - (xx[8] - xx[15] * (xx[21] * xx[101] + xx[20] * xx\n    [102]));\n  J[64] = xx[0];\n  J[65] = xx[23];\n  J[66] = xx[0];\n  J[67] = bb[0] ? xx[0] : xx[15] * (xx[94] + xx[86] * state[21]) - xx[27];\n  J[68] = bb[0] ? xx[0] : xx[15] * (xx[39] + xx[93] * state[21]);\n  J[69] = xx[0];\n  J[70] = xx[0];\n  J[71] = xx[0];\n  J[72] = xx[1];\n  J[73] = bb[0] ? xx[0] : - (xx[15] * (xx[71] + xx[19] * xx[65]) + motionData[12]\n    + xx[15] * (xx[74] - xx[40] * state[3]) - xx[15] * (state[3] * state[4] +\n    state[5] * state[6]));\n  J[74] = bb[0] ? xx[0] : - (xx[15] * (xx[77] + xx[57] * xx[65]) + xx[15] * (xx\n    [83] - xx[25] * state[3]) - motionData[11] + xx[15] * (state[4] * state[6] -\n    state[3] * state[5]));\n  J[75] = bb[0] ? xx[0] : - (xx[15] * (xx[89] + xx[26] * xx[65]) + xx[15] *\n    (state[3] * xx[68] + xx[92]));\n  J[76] = bb[0] ? xx[0] : - (xx[15] * (xx[107] + xx[85] * xx[101]) + xx[99]);\n  J[77] = bb[0] ? xx[0] : - (xx[15] * (xx[20] * xx[101] - xx[21] * xx[102]) +\n    xx[9]);\n  J[78] = xx[0];\n  J[79] = xx[0];\n  J[80] = xx[23];\n  J[81] = bb[0] ? xx[0] : - (xx[15] * (xx[86] * state[20] + xx[29] * state[22]));\n  J[82] = bb[0] ? xx[0] : xx[15] * (xx[29] * state[21] - xx[93] * state[20]);\n  J[83] = xx[0];\n  return 6;\n}\n\nsize_t simulation_b048d748_1_computeAssemblyJacobian(const void *mech, const\n  RuntimeDerivedValuesBundle *rtdv, size_t constraintIdx, boolean_T\n  forVelocitySatisfaction, const double *state, const int *modeVector, const\n  double *motionData, double *J)\n{\n  (void) mech;\n  (void) rtdv;\n  (void) state;\n  (void) modeVector;\n  (void) forVelocitySatisfaction;\n  (void) motionData;\n  (void) J;\n  switch (constraintIdx)\n  {\n   case 0:\n    return computeAssemblyJacobian_0(rtdv, state, modeVector, motionData, J);\n  }\n\n  return 0;\n}\n\nsize_t simulation_b048d748_1_computeFullAssemblyJacobian(const void *mech, const\n  RuntimeDerivedValuesBundle *rtdv, const double *state, const int *modeVector,\n  const double *motionData, double *J)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  boolean_T bb[1];\n  double xx[114];\n  (void) mech;\n  (void) rtdvd;\n  (void) rtdvi;\n  bb[0] = modeVector[0] == -1;\n  xx[0] = 0.0;\n  xx[1] = motionData[21];\n  xx[2] = motionData[22];\n  xx[3] = motionData[23];\n  xx[4] = motionData[24];\n  xx[5] = motionData[14];\n  xx[6] = motionData[15];\n  xx[7] = motionData[16];\n  xx[8] = motionData[17];\n  pm_math_Quaternion_inverseCompose_ra(xx + 1, xx + 5, xx + 9);\n  xx[13] = xx[0];\n  xx[14] = xx[0];\n  xx[15] = xx[0];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 13, xx + 16);\n  xx[13] = bb[0] ? xx[0] : xx[17];\n  xx[14] = 1.0;\n  xx[15] = 2.0;\n  xx[20] = motionData[9] * motionData[9];\n  xx[21] = motionData[10] * motionData[10];\n  xx[22] = xx[14] - xx[15] * (xx[20] + xx[21]);\n  xx[23] = motionData[8] * motionData[9];\n  xx[24] = motionData[7] * motionData[10];\n  xx[25] = xx[23] - xx[24];\n  xx[26] = motionData[7] * motionData[9];\n  xx[27] = motionData[8] * motionData[10];\n  xx[28] = xx[22];\n  xx[29] = xx[15] * xx[25];\n  xx[30] = xx[15] * (xx[26] + xx[27]);\n  pm_math_Quaternion_xform_ra(xx + 1, xx + 28, xx + 31);\n  pm_math_Quaternion_inverseXform_ra(xx + 5, xx + 31, xx + 28);\n  xx[31] = - xx[28];\n  xx[32] = - xx[29];\n  xx[33] = - xx[30];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 31, xx + 34);\n  xx[28] = xx[24] + xx[23];\n  xx[23] = motionData[8] * motionData[8];\n  xx[24] = xx[14] - xx[15] * (xx[21] + xx[23]);\n  xx[21] = motionData[9] * motionData[10];\n  xx[29] = motionData[7] * motionData[8];\n  xx[30] = xx[15] * xx[28];\n  xx[31] = xx[24];\n  xx[32] = xx[15] * (xx[21] - xx[29]);\n  pm_math_Quaternion_xform_ra(xx + 1, xx + 30, xx + 38);\n  pm_math_Quaternion_inverseXform_ra(xx + 5, xx + 38, xx + 30);\n  xx[38] = - xx[30];\n  xx[39] = - xx[31];\n  xx[40] = - xx[32];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 38, xx + 30);\n  xx[38] = xx[27] - xx[26];\n  xx[26] = xx[29] + xx[21];\n  xx[39] = xx[15] * xx[38];\n  xx[40] = xx[15] * xx[26];\n  xx[41] = xx[14] - xx[15] * (xx[23] + xx[20]);\n  pm_math_Quaternion_xform_ra(xx + 1, xx + 39, xx + 42);\n  pm_math_Quaternion_inverseXform_ra(xx + 5, xx + 42, xx + 39);\n  xx[42] = - xx[39];\n  xx[43] = - xx[40];\n  xx[44] = - xx[41];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 42, xx + 45);\n  xx[20] = 0.5;\n  xx[21] = xx[20] * state[13];\n  xx[23] = cos(xx[21]);\n  xx[27] = xx[20] * state[14];\n  xx[20] = sin(xx[27]);\n  xx[29] = xx[23] * xx[20];\n  xx[39] = sin(xx[21]);\n  xx[21] = xx[39] * xx[20];\n  xx[20] = xx[14] - xx[15] * (xx[29] * xx[29] + xx[21] * xx[21]);\n  xx[40] = cos(xx[27]);\n  xx[27] = xx[40] * xx[39];\n  xx[39] = xx[23] * xx[40];\n  xx[23] = xx[15] * (xx[29] * xx[27] - xx[39] * xx[21]);\n  xx[40] = xx[20];\n  xx[41] = xx[23];\n  xx[42] = xx[15] * (xx[39] * xx[29] + xx[27] * xx[21]);\n  pm_math_Quaternion_xform_ra(xx + 1, xx + 40, xx + 49);\n  pm_math_Quaternion_inverseXform_ra(xx + 5, xx + 49, xx + 1);\n  xx[40] = - xx[1];\n  xx[41] = - xx[2];\n  xx[42] = - xx[3];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 40, xx + 1);\n  xx[40] = xx[15] * (motionData[22] * motionData[23] - motionData[21] *\n                     motionData[24]);\n  xx[41] = xx[14] - xx[15] * (motionData[24] * motionData[24] + motionData[22] *\n    motionData[22]);\n  xx[42] = xx[15] * (motionData[21] * motionData[22] + motionData[23] *\n                     motionData[24]);\n  pm_math_Quaternion_inverseXform_ra(xx + 5, xx + 40, xx + 49);\n  xx[5] = - xx[49];\n  xx[6] = - xx[50];\n  xx[7] = - xx[51];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 5, xx + 40);\n  xx[5] = xx[14];\n  xx[6] = xx[0];\n  xx[7] = xx[0];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 5, xx + 49);\n  xx[5] = xx[0];\n  xx[6] = xx[14];\n  xx[7] = xx[0];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 5, xx + 53);\n  xx[5] = xx[0];\n  xx[6] = xx[0];\n  xx[7] = xx[14];\n  pm_math_Quaternion_compDeriv_ra(xx + 9, xx + 5, xx + 57);\n  xx[5] = bb[0] ? xx[0] : xx[18];\n  xx[6] = bb[0] ? xx[0] : xx[19];\n  xx[1] = bb[0] ? xx[0] : - xx[14];\n  xx[7] = - state[4];\n  xx[8] = - state[5];\n  xx[9] = - state[6];\n  xx[16] = - state[3];\n  xx[17] = xx[7];\n  xx[18] = xx[8];\n  xx[19] = xx[9];\n  xx[61] = motionData[7];\n  xx[62] = motionData[8];\n  xx[63] = motionData[9];\n  xx[64] = motionData[10];\n  pm_math_Quaternion_compose_ra(xx + 16, xx + 61, xx + 65);\n  xx[10] = 0.04500000000000001;\n  xx[11] = xx[10] * xx[22];\n  xx[12] = xx[11] * xx[68];\n  xx[16] = 0.09000000000000001;\n  xx[17] = xx[16] * xx[25];\n  xx[18] = xx[17] * xx[68];\n  xx[19] = xx[11] * xx[66] + xx[17] * xx[67];\n  xx[61] = - xx[12];\n  xx[62] = - xx[18];\n  xx[63] = xx[19];\n  pm_math_Vector3_cross_ra(xx + 66, xx + 61, xx + 69);\n  xx[22] = motionData[12] * state[5];\n  xx[25] = motionData[13] * state[6];\n  xx[30] = xx[22] + xx[25];\n  xx[34] = motionData[12] * state[4];\n  xx[40] = motionData[13] * state[4];\n  xx[61] = - xx[30];\n  xx[62] = xx[34];\n  xx[63] = xx[40];\n  pm_math_Vector3_cross_ra(xx + 7, xx + 61, xx + 72);\n  xx[44] = state[3] * state[6];\n  xx[45] = state[4] * state[5];\n  xx[49] = xx[16] * xx[28];\n  xx[28] = xx[49] * xx[68];\n  xx[53] = xx[10] * xx[24];\n  xx[24] = xx[53] * xx[68];\n  xx[57] = xx[49] * xx[66] + xx[53] * xx[67];\n  xx[61] = - xx[28];\n  xx[62] = - xx[24];\n  xx[63] = xx[57];\n  pm_math_Vector3_cross_ra(xx + 66, xx + 61, xx + 75);\n  xx[61] = motionData[11] * state[5];\n  xx[62] = motionData[11] * state[4];\n  xx[63] = xx[25] + xx[62];\n  xx[25] = motionData[13] * state[5];\n  xx[78] = xx[61];\n  xx[79] = - xx[63];\n  xx[80] = xx[25];\n  pm_math_Vector3_cross_ra(xx + 7, xx + 78, xx + 81);\n  xx[64] = state[6] * state[6];\n  xx[78] = xx[16] * xx[38];\n  xx[38] = xx[78] * xx[68];\n  xx[79] = xx[16] * xx[26];\n  xx[16] = xx[79] * xx[68];\n  xx[26] = xx[78] * xx[66] + xx[79] * xx[67];\n  xx[84] = - xx[38];\n  xx[85] = - xx[16];\n  xx[86] = xx[26];\n  pm_math_Vector3_cross_ra(xx + 66, xx + 84, xx + 87);\n  xx[66] = motionData[11] * state[6];\n  xx[67] = motionData[12] * state[6];\n  xx[68] = xx[62] + xx[22];\n  xx[84] = xx[66];\n  xx[85] = xx[67];\n  xx[86] = - xx[68];\n  pm_math_Vector3_cross_ra(xx + 7, xx + 84, xx + 90);\n  xx[93] = motionData[0];\n  xx[94] = motionData[1];\n  xx[95] = motionData[2];\n  xx[96] = motionData[3];\n  xx[7] = - xx[27];\n  xx[8] = - xx[29];\n  xx[9] = - xx[21];\n  xx[97] = - xx[39];\n  xx[98] = xx[7];\n  xx[99] = xx[8];\n  xx[100] = xx[9];\n  pm_math_Quaternion_compose_ra(xx + 93, xx + 97, xx + 101);\n  xx[22] = xx[10] * xx[20];\n  xx[62] = xx[22] * xx[104];\n  xx[80] = xx[10] * xx[23];\n  xx[84] = xx[80] * xx[104];\n  xx[85] = xx[22] * xx[102] + xx[80] * xx[103];\n  xx[97] = - xx[62];\n  xx[98] = - xx[84];\n  xx[99] = xx[85];\n  pm_math_Vector3_cross_ra(xx + 102, xx + 97, xx + 105);\n  xx[86] = 0.04499999999999999;\n  xx[97] = xx[86] * xx[20];\n  xx[20] = xx[97] * xx[21];\n  xx[98] = xx[86] * xx[23];\n  xx[23] = xx[98] * xx[21];\n  xx[99] = xx[97] * xx[27] + xx[98] * xx[29];\n  xx[108] = xx[20];\n  xx[109] = xx[23];\n  xx[110] = - xx[99];\n  pm_math_Vector3_cross_ra(xx + 7, xx + 108, xx + 111);\n  xx[7] = xx[15] * (xx[111] - xx[20] * xx[39]) - xx[98];\n  xx[8] = xx[15] * (xx[112] - xx[23] * xx[39]) + xx[97];\n  xx[9] = xx[15] * (xx[113] + xx[39] * xx[99]);\n  pm_math_Quaternion_xform_ra(xx + 93, xx + 7, xx + 97);\n  xx[7] = xx[86] * xx[29];\n  xx[8] = xx[86] * xx[21];\n  xx[108] = xx[15] * (xx[7] * xx[29] + xx[8] * xx[21]) - xx[86];\n  xx[109] = - (xx[15] * (xx[8] * xx[39] + xx[7] * xx[27]));\n  xx[110] = xx[15] * (xx[7] * xx[39] - xx[8] * xx[27]);\n  pm_math_Quaternion_xform_ra(xx + 93, xx + 108, xx + 7);\n  xx[20] = xx[10] * xx[103];\n  xx[21] = xx[10] * xx[104];\n  xx[23] = bb[0] ? xx[0] : xx[14];\n  xx[27] = 0.0225;\n  xx[29] = xx[27] * state[23];\n  xx[39] = xx[29] * state[20];\n  xx[86] = xx[27] * state[21];\n  xx[93] = xx[27] * state[22];\n  xx[94] = xx[29] * state[23];\n  J[0] = xx[13];\n  J[1] = xx[13];\n  J[2] = xx[13];\n  J[3] = bb[0] ? xx[0] : xx[35];\n  J[4] = bb[0] ? xx[0] : xx[31];\n  J[5] = bb[0] ? xx[0] : xx[46];\n  J[6] = bb[0] ? xx[0] : xx[2];\n  J[7] = bb[0] ? xx[0] : xx[41];\n  J[8] = xx[13];\n  J[9] = xx[13];\n  J[10] = xx[13];\n  J[11] = bb[0] ? xx[0] : xx[50];\n  J[12] = bb[0] ? xx[0] : xx[54];\n  J[13] = bb[0] ? xx[0] : xx[58];\n  J[14] = xx[5];\n  J[15] = xx[5];\n  J[16] = xx[5];\n  J[17] = bb[0] ? xx[0] : xx[36];\n  J[18] = bb[0] ? xx[0] : xx[32];\n  J[19] = bb[0] ? xx[0] : xx[47];\n  J[20] = bb[0] ? xx[0] : xx[3];\n  J[21] = bb[0] ? xx[0] : xx[42];\n  J[22] = xx[5];\n  J[23] = xx[5];\n  J[24] = xx[5];\n  J[25] = bb[0] ? xx[0] : xx[51];\n  J[26] = bb[0] ? xx[0] : xx[55];\n  J[27] = bb[0] ? xx[0] : xx[59];\n  J[28] = xx[6];\n  J[29] = xx[6];\n  J[30] = xx[6];\n  J[31] = bb[0] ? xx[0] : xx[37];\n  J[32] = bb[0] ? xx[0] : xx[33];\n  J[33] = bb[0] ? xx[0] : xx[48];\n  J[34] = bb[0] ? xx[0] : xx[4];\n  J[35] = bb[0] ? xx[0] : xx[43];\n  J[36] = xx[6];\n  J[37] = xx[6];\n  J[38] = xx[6];\n  J[39] = bb[0] ? xx[0] : xx[52];\n  J[40] = bb[0] ? xx[0] : xx[56];\n  J[41] = bb[0] ? xx[0] : xx[60];\n  J[42] = xx[1];\n  J[43] = xx[0];\n  J[44] = xx[0];\n  J[45] = bb[0] ? xx[0] : - (xx[15] * (xx[69] - xx[12] * xx[65]) - xx[17] + xx\n    [15] * (state[3] * xx[30] + xx[72]) + xx[15] * (xx[44] - xx[45]));\n  J[46] = bb[0] ? xx[0] : - (xx[15] * (xx[75] - xx[28] * xx[65]) - xx[53] +\n    motionData[13] + xx[15] * (xx[81] - xx[61] * state[3]) - xx[15] * (state[5] *\n    state[5] + xx[64]) + xx[14]);\n  J[47] = bb[0] ? xx[0] : - (xx[15] * (xx[87] - xx[38] * xx[65]) - xx[79] + xx\n    [15] * (xx[90] - xx[66] * state[3]) - motionData[12]);\n  J[48] = bb[0] ? xx[0] : - (xx[15] * (xx[105] - xx[62] * xx[101]) - xx[80] +\n    xx[97]);\n  J[49] = bb[0] ? xx[0] : - (xx[7] + xx[15] * (xx[20] * xx[103] + xx[21] * xx\n    [104]) - xx[10]);\n  J[50] = xx[23];\n  J[51] = xx[0];\n  J[52] = xx[0];\n  J[53] = bb[0] ? xx[0] : xx[15] * (xx[39] - xx[86] * state[22]);\n  J[54] = bb[0] ? xx[0] : xx[27] - xx[15] * (xx[93] * state[22] + xx[94]);\n  J[55] = xx[0];\n  J[56] = xx[0];\n  J[57] = xx[1];\n  J[58] = xx[0];\n  J[59] = bb[0] ? xx[0] : - (xx[15] * (xx[70] - xx[18] * xx[65]) + xx[15] * (xx\n    [73] - xx[34] * state[3]) + xx[15] * (xx[64] + state[4] * state[4]) -\n    motionData[13] + xx[11] - xx[14]);\n  J[60] = bb[0] ? xx[0] : - (xx[15] * (xx[76] - xx[24] * xx[65]) + xx[49] + xx\n    [15] * (state[3] * xx[63] + xx[82]) + xx[15] * (xx[44] + xx[45]));\n  J[61] = bb[0] ? xx[0] : - (xx[15] * (xx[88] - xx[16] * xx[65]) + xx[78] +\n    motionData[11] + xx[15] * (xx[91] - xx[67] * state[3]));\n  J[62] = bb[0] ? xx[0] : - (xx[15] * (xx[106] - xx[84] * xx[101]) + xx[22] +\n    xx[98]);\n  J[63] = bb[0] ? xx[0] : - (xx[8] - xx[15] * (xx[21] * xx[101] + xx[20] * xx\n    [102]));\n  J[64] = xx[0];\n  J[65] = xx[23];\n  J[66] = xx[0];\n  J[67] = bb[0] ? xx[0] : xx[15] * (xx[94] + xx[86] * state[21]) - xx[27];\n  J[68] = bb[0] ? xx[0] : xx[15] * (xx[39] + xx[93] * state[21]);\n  J[69] = xx[0];\n  J[70] = xx[0];\n  J[71] = xx[0];\n  J[72] = xx[1];\n  J[73] = bb[0] ? xx[0] : - (xx[15] * (xx[71] + xx[19] * xx[65]) + motionData[12]\n    + xx[15] * (xx[74] - xx[40] * state[3]) - xx[15] * (state[3] * state[4] +\n    state[5] * state[6]));\n  J[74] = bb[0] ? xx[0] : - (xx[15] * (xx[77] + xx[57] * xx[65]) + xx[15] * (xx\n    [83] - xx[25] * state[3]) - motionData[11] + xx[15] * (state[4] * state[6] -\n    state[3] * state[5]));\n  J[75] = bb[0] ? xx[0] : - (xx[15] * (xx[89] + xx[26] * xx[65]) + xx[15] *\n    (state[3] * xx[68] + xx[92]));\n  J[76] = bb[0] ? xx[0] : - (xx[15] * (xx[107] + xx[85] * xx[101]) + xx[99]);\n  J[77] = bb[0] ? xx[0] : - (xx[15] * (xx[20] * xx[101] - xx[21] * xx[102]) +\n    xx[9]);\n  J[78] = xx[0];\n  J[79] = xx[0];\n  J[80] = xx[23];\n  J[81] = bb[0] ? xx[0] : - (xx[15] * (xx[86] * state[20] + xx[29] * state[22]));\n  J[82] = bb[0] ? xx[0] : xx[15] * (xx[29] * state[21] - xx[93] * state[20]);\n  J[83] = xx[0];\n  return 6;\n}\n\nstatic boolean_T isInKinematicSingularity_0(const RuntimeDerivedValuesBundle\n  *rtdv, const int *modeVector, const double *motionData)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) modeVector;\n  (void) motionData;\n  return 0;\n}\n\nboolean_T simulation_b048d748_1_isInKinematicSingularity(const void *mech, const\n  RuntimeDerivedValuesBundle *rtdv, size_t constraintIdx, const int *modeVector,\n  const double *motionData)\n{\n  (void) mech;\n  (void) rtdv;\n  (void) modeVector;\n  (void) motionData;\n  switch (constraintIdx)\n  {\n   case 0:\n    return isInKinematicSingularity_0(rtdv, modeVector, motionData);\n  }\n\n  return 0;\n}\n\nvoid simulation_b048d748_1_convertStateVector(const void *asmMech, const\n  RuntimeDerivedValuesBundle *rtdv, const void *simMech, const double *asmState,\n  const int *asmModeVector, const int *simModeVector, double *simState)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  double xx[10];\n  (void) asmMech;\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) simMech;\n  (void) asmModeVector;\n  (void) simModeVector;\n  xx[0] = - asmState[20];\n  xx[1] = - asmState[21];\n  xx[2] = - asmState[22];\n  xx[3] = - asmState[23];\n  xx[4] = asmState[24];\n  xx[5] = asmState[25];\n  xx[6] = asmState[26];\n  pm_math_Quaternion_inverseXform_ra(xx + 0, xx + 4, xx + 7);\n  pm_math_Quaternion_xform_ra(xx + 0, xx + 7, xx + 4);\n  simState[0] = asmState[0];\n  simState[1] = asmState[1];\n  simState[2] = asmState[2];\n  simState[3] = asmState[3];\n  simState[4] = asmState[4];\n  simState[5] = asmState[5];\n  simState[6] = asmState[6];\n  simState[7] = asmState[7];\n  simState[8] = asmState[8];\n  simState[9] = asmState[9];\n  simState[10] = asmState[10];\n  simState[11] = asmState[11];\n  simState[12] = asmState[12];\n  simState[13] = asmState[13];\n  simState[14] = asmState[14];\n  simState[15] = asmState[15];\n  simState[16] = asmState[16];\n  simState[17] = asmState[17];\n  simState[18] = asmState[18];\n  simState[19] = asmState[19];\n  simState[20] = xx[0];\n  simState[21] = xx[1];\n  simState[22] = xx[2];\n  simState[23] = xx[3];\n  simState[24] = xx[4];\n  simState[25] = xx[5];\n  simState[26] = xx[6];\n  simState[27] = asmState[27];\n  simState[28] = asmState[28];\n  simState[29] = asmState[29];\n}\n"},{"name":"simulation_b048d748_1_asserts.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include <math.h>\n#include <string.h>\n#include \"pm_std.h\"\n#include \"sm_std.h\"\n#include \"ne_std.h\"\n#include \"ne_dae.h\"\n#include \"sm_ssci_run_time_errors.h\"\n#include \"sm_RuntimeDerivedValuesBundle.h\"\n\nvoid simulation_b048d748_1_validateRuntimeParameters(const double *rtp, int32_T *\n  satFlags)\n{\n  (void) rtp;\n  (void) satFlags;\n}\n\nconst NeAssertData *simulation_b048d748_1_assertData = NULL;\n"},{"name":"simulation_b048d748_1_checkDynamics.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include <math.h>\n#include <string.h>\n#include \"pm_std.h\"\n#include \"sm_std.h\"\n#include \"ne_std.h\"\n#include \"ne_dae.h\"\n#include \"sm_ssci_run_time_errors.h\"\n#include \"sm_RuntimeDerivedValuesBundle.h\"\n#include \"simulation_b048d748_1_geometries.h\"\n\nPmfMessageId simulation_b048d748_1_checkDynamics(const\n  RuntimeDerivedValuesBundle *rtdv, const double *state, const double *input,\n  const double *inputDot, const double *inputDdot, const double *discreteState,\n  const int *modeVector, double *errorResult, NeuDiagnosticManager *neDiagMgr)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) state;\n  (void) input;\n  (void) inputDot;\n  (void) inputDdot;\n  (void) discreteState;\n  (void) modeVector;\n  (void) neDiagMgr;\n  errorResult[0] = 0.0;\n  return NULL;\n}\n"},{"name":"simulation_b048d748_1_compOutputsDyn.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include <math.h>\n#include <string.h>\n#include \"pm_std.h\"\n#include \"sm_std.h\"\n#include \"ne_std.h\"\n#include \"ne_dae.h\"\n#include \"sm_ssci_run_time_errors.h\"\n#include \"sm_RuntimeDerivedValuesBundle.h\"\n#include \"simulation_b048d748_1_geometries.h\"\n\nPmfMessageId simulation_b048d748_1_compOutputsDyn(const\n  RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags, const double\n  *state, const int *modeVector, const double *input, const double *inputDot,\n  const double *inputDdot, const double *discreteState, double *deriv, double\n  *output, int *derivErr, double *errorResult, NeuDiagnosticManager *neDiagMgr)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  boolean_T bb[2];\n  int ii[6];\n  double xx[558];\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) eqnEnableFlags;\n  (void) discreteState;\n  (void) neDiagMgr;\n  (void) derivErr;\n  xx[0] = state[3];\n  xx[1] = state[4];\n  xx[2] = state[5];\n  xx[3] = state[6];\n  xx[4] = state[10];\n  xx[5] = state[11];\n  xx[6] = state[12];\n  pm_math_Quaternion_compDeriv_ra(xx + 0, xx + 4, xx + 7);\n  xx[11] = 1.0;\n  xx[12] = 2.0;\n  xx[13] = state[5] * state[5];\n  xx[14] = state[6] * state[6];\n  xx[15] = xx[12] * (xx[13] + xx[14]);\n  xx[16] = xx[11] - xx[15];\n  xx[17] = state[4] * state[5];\n  xx[18] = state[3] * state[6];\n  xx[19] = xx[12] * (xx[17] - xx[18]);\n  xx[20] = state[3] * state[5];\n  xx[21] = state[4] * state[6];\n  xx[22] = xx[12] * (xx[20] + xx[21]);\n  xx[23] = xx[16];\n  xx[24] = xx[19];\n  xx[25] = xx[22];\n  xx[26] = 1.1;\n  xx[27] = 0.5;\n  xx[28] = xx[27] * input[0];\n  xx[29] = cos(xx[28]);\n  xx[30] = xx[27] * input[1];\n  xx[27] = cos(xx[30]);\n  xx[31] = xx[29] * xx[27];\n  xx[32] = xx[31] * xx[31];\n  xx[33] = sin(xx[28]);\n  xx[28] = xx[27] * xx[33];\n  xx[34] = xx[28] * xx[28];\n  xx[35] = xx[12] * (xx[32] + xx[34]) - xx[11];\n  xx[36] = sin(xx[30]);\n  xx[37] = xx[29] * xx[36];\n  xx[29] = xx[37] * xx[28];\n  xx[38] = xx[33] * xx[36];\n  xx[33] = xx[31] * xx[38];\n  xx[39] = xx[29] - xx[33];\n  xx[40] = xx[12] * xx[39];\n  xx[41] = xx[28] * xx[38];\n  xx[42] = xx[31] * xx[37];\n  xx[43] = xx[12] * (xx[41] + xx[42]);\n  xx[44] = xx[12] * (xx[29] + xx[33]);\n  xx[45] = xx[37] * xx[37];\n  xx[46] = xx[12] * (xx[32] + xx[45]) - xx[11];\n  xx[47] = xx[37] * xx[38];\n  xx[48] = xx[31] * xx[28];\n  xx[49] = xx[12] * (xx[47] - xx[48]);\n  xx[50] = xx[12] * (xx[41] - xx[42]);\n  xx[51] = xx[12] * (xx[47] + xx[48]);\n  xx[52] = xx[38] * xx[38];\n  xx[53] = xx[12] * (xx[32] + xx[52]) - xx[11];\n  xx[54] = xx[35];\n  xx[55] = xx[40];\n  xx[56] = xx[43];\n  xx[57] = xx[44];\n  xx[58] = xx[46];\n  xx[59] = xx[49];\n  xx[60] = xx[50];\n  xx[61] = xx[51];\n  xx[62] = xx[53];\n  xx[32] = 0.1;\n  xx[63] = xx[32] * xx[35];\n  xx[64] = xx[32] * xx[44];\n  xx[65] = xx[32] * xx[50];\n  xx[66] = xx[32] * xx[40];\n  xx[67] = xx[32] * xx[46];\n  xx[68] = xx[32] * xx[51];\n  xx[69] = xx[32] * xx[43];\n  xx[70] = xx[32] * xx[49];\n  xx[71] = xx[32] * xx[53];\n  pm_math_Matrix3x3_compose_ra(xx + 54, xx + 63, xx + 72);\n  xx[63] = xx[26] + xx[72];\n  xx[64] = xx[26] + xx[76];\n  xx[81] = xx[63];\n  xx[82] = xx[73];\n  xx[83] = xx[74];\n  xx[84] = xx[75];\n  xx[85] = xx[64];\n  xx[86] = xx[77];\n  xx[87] = xx[78];\n  xx[88] = xx[79];\n  xx[89] = xx[26] + xx[80];\n  pm_math_Matrix3x3_xform_ra(xx + 81, xx + 23, xx + 65);\n  xx[26] = xx[12] * (xx[18] + xx[17]);\n  xx[68] = state[4] * state[4];\n  xx[69] = xx[12] * (xx[14] + xx[68]);\n  xx[70] = xx[11] - xx[69];\n  xx[71] = state[5] * state[6];\n  xx[90] = state[3] * state[4];\n  xx[91] = xx[12] * (xx[71] - xx[90]);\n  xx[92] = xx[26];\n  xx[93] = xx[70];\n  xx[94] = xx[91];\n  pm_math_Matrix3x3_xform_ra(xx + 81, xx + 92, xx + 95);\n  xx[98] = pm_math_Vector3_dot_ra(xx + 23, xx + 95);\n  xx[99] = xx[12] * (xx[21] - xx[20]);\n  xx[100] = xx[12] * (xx[90] + xx[71]);\n  xx[101] = xx[12] * (xx[68] + xx[13]);\n  xx[102] = xx[11] - xx[101];\n  xx[103] = xx[99];\n  xx[104] = xx[100];\n  xx[105] = xx[102];\n  pm_math_Matrix3x3_xform_ra(xx + 81, xx + 103, xx + 106);\n  xx[109] = pm_math_Vector3_dot_ra(xx + 23, xx + 106);\n  xx[110] = 0.04499999999999999;\n  xx[111] = xx[110] * xx[37];\n  xx[112] = xx[111] * xx[31];\n  xx[113] = xx[110] * xx[28];\n  xx[114] = xx[12] * (xx[112] + xx[113] * xx[38]);\n  xx[115] = xx[12] * (xx[113] * xx[31] - xx[111] * xx[38]);\n  xx[116] = xx[111] * xx[37];\n  xx[117] = xx[12] * (xx[113] * xx[28] + xx[116]) - xx[110] - xx[11];\n  xx[118] = - xx[114];\n  xx[119] = xx[115];\n  xx[120] = xx[117];\n  pm_math_Matrix3x3_postCross_ra(xx + 72, xx + 118, xx + 121);\n  xx[72] = - (xx[121] + xx[73]);\n  xx[73] = xx[124] + xx[64];\n  xx[64] = - xx[73];\n  xx[74] = - (xx[127] + xx[79]);\n  xx[130] = xx[72];\n  xx[131] = xx[64];\n  xx[132] = xx[74];\n  xx[76] = pm_math_Vector3_dot_ra(xx + 23, xx + 130);\n  xx[77] = xx[63] - xx[122];\n  xx[63] = xx[75] - xx[125];\n  xx[75] = xx[78] - xx[128];\n  xx[78] = xx[77];\n  xx[79] = xx[63];\n  xx[80] = xx[75];\n  xx[113] = pm_math_Vector3_dot_ra(xx + 23, xx + 78);\n  xx[133] = - xx[123];\n  xx[134] = - xx[126];\n  xx[135] = - xx[129];\n  xx[136] = pm_math_Vector3_dot_ra(xx + 23, xx + 133);\n  xx[137] = pm_math_Vector3_dot_ra(xx + 92, xx + 106);\n  xx[138] = pm_math_Vector3_dot_ra(xx + 92, xx + 130);\n  xx[139] = pm_math_Vector3_dot_ra(xx + 92, xx + 78);\n  xx[140] = pm_math_Vector3_dot_ra(xx + 92, xx + 133);\n  xx[141] = pm_math_Vector3_dot_ra(xx + 103, xx + 130);\n  xx[130] = pm_math_Vector3_dot_ra(xx + 103, xx + 78);\n  xx[78] = pm_math_Vector3_dot_ra(xx + 103, xx + 133);\n  xx[79] = 1.181250000000001e-4;\n  xx[80] = 1.0125e-4;\n  xx[142] = xx[79] * xx[35];\n  xx[143] = xx[79] * xx[44];\n  xx[144] = xx[79] * xx[50];\n  xx[145] = xx[79] * xx[40];\n  xx[146] = xx[79] * xx[46];\n  xx[147] = xx[79] * xx[51];\n  xx[148] = xx[80] * xx[43];\n  xx[149] = xx[80] * xx[49];\n  xx[150] = xx[80] * xx[53];\n  pm_math_Matrix3x3_compose_ra(xx + 54, xx + 142, xx + 151);\n  pm_math_Matrix3x3_preCross_ra(xx + 121, xx + 118, xx + 142);\n  xx[35] = xx[11] + xx[151] - xx[142] + xx[124];\n  xx[43] = xx[152] - xx[143] - xx[121];\n  xx[44] = xx[43] - xx[63];\n  xx[46] = xx[153] - xx[144];\n  xx[51] = xx[46] + xx[126];\n  xx[53] = xx[11] + xx[155] - xx[146] - xx[122];\n  xx[129] = xx[156] - xx[147];\n  xx[131] = xx[129] - xx[123];\n  xx[132] = xx[11] + xx[159] - xx[150];\n  xx[160] = pm_math_Vector3_dot_ra(xx + 23, xx + 65);\n  xx[161] = xx[98];\n  xx[162] = xx[109];\n  xx[163] = xx[76];\n  xx[164] = xx[113];\n  xx[165] = xx[136];\n  xx[166] = xx[98];\n  xx[167] = pm_math_Vector3_dot_ra(xx + 92, xx + 95);\n  xx[168] = xx[137];\n  xx[169] = xx[138];\n  xx[170] = xx[139];\n  xx[171] = xx[140];\n  xx[172] = xx[109];\n  xx[173] = xx[137];\n  xx[174] = pm_math_Vector3_dot_ra(xx + 103, xx + 106);\n  xx[175] = xx[141];\n  xx[176] = xx[130];\n  xx[177] = xx[78];\n  xx[178] = xx[76];\n  xx[179] = xx[138];\n  xx[180] = xx[141];\n  xx[181] = xx[35] + xx[73];\n  xx[182] = xx[44];\n  xx[183] = xx[51];\n  xx[184] = xx[113];\n  xx[185] = xx[139];\n  xx[186] = xx[130];\n  xx[187] = xx[44];\n  xx[188] = xx[53] + xx[77];\n  xx[189] = xx[131];\n  xx[190] = xx[136];\n  xx[191] = xx[140];\n  xx[192] = xx[78];\n  xx[193] = xx[51];\n  xx[194] = xx[131];\n  xx[195] = xx[132];\n  ii[0] = factorSymmetricPosDef(xx + 160, 6, xx + 136);\n  if (ii[0] != 0)\n    *derivErr = 1;\n  xx[44] = 0.0;\n  bb[0] = modeVector[0] == -1;\n  xx[51] = xx[11] - xx[12] * (xx[45] + xx[52]);\n  xx[73] = - state[3];\n  xx[76] = - state[4];\n  xx[78] = - state[5];\n  xx[98] = - state[6];\n  xx[136] = xx[73];\n  xx[137] = xx[76];\n  xx[138] = xx[78];\n  xx[139] = xx[98];\n  xx[109] = - xx[28];\n  xx[113] = - xx[37];\n  xx[130] = - xx[38];\n  xx[196] = - xx[31];\n  xx[197] = xx[109];\n  xx[198] = xx[113];\n  xx[199] = xx[130];\n  pm_math_Quaternion_compose_ra(xx + 136, xx + 196, xx + 200);\n  xx[131] = xx[51] * xx[202];\n  xx[140] = xx[12] * (xx[42] + xx[41]);\n  xx[41] = xx[140] * xx[203];\n  xx[42] = xx[51] * xx[201];\n  xx[141] = xx[41] + xx[42];\n  xx[204] = xx[140] * xx[202];\n  xx[205] = xx[131];\n  xx[206] = - xx[141];\n  xx[207] = xx[204];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 205, xx + 208);\n  xx[205] = xx[12] * (xx[131] * xx[200] + xx[208]) - xx[140];\n  xx[206] = xx[12] * (xx[209] - xx[141] * xx[200]);\n  xx[207] = xx[51] + xx[12] * (xx[204] * xx[200] + xx[210]);\n  xx[131] = state[16] * state[16];\n  xx[141] = state[17] * state[17];\n  xx[204] = xx[12] * (xx[131] + xx[141]) - xx[11];\n  xx[208] = state[17] * state[18];\n  xx[209] = state[16] * state[19];\n  xx[210] = xx[12] * (xx[208] + xx[209]);\n  xx[211] = state[17] * state[19];\n  xx[212] = state[16] * state[18];\n  xx[213] = xx[12] * (xx[211] - xx[212]);\n  xx[214] = xx[204];\n  xx[215] = xx[210];\n  xx[216] = xx[213];\n  xx[217] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 205, xx + 214);\n  xx[205] = xx[12] * (xx[33] + xx[29]);\n  xx[29] = xx[205] * xx[202];\n  xx[33] = xx[49] * xx[203];\n  xx[206] = xx[205] * xx[201];\n  xx[207] = xx[33] + xx[206];\n  xx[218] = xx[49] * xx[202];\n  xx[219] = xx[29];\n  xx[220] = - xx[207];\n  xx[221] = xx[218];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 219, xx + 222);\n  xx[219] = xx[12] * (xx[29] * xx[200] + xx[222]) - xx[49];\n  xx[220] = xx[12] * (xx[223] - xx[207] * xx[200]);\n  xx[221] = xx[205] + xx[12] * (xx[218] * xx[200] + xx[224]);\n  xx[29] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 219, xx + 214);\n  xx[207] = xx[50] * xx[202];\n  xx[218] = xx[11] - xx[12] * (xx[34] + xx[45]);\n  xx[45] = xx[218] * xx[203];\n  xx[219] = xx[50] * xx[201];\n  xx[220] = xx[45] + xx[219];\n  xx[221] = xx[218] * xx[202];\n  xx[222] = xx[207];\n  xx[223] = - xx[220];\n  xx[224] = xx[221];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 222, xx + 225);\n  xx[222] = xx[12] * (xx[207] * xx[200] + xx[225]) - xx[218];\n  xx[223] = xx[12] * (xx[226] - xx[220] * xx[200]);\n  xx[224] = xx[50] + xx[12] * (xx[221] * xx[200] + xx[227]);\n  xx[207] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 222, xx + 214);\n  xx[220] = xx[44];\n  xx[221] = xx[44];\n  xx[222] = xx[44];\n  xx[223] = xx[217];\n  xx[224] = xx[29];\n  xx[225] = xx[207];\n  solveSymmetricPosDef(xx + 160, xx + 220, 6, 1, xx + 226, xx + 232);\n  xx[220] = state[18] * state[18];\n  xx[221] = state[19] * state[19];\n  xx[222] = xx[12] * (xx[220] + xx[221]);\n  xx[223] = xx[11] - xx[222];\n  xx[224] = xx[12] * (xx[208] - xx[209]);\n  xx[225] = xx[12] * (xx[212] + xx[211]);\n  xx[226] = xx[32] * xx[223];\n  xx[227] = xx[32] * xx[224];\n  xx[228] = xx[32] * xx[225];\n  xx[232] = xx[12] * (xx[209] + xx[208]);\n  xx[233] = xx[32] * xx[232];\n  xx[234] = xx[12] * (xx[221] + xx[141]);\n  xx[235] = xx[11] - xx[234];\n  xx[236] = xx[32] * xx[235];\n  xx[237] = state[18] * state[19];\n  xx[238] = state[16] * state[17];\n  xx[239] = xx[12] * (xx[237] - xx[238]);\n  xx[240] = xx[32] * xx[239];\n  xx[241] = xx[233];\n  xx[242] = xx[236];\n  xx[243] = xx[240];\n  xx[244] = pm_math_Vector3_dot_ra(xx + 223, xx + 241);\n  xx[245] = xx[32] * xx[213];\n  xx[246] = xx[12] * (xx[238] + xx[237]);\n  xx[247] = xx[32] * xx[246];\n  xx[248] = xx[12] * (xx[141] + xx[220]);\n  xx[141] = xx[11] - xx[248];\n  xx[249] = xx[32] * xx[141];\n  xx[250] = xx[245];\n  xx[251] = xx[247];\n  xx[252] = xx[249];\n  xx[253] = pm_math_Vector3_dot_ra(xx + 223, xx + 250);\n  xx[254] = xx[232];\n  xx[255] = xx[235];\n  xx[256] = xx[239];\n  xx[257] = pm_math_Vector3_dot_ra(xx + 254, xx + 250);\n  xx[258] = xx[213];\n  xx[259] = xx[246];\n  xx[260] = xx[141];\n  xx[261] = 6.750000000000001e-5;\n  xx[262] = pm_math_Vector3_dot_ra(xx + 223, xx + 226);\n  xx[263] = xx[244];\n  xx[264] = xx[253];\n  xx[265] = xx[44];\n  xx[266] = xx[44];\n  xx[267] = xx[44];\n  xx[268] = xx[244];\n  xx[269] = pm_math_Vector3_dot_ra(xx + 254, xx + 241);\n  xx[270] = xx[257];\n  xx[271] = xx[44];\n  xx[272] = xx[44];\n  xx[273] = xx[44];\n  xx[274] = xx[253];\n  xx[275] = xx[257];\n  xx[276] = pm_math_Vector3_dot_ra(xx + 258, xx + 250);\n  xx[277] = xx[44];\n  xx[278] = xx[44];\n  xx[279] = xx[44];\n  xx[280] = xx[44];\n  xx[281] = xx[44];\n  xx[282] = xx[44];\n  xx[283] = xx[261];\n  xx[284] = xx[44];\n  xx[285] = xx[44];\n  xx[286] = xx[44];\n  xx[287] = xx[44];\n  xx[288] = xx[44];\n  xx[289] = xx[44];\n  xx[290] = xx[261];\n  xx[291] = xx[44];\n  xx[292] = xx[44];\n  xx[293] = xx[44];\n  xx[294] = xx[44];\n  xx[295] = xx[44];\n  xx[296] = xx[44];\n  xx[297] = xx[80];\n  ii[0] = factorSymmetricPosDef(xx + 262, 6, xx + 298);\n  if (ii[0] != 0)\n    *derivErr = 1;\n  xx[241] = - xx[225];\n  xx[242] = xx[12] * (xx[238] - xx[237]);\n  xx[243] = xx[248] - xx[11];\n  xx[244] = xx[201] * xx[202];\n  xx[248] = xx[200] * xx[203];\n  xx[250] = xx[12] * (xx[244] - xx[248]);\n  xx[251] = xx[200] * xx[200];\n  xx[252] = xx[202] * xx[202];\n  xx[253] = xx[12] * (xx[251] + xx[252]) - xx[11];\n  xx[257] = xx[202] * xx[203];\n  xx[298] = xx[200] * xx[201];\n  xx[299] = xx[12] * (xx[257] + xx[298]);\n  xx[300] = xx[250];\n  xx[301] = xx[253];\n  xx[302] = xx[299];\n  xx[303] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 241, xx + 300);\n  xx[241] = xx[224];\n  xx[242] = xx[235];\n  xx[243] = xx[246];\n  xx[235] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 241, xx + 300);\n  xx[304] = xx[44];\n  xx[305] = xx[44];\n  xx[306] = xx[44];\n  xx[307] = xx[44];\n  xx[308] = xx[303];\n  xx[309] = xx[235];\n  solveSymmetricPosDef(xx + 262, xx + 304, 6, 1, xx + 310, xx + 316);\n  xx[241] = xx[51] * xx[203];\n  xx[242] = xx[40] * xx[203];\n  xx[243] = xx[40] * xx[202];\n  xx[304] = xx[42] + xx[243];\n  xx[305] = xx[241];\n  xx[306] = xx[242];\n  xx[307] = - xx[304];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 305, xx + 308);\n  xx[305] = xx[40] + xx[12] * (xx[241] * xx[200] + xx[308]);\n  xx[306] = xx[12] * (xx[242] * xx[200] + xx[309]) - xx[51];\n  xx[307] = xx[12] * (xx[310] - xx[304] * xx[200]);\n  xx[42] = xx[12] * (xx[131] + xx[220]) - xx[11];\n  xx[220] = xx[12] * (xx[237] + xx[238]);\n  xx[308] = xx[224];\n  xx[309] = xx[42];\n  xx[310] = xx[220];\n  xx[237] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 305, xx + 308);\n  xx[238] = xx[11] - xx[12] * (xx[52] + xx[34]);\n  xx[34] = xx[205] * xx[203];\n  xx[52] = xx[238] * xx[203];\n  xx[241] = xx[238] * xx[202];\n  xx[242] = xx[206] + xx[241];\n  xx[304] = xx[34];\n  xx[305] = xx[52];\n  xx[306] = - xx[242];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 304, xx + 311);\n  xx[304] = xx[238] + xx[12] * (xx[34] * xx[200] + xx[311]);\n  xx[305] = xx[12] * (xx[52] * xx[200] + xx[312]) - xx[205];\n  xx[306] = xx[12] * (xx[313] - xx[242] * xx[200]);\n  xx[34] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 304, xx + 308);\n  xx[52] = xx[12] * (xx[48] + xx[47]);\n  xx[47] = xx[50] * xx[203];\n  xx[48] = xx[52] * xx[203];\n  xx[206] = xx[52] * xx[202];\n  xx[242] = xx[219] + xx[206];\n  xx[304] = xx[47];\n  xx[305] = xx[48];\n  xx[306] = - xx[242];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 304, xx + 311);\n  xx[304] = xx[52] + xx[12] * (xx[47] * xx[200] + xx[311]);\n  xx[305] = xx[12] * (xx[48] * xx[200] + xx[312]) - xx[50];\n  xx[306] = xx[12] * (xx[313] - xx[242] * xx[200]);\n  xx[47] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 304, xx + 308);\n  xx[316] = xx[44];\n  xx[317] = xx[44];\n  xx[318] = xx[44];\n  xx[319] = xx[237];\n  xx[320] = xx[34];\n  xx[321] = xx[47];\n  solveSymmetricPosDef(xx + 160, xx + 316, 6, 1, xx + 322, xx + 328);\n  xx[304] = xx[225];\n  xx[305] = xx[239];\n  xx[306] = xx[141];\n  xx[48] = xx[201] * xx[203];\n  xx[141] = xx[200] * xx[202];\n  xx[219] = xx[12] * (xx[48] + xx[141]);\n  xx[242] = xx[12] * (xx[257] - xx[298]);\n  xx[307] = xx[203] * xx[203];\n  xx[311] = xx[12] * (xx[251] + xx[307]) - xx[11];\n  xx[316] = xx[219];\n  xx[317] = xx[242];\n  xx[318] = xx[311];\n  xx[312] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 304, xx + 316);\n  xx[304] = xx[222] - xx[11];\n  xx[305] = - xx[232];\n  xx[306] = xx[12] * (xx[212] - xx[211]);\n  xx[222] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 304, xx + 316);\n  xx[319] = xx[44];\n  xx[320] = xx[44];\n  xx[321] = xx[44];\n  xx[322] = xx[312];\n  xx[323] = xx[44];\n  xx[324] = xx[222];\n  solveSymmetricPosDef(xx + 262, xx + 319, 6, 1, xx + 328, xx + 334);\n  xx[304] = xx[325] * xx[217] + xx[326] * xx[29] + xx[327] * xx[207] + xx[332] *\n    xx[303] + xx[333] * xx[235];\n  xx[305] = xx[243] + xx[41];\n  xx[41] = xx[40] * xx[201];\n  xx[243] = xx[140] * xx[201];\n  xx[319] = - xx[305];\n  xx[320] = xx[41];\n  xx[321] = xx[243];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 319, xx + 322);\n  xx[319] = xx[12] * (xx[322] - xx[305] * xx[200]);\n  xx[320] = xx[140] + xx[12] * (xx[41] * xx[200] + xx[323]);\n  xx[321] = xx[12] * (xx[243] * xx[200] + xx[324]) - xx[40];\n  xx[41] = xx[12] * (xx[211] + xx[212]);\n  xx[211] = xx[12] * (xx[131] + xx[221]) - xx[11];\n  xx[322] = xx[41];\n  xx[323] = xx[239];\n  xx[324] = xx[211];\n  xx[131] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 319, xx + 322);\n  xx[212] = xx[241] + xx[33];\n  xx[33] = xx[238] * xx[201];\n  xx[221] = xx[49] * xx[201];\n  xx[319] = - xx[212];\n  xx[320] = xx[33];\n  xx[321] = xx[221];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 319, xx + 334);\n  xx[319] = xx[12] * (xx[334] - xx[212] * xx[200]);\n  xx[320] = xx[49] + xx[12] * (xx[33] * xx[200] + xx[335]);\n  xx[321] = xx[12] * (xx[221] * xx[200] + xx[336]) - xx[238];\n  xx[33] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 319, xx + 322);\n  xx[49] = xx[206] + xx[45];\n  xx[45] = xx[52] * xx[201];\n  xx[206] = xx[218] * xx[201];\n  xx[319] = - xx[49];\n  xx[320] = xx[45];\n  xx[321] = xx[206];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 319, xx + 334);\n  xx[319] = xx[12] * (xx[334] - xx[49] * xx[200]);\n  xx[320] = xx[218] + xx[12] * (xx[45] * xx[200] + xx[335]);\n  xx[321] = xx[12] * (xx[206] * xx[200] + xx[336]) - xx[52];\n  xx[45] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 319, xx + 322);\n  xx[334] = xx[44];\n  xx[335] = xx[44];\n  xx[336] = xx[44];\n  xx[337] = xx[131];\n  xx[338] = xx[33];\n  xx[339] = xx[45];\n  solveSymmetricPosDef(xx + 160, xx + 334, 6, 1, xx + 340, xx + 346);\n  xx[319] = xx[12] * (xx[209] - xx[208]);\n  xx[320] = xx[234] - xx[11];\n  xx[321] = - xx[246];\n  xx[49] = xx[201] * xx[201];\n  xx[206] = xx[12] * (xx[251] + xx[49]) - xx[11];\n  xx[208] = xx[12] * (xx[244] + xx[248]);\n  xx[209] = xx[12] * (xx[48] - xx[141]);\n  xx[334] = xx[206];\n  xx[335] = xx[208];\n  xx[336] = xx[209];\n  xx[212] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 319, xx + 334);\n  xx[319] = xx[223];\n  xx[320] = xx[232];\n  xx[321] = xx[213];\n  xx[218] = bb[0] ? xx[44] : pm_math_Vector3_dot_ra(xx + 319, xx + 334);\n  xx[337] = xx[44];\n  xx[338] = xx[44];\n  xx[339] = xx[44];\n  xx[340] = xx[212];\n  xx[341] = xx[218];\n  xx[342] = xx[44];\n  solveSymmetricPosDef(xx + 262, xx + 337, 6, 1, xx + 346, xx + 352);\n  xx[221] = xx[343] * xx[217] + xx[344] * xx[29] + xx[345] * xx[207] + xx[350] *\n    xx[303] + xx[351] * xx[235];\n  xx[232] = - xx[11];\n  xx[234] = bb[0] ? xx[44] : xx[232];\n  xx[241] = 0.04500000000000001;\n  xx[243] = xx[241] * xx[51];\n  xx[246] = xx[243] * xx[203];\n  xx[251] = xx[241] * xx[40];\n  xx[305] = xx[251] * xx[203];\n  xx[306] = xx[243] * xx[201] + xx[251] * xx[202];\n  xx[319] = - xx[246];\n  xx[320] = - xx[305];\n  xx[321] = xx[306];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 319, xx + 337);\n  xx[313] = xx[12] * (xx[337] - xx[246] * xx[200]) - xx[251];\n  xx[246] = xx[115] * state[5];\n  xx[251] = state[6] * xx[117];\n  xx[319] = xx[246] + xx[251];\n  xx[340] = xx[76];\n  xx[341] = xx[78];\n  xx[342] = xx[98];\n  xx[320] = xx[115] * state[4];\n  xx[321] = state[4] * xx[117];\n  xx[352] = - xx[319];\n  xx[353] = xx[320];\n  xx[354] = xx[321];\n  pm_math_Vector3_cross_ra(xx + 340, xx + 352, xx + 355);\n  xx[352] = bb[0] ? xx[44] : - (xx[313] + xx[12] * (state[3] * xx[319] + xx[355])\n    + xx[12] * (xx[18] - xx[17]));\n  xx[319] = xx[241] * xx[205];\n  xx[205] = xx[319] * xx[203];\n  xx[353] = xx[241] * xx[238];\n  xx[238] = xx[353] * xx[203];\n  xx[354] = xx[319] * xx[201] + xx[353] * xx[202];\n  xx[358] = - xx[205];\n  xx[359] = - xx[238];\n  xx[360] = xx[354];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 358, xx + 361);\n  xx[358] = xx[114] * state[5];\n  xx[359] = xx[114] * state[4];\n  xx[360] = xx[251] - xx[359];\n  xx[251] = state[5] * xx[117];\n  xx[364] = - xx[358];\n  xx[365] = - xx[360];\n  xx[366] = xx[251];\n  pm_math_Vector3_cross_ra(xx + 340, xx + 364, xx + 367);\n  xx[364] = bb[0] ? xx[44] : - (xx[12] * (xx[361] - xx[205] * xx[200]) - xx[353]\n    + xx[117] + xx[12] * (xx[367] + xx[358] * state[3]) - xx[15] + xx[11]);\n  xx[15] = xx[241] * xx[50];\n  xx[50] = xx[15] * xx[203];\n  xx[205] = xx[241] * xx[52];\n  xx[52] = xx[205] * xx[203];\n  xx[353] = xx[15] * xx[201] + xx[205] * xx[202];\n  xx[370] = - xx[50];\n  xx[371] = - xx[52];\n  xx[372] = xx[353];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 370, xx + 373);\n  xx[358] = xx[114] * state[6];\n  xx[365] = xx[115] * state[6];\n  xx[366] = xx[246] - xx[359];\n  xx[370] = - xx[358];\n  xx[371] = xx[365];\n  xx[372] = - xx[366];\n  pm_math_Vector3_cross_ra(xx + 340, xx + 370, xx + 376);\n  xx[246] = bb[0] ? xx[44] : - (xx[12] * (xx[373] - xx[50] * xx[200]) - xx[205]\n    + xx[12] * (xx[376] + xx[358] * state[3]) - xx[115]);\n  xx[379] = xx[234];\n  xx[380] = xx[44];\n  xx[381] = xx[44];\n  xx[382] = xx[352];\n  xx[383] = xx[364];\n  xx[384] = xx[246];\n  solveSymmetricPosDef(xx + 160, xx + 379, 6, 1, xx + 385, xx + 391);\n  xx[50] = bb[0] ? xx[44] : xx[11];\n  xx[205] = 0.0225;\n  xx[340] = xx[205] * state[19];\n  xx[341] = xx[340] * state[16];\n  xx[342] = xx[205] * state[17];\n  xx[358] = bb[0] ? xx[44] : xx[12] * (xx[341] - xx[342] * state[18]);\n  xx[359] = xx[205] * state[18];\n  xx[370] = xx[340] * state[19];\n  xx[371] = bb[0] ? xx[44] : xx[205] - xx[12] * (xx[359] * state[18] + xx[370]);\n  xx[379] = xx[50];\n  xx[380] = xx[44];\n  xx[381] = xx[44];\n  xx[382] = xx[358];\n  xx[383] = xx[371];\n  xx[384] = xx[44];\n  solveSymmetricPosDef(xx + 262, xx + 379, 6, 1, xx + 391, xx + 397);\n  xx[372] = xx[388] * xx[217] + xx[389] * xx[29] + xx[390] * xx[207] + xx[395] *\n    xx[303] + xx[396] * xx[235];\n  xx[379] = xx[12] * (xx[338] - xx[305] * xx[200]);\n  xx[305] = bb[0] ? xx[44] : - (xx[379] + xx[12] * (xx[356] - xx[320] * state[3])\n    + xx[69] - xx[117] + xx[243] - xx[11]);\n  xx[69] = bb[0] ? xx[44] : - (xx[12] * (xx[362] - xx[238] * xx[200]) + xx[319]\n    + xx[12] * (state[3] * xx[360] + xx[368]) + xx[26]);\n  xx[117] = bb[0] ? xx[44] : - (xx[12] * (xx[374] - xx[52] * xx[200]) + xx[15] +\n    xx[12] * (xx[377] - xx[365] * state[3]) - xx[114]);\n  xx[397] = xx[44];\n  xx[398] = xx[234];\n  xx[399] = xx[44];\n  xx[400] = xx[305];\n  xx[401] = xx[69];\n  xx[402] = xx[117];\n  solveSymmetricPosDef(xx + 160, xx + 397, 6, 1, xx + 403, xx + 409);\n  xx[15] = bb[0] ? xx[44] : xx[12] * (xx[370] + xx[342] * state[17]) - xx[205];\n  xx[52] = bb[0] ? xx[44] : xx[12] * (xx[341] + xx[359] * state[17]);\n  xx[397] = xx[44];\n  xx[398] = xx[50];\n  xx[399] = xx[44];\n  xx[400] = xx[15];\n  xx[401] = xx[52];\n  xx[402] = xx[44];\n  solveSymmetricPosDef(xx + 262, xx + 397, 6, 1, xx + 409, xx + 415);\n  xx[238] = xx[406] * xx[217] + xx[407] * xx[29] + xx[408] * xx[207] + xx[413] *\n    xx[303] + xx[414] * xx[235];\n  xx[319] = xx[12] * (xx[339] + xx[306] * xx[200]);\n  xx[306] = bb[0] ? xx[44] : - (xx[319] + xx[115] + xx[12] * (xx[357] - xx[321] *\n    state[3]) - xx[100]);\n  xx[115] = bb[0] ? xx[44] : - (xx[12] * (xx[363] + xx[354] * xx[200]) + xx[12] *\n    (xx[369] - xx[251] * state[3]) + xx[114] + xx[99]);\n  xx[114] = bb[0] ? xx[44] : - (xx[12] * (xx[375] + xx[353] * xx[200]) + xx[12] *\n    (state[3] * xx[366] + xx[378]));\n  xx[365] = xx[44];\n  xx[366] = xx[44];\n  xx[367] = xx[234];\n  xx[368] = xx[306];\n  xx[369] = xx[115];\n  xx[370] = xx[114];\n  solveSymmetricPosDef(xx + 160, xx + 365, 6, 1, xx + 373, xx + 397);\n  xx[251] = bb[0] ? xx[44] : - (xx[12] * (xx[342] * state[16] + xx[340] * state\n    [18]));\n  xx[320] = bb[0] ? xx[44] : xx[12] * (xx[340] * state[17] - xx[359] * state[16]);\n  xx[337] = xx[44];\n  xx[338] = xx[44];\n  xx[339] = xx[50];\n  xx[340] = xx[251];\n  xx[341] = xx[320];\n  xx[342] = xx[44];\n  solveSymmetricPosDef(xx + 262, xx + 337, 6, 1, xx + 365, xx + 397);\n  xx[321] = xx[376] * xx[217] + xx[377] * xx[29] + xx[378] * xx[207] + xx[369] *\n    xx[303] + xx[370] * xx[235];\n  xx[328] = xx[343] * xx[237] + xx[344] * xx[34] + xx[345] * xx[47] + xx[349] *\n    xx[312] + xx[351] * xx[222];\n  xx[329] = xx[388] * xx[237] + xx[389] * xx[34] + xx[390] * xx[47] + xx[394] *\n    xx[312] + xx[396] * xx[222];\n  xx[330] = xx[406] * xx[237] + xx[407] * xx[34] + xx[408] * xx[47] + xx[412] *\n    xx[312] + xx[414] * xx[222];\n  xx[332] = xx[376] * xx[237] + xx[377] * xx[34] + xx[378] * xx[47] + xx[368] *\n    xx[312] + xx[370] * xx[222];\n  xx[337] = xx[388] * xx[131] + xx[389] * xx[33] + xx[390] * xx[45] + xx[394] *\n    xx[212] + xx[395] * xx[218];\n  xx[338] = xx[406] * xx[131] + xx[407] * xx[33] + xx[408] * xx[45] + xx[412] *\n    xx[212] + xx[413] * xx[218];\n  xx[339] = xx[376] * xx[131] + xx[377] * xx[33] + xx[378] * xx[45] + xx[368] *\n    xx[212] + xx[369] * xx[218];\n  xx[340] = xx[403] * xx[234] + xx[406] * xx[352] + xx[407] * xx[364] + xx[408] *\n    xx[246] + xx[409] * xx[50] + xx[412] * xx[358] + xx[413] * xx[371];\n  xx[341] = xx[373] * xx[234] + xx[376] * xx[352] + xx[377] * xx[364] + xx[378] *\n    xx[246] + xx[365] * xx[50] + xx[368] * xx[358] + xx[369] * xx[371];\n  xx[342] = xx[374] * xx[234] + xx[376] * xx[305] + xx[377] * xx[69] + xx[378] *\n    xx[117] + xx[366] * xx[50] + xx[368] * xx[15] + xx[369] * xx[52];\n  xx[414] = xx[229] * xx[217] + xx[230] * xx[29] + xx[231] * xx[207] + xx[314] *\n    xx[303] + xx[315] * xx[235];\n  xx[415] = xx[304];\n  xx[416] = xx[221];\n  xx[417] = xx[372];\n  xx[418] = xx[238];\n  xx[419] = xx[321];\n  xx[420] = xx[304];\n  xx[421] = xx[325] * xx[237] + xx[326] * xx[34] + xx[327] * xx[47] + xx[331] *\n    xx[312] + xx[333] * xx[222];\n  xx[422] = xx[328];\n  xx[423] = xx[329];\n  xx[424] = xx[330];\n  xx[425] = xx[332];\n  xx[426] = xx[221];\n  xx[427] = xx[328];\n  xx[428] = xx[343] * xx[131] + xx[344] * xx[33] + xx[345] * xx[45] + xx[349] *\n    xx[212] + xx[350] * xx[218];\n  xx[429] = xx[337];\n  xx[430] = xx[338];\n  xx[431] = xx[339];\n  xx[432] = xx[372];\n  xx[433] = xx[329];\n  xx[434] = xx[337];\n  xx[435] = xx[385] * xx[234] + xx[388] * xx[352] + xx[389] * xx[364] + xx[390] *\n    xx[246] + xx[391] * xx[50] + xx[394] * xx[358] + xx[395] * xx[371];\n  xx[436] = xx[340];\n  xx[437] = xx[341];\n  xx[438] = xx[238];\n  xx[439] = xx[330];\n  xx[440] = xx[338];\n  xx[441] = xx[340];\n  xx[442] = xx[404] * xx[234] + xx[406] * xx[305] + xx[407] * xx[69] + xx[408] *\n    xx[117] + xx[410] * xx[50] + xx[412] * xx[15] + xx[413] * xx[52];\n  xx[443] = xx[342];\n  xx[444] = xx[321];\n  xx[445] = xx[332];\n  xx[446] = xx[339];\n  xx[447] = xx[341];\n  xx[448] = xx[342];\n  xx[449] = xx[375] * xx[234] + xx[376] * xx[306] + xx[377] * xx[115] + xx[378] *\n    xx[114] + xx[367] * xx[50] + xx[368] * xx[251] + xx[369] * xx[320];\n  ii[0] = bb[0] ? 0 : 1;\n  xx[221] = xx[12] * (xx[21] + xx[20]);\n  xx[20] = state[3] * state[3];\n  xx[21] = xx[12] * (xx[20] + xx[68]) - xx[11];\n  xx[68] = xx[221] * state[10] - xx[21] * state[12];\n  xx[229] = xx[21] * state[11] - xx[19] * state[10];\n  xx[230] = xx[19] * state[12] - xx[221] * state[11];\n  xx[231] = xx[230] * state[11] - xx[68] * state[10];\n  xx[238] = xx[12] * (xx[17] + xx[18]);\n  xx[17] = xx[91] * state[10] - xx[238] * state[12];\n  xx[18] = xx[12] * (xx[20] + xx[13]) - xx[11];\n  xx[13] = xx[238] * state[11] - xx[18] * state[10];\n  xx[304] = xx[18] * state[12] - xx[91] * state[11];\n  xx[314] = xx[304] * state[11] - xx[17] * state[10];\n  xx[315] = xx[12] * (xx[20] + xx[14]) - xx[11];\n  xx[14] = xx[315] * state[10] - xx[99] * state[12];\n  xx[20] = xx[12] * (xx[71] + xx[90]);\n  xx[321] = xx[99] * state[11] - xx[20] * state[10];\n  xx[325] = xx[20] * state[12] - xx[315] * state[11];\n  xx[326] = xx[325] * state[11] - xx[14] * state[10];\n  xx[337] = xx[68] * state[12] - xx[229] * state[11];\n  xx[338] = xx[229] * state[10] - xx[230] * state[12];\n  xx[339] = xx[231];\n  xx[340] = xx[17] * state[12] - xx[13] * state[11];\n  xx[341] = xx[13] * state[10] - xx[304] * state[12];\n  xx[342] = xx[314];\n  xx[343] = xx[14] * state[12] - xx[321] * state[11];\n  xx[344] = xx[321] * state[10] - xx[325] * state[12];\n  xx[345] = xx[326];\n  pm_math_Matrix3x3_compose_ra(xx + 337, xx + 54, xx + 380);\n  xx[389] = xx[21];\n  xx[390] = xx[19];\n  xx[391] = xx[221];\n  xx[392] = xx[238];\n  xx[393] = xx[18];\n  xx[394] = xx[91];\n  xx[395] = xx[99];\n  xx[396] = xx[20];\n  xx[397] = xx[315];\n  xx[13] = xx[140] * inputDot[0];\n  xx[14] = xx[13] * xx[13];\n  xx[17] = xx[12] * xx[39] * inputDot[0] + inputDot[1];\n  xx[18] = xx[17] * xx[17];\n  xx[20] = xx[51] * inputDot[0];\n  xx[21] = xx[20] * xx[17];\n  xx[327] = xx[20];\n  xx[328] = xx[17];\n  xx[329] = xx[13];\n  xx[330] = xx[51];\n  xx[331] = xx[40];\n  xx[332] = xx[140];\n  pm_math_Vector3_cross_ra(xx + 327, xx + 330, xx + 346);\n  xx[39] = inputDot[0] * xx[348];\n  xx[68] = xx[13] * xx[20];\n  xx[140] = inputDot[0] * xx[347];\n  xx[221] = xx[20] * xx[20];\n  xx[229] = xx[13] * xx[17];\n  xx[230] = inputDot[0] * xx[346];\n  xx[398] = - (xx[14] + xx[18]);\n  xx[399] = xx[21] + xx[39];\n  xx[400] = xx[68] - xx[140];\n  xx[401] = xx[21] - xx[39];\n  xx[402] = - (xx[14] + xx[221]);\n  xx[403] = xx[229] + xx[230];\n  xx[404] = xx[68] + xx[140];\n  xx[405] = xx[229] - xx[230];\n  xx[406] = - (xx[18] + xx[221]);\n  pm_math_Matrix3x3_compose_ra(xx + 54, xx + 398, xx + 450);\n  pm_math_Matrix3x3_compose_ra(xx + 389, xx + 450, xx + 54);\n  xx[389] = xx[206];\n  xx[390] = xx[250];\n  xx[391] = xx[219];\n  xx[392] = xx[208];\n  xx[393] = xx[253];\n  xx[394] = xx[242];\n  xx[395] = xx[209];\n  xx[396] = xx[299];\n  xx[397] = xx[311];\n  pm_math_Quaternion_inverseXform_ra(xx + 196, xx + 4, xx + 330);\n  pm_math_Matrix3x3_postCross_ra(xx + 389, xx + 330, xx + 398);\n  pm_math_Matrix3x3_postCross_ra(xx + 398, xx + 327, xx + 389);\n  xx[327] = xx[381] + xx[55] + xx[12] * xx[390];\n  xx[328] = xx[384] + xx[58] + xx[12] * xx[393];\n  xx[329] = xx[387] + xx[61] + xx[12] * xx[396];\n  xx[14] = xx[41] * state[23] - xx[204] * state[25];\n  xx[18] = xx[204] * state[24] - xx[224] * state[23];\n  xx[21] = xx[239] * state[23] - xx[210] * state[25];\n  xx[39] = xx[210] * state[24] - xx[42] * state[23];\n  xx[68] = xx[211] * state[23] - xx[213] * state[25];\n  xx[140] = xx[213] * state[24] - xx[220] * state[23];\n  xx[346] = xx[14] * state[25] - xx[18] * state[24];\n  xx[347] = xx[21] * state[25] - xx[39] * state[24];\n  xx[348] = xx[68] * state[25] - xx[140] * state[24];\n  xx[204] = - state[17];\n  xx[206] = - state[18];\n  xx[208] = - state[19];\n  xx[349] = xx[204];\n  xx[350] = xx[206];\n  xx[351] = xx[208];\n  xx[210] = state[18] * state[24];\n  xx[213] = state[19] * state[25];\n  xx[219] = xx[210] + xx[213];\n  xx[221] = state[17] * state[24];\n  xx[229] = state[17] * state[25];\n  xx[353] = xx[219];\n  xx[354] = - xx[221];\n  xx[355] = - xx[229];\n  pm_math_Vector3_cross_ra(xx + 349, xx + 353, xx + 359);\n  xx[353] = xx[12] * (xx[359] - state[16] * xx[219]);\n  xx[354] = state[25] + xx[12] * (xx[221] * state[16] + xx[360]);\n  xx[355] = xx[12] * (xx[229] * state[16] + xx[361]) - state[24];\n  xx[219] = xx[330] + xx[20];\n  xx[221] = xx[219] * xx[202];\n  xx[229] = xx[332] + xx[13];\n  xx[13] = xx[229] * xx[203];\n  xx[230] = xx[219] * xx[201];\n  xx[238] = xx[13] + xx[230];\n  xx[242] = xx[229] * xx[202];\n  xx[359] = xx[221];\n  xx[360] = - xx[238];\n  xx[361] = xx[242];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 359, xx + 365);\n  xx[359] = xx[12] * (xx[221] * xx[200] + xx[365]) - xx[229];\n  xx[360] = xx[12] * (xx[366] - xx[238] * xx[200]);\n  xx[361] = xx[219] + xx[12] * (xx[242] * xx[200] + xx[367]);\n  xx[221] = xx[382] + xx[56] + xx[12] * xx[391];\n  xx[238] = xx[385] + xx[59] + xx[12] * xx[394];\n  xx[242] = xx[388] + xx[62] + xx[12] * xx[397];\n  xx[365] = xx[221];\n  xx[366] = xx[238];\n  xx[367] = xx[242];\n  xx[250] = xx[224] * state[25] - xx[41] * state[24];\n  xx[41] = xx[42] * state[25] - xx[239] * state[24];\n  xx[42] = xx[220] * state[25] - xx[211] * state[24];\n  xx[368] = xx[18] * state[23] - xx[250] * state[25];\n  xx[369] = xx[39] * state[23] - xx[41] * state[25];\n  xx[370] = xx[140] * state[23] - xx[42] * state[25];\n  xx[18] = state[18] * state[23];\n  xx[39] = state[17] * state[23];\n  xx[140] = xx[213] + xx[39];\n  xx[211] = state[18] * state[25];\n  xx[372] = - xx[18];\n  xx[373] = xx[140];\n  xx[374] = - xx[211];\n  pm_math_Vector3_cross_ra(xx + 349, xx + 372, xx + 375);\n  xx[372] = xx[12] * (xx[18] * state[16] + xx[375]) - state[25];\n  xx[373] = xx[12] * (xx[376] - state[16] * xx[140]);\n  xx[374] = state[23] + xx[12] * (xx[211] * state[16] + xx[377]);\n  xx[18] = xx[331] + xx[17];\n  xx[140] = xx[219] * xx[203];\n  xx[211] = xx[18] * xx[203];\n  xx[213] = xx[18] * xx[202];\n  xx[220] = xx[230] + xx[213];\n  xx[375] = xx[140];\n  xx[376] = xx[211];\n  xx[377] = - xx[220];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 375, xx + 398);\n  xx[375] = xx[18] + xx[12] * (xx[140] * xx[200] + xx[398]);\n  xx[376] = xx[12] * (xx[211] * xx[200] + xx[399]) - xx[219];\n  xx[377] = xx[12] * (xx[400] - xx[220] * xx[200]);\n  xx[396] = xx[380] + xx[54] + xx[12] * xx[389];\n  xx[397] = xx[383] + xx[57] + xx[12] * xx[392];\n  xx[398] = xx[386] + xx[60] + xx[12] * xx[395];\n  xx[54] = xx[250] * state[24] - xx[14] * state[23];\n  xx[14] = xx[41] * state[24] - xx[21] * state[23];\n  xx[21] = xx[42] * state[24] - xx[68] * state[23];\n  xx[55] = xx[54];\n  xx[56] = xx[14];\n  xx[57] = xx[21];\n  xx[41] = state[19] * state[23];\n  xx[42] = state[19] * state[24];\n  xx[58] = xx[39] + xx[210];\n  xx[59] = - xx[41];\n  xx[60] = - xx[42];\n  xx[61] = xx[58];\n  pm_math_Vector3_cross_ra(xx + 349, xx + 59, xx + 380);\n  xx[59] = state[24] + xx[12] * (xx[41] * state[16] + xx[380]);\n  xx[60] = xx[12] * (xx[42] * state[16] + xx[381]) - state[23];\n  xx[61] = xx[12] * (xx[382] - state[16] * xx[58]);\n  xx[39] = xx[213] + xx[13];\n  xx[13] = xx[18] * xx[201];\n  xx[41] = xx[229] * xx[201];\n  xx[349] = - xx[39];\n  xx[350] = xx[13];\n  xx[351] = xx[41];\n  pm_math_Vector3_cross_ra(xx + 201, xx + 349, xx + 380);\n  xx[349] = xx[12] * (xx[380] - xx[39] * xx[200]);\n  xx[350] = xx[229] + xx[12] * (xx[13] * xx[200] + xx[381]);\n  xx[351] = xx[12] * (xx[41] * xx[200] + xx[382]) - xx[18];\n  pm_math_Matrix3x3_xform_ra(xx + 337, xx + 118, xx + 380);\n  xx[337] = - (xx[110] * xx[452]);\n  xx[338] = - (xx[110] * xx[455]);\n  xx[339] = - (xx[110] * xx[458]);\n  pm_math_Quaternion_xform_ra(xx + 136, xx + 337, xx + 340);\n  xx[337] = xx[109];\n  xx[338] = xx[113];\n  xx[339] = xx[130];\n  xx[13] = xx[110] * xx[20];\n  xx[18] = xx[13] * xx[38];\n  xx[20] = xx[110] * xx[17];\n  xx[17] = xx[20] * xx[38];\n  xx[39] = xx[13] * xx[28] + xx[20] * xx[37];\n  xx[343] = xx[18];\n  xx[344] = xx[17];\n  xx[345] = - xx[39];\n  pm_math_Vector3_cross_ra(xx + 337, xx + 343, xx + 383);\n  xx[343] = xx[12] * (xx[383] - xx[18] * xx[31]) - xx[20];\n  xx[344] = xx[12] * (xx[384] - xx[17] * xx[31]) + xx[13];\n  xx[345] = xx[12] * (xx[385] + xx[31] * xx[39]);\n  pm_math_Vector3_cross_ra(xx + 4, xx + 343, xx + 383);\n  pm_math_Quaternion_xform_ra(xx + 136, xx + 383, xx + 343);\n  xx[383] = pm_math_Vector3_dot_ra(xx + 327, xx + 214) + pm_math_Vector3_dot_ra\n    (xx + 346, xx + 300) + pm_math_Vector3_dot_ra(xx + 353, xx + 359) * xx[12];\n  xx[384] = pm_math_Vector3_dot_ra(xx + 365, xx + 308) + pm_math_Vector3_dot_ra\n    (xx + 368, xx + 316) + pm_math_Vector3_dot_ra(xx + 372, xx + 375) * xx[12];\n  xx[385] = pm_math_Vector3_dot_ra(xx + 396, xx + 322) + pm_math_Vector3_dot_ra\n    (xx + 55, xx + 334) + pm_math_Vector3_dot_ra(xx + 59, xx + 349) * xx[12];\n  xx[386] = xx[205] * xx[54] - (xx[380] + xx[231] + xx[340] + xx[12] * xx[343] -\n    xx[241] * xx[221]);\n  xx[387] = xx[205] * xx[14] - (xx[381] + xx[314] + xx[341] + xx[12] * xx[344] -\n    xx[241] * xx[238]);\n  xx[388] = xx[205] * xx[21] - (xx[382] + xx[326] + xx[342] + xx[12] * xx[345] -\n    xx[241] * xx[242]);\n  zeroMajor(1, 6, ii + 0, xx + 383);\n  pm_math_Vector3_cross_ra(xx + 4, xx + 118, xx + 54);\n  pm_math_Vector3_cross_ra(xx + 4, xx + 54, xx + 57);\n  pm_math_Quaternion_inverseXform_ra(xx + 196, xx + 57, xx + 60);\n  xx[13] = xx[12] * xx[36] * xx[36];\n  xx[14] = (xx[11] - xx[13]) * inputDot[0];\n  xx[17] = xx[110] * xx[14];\n  xx[18] = xx[12] * xx[27] * xx[36];\n  xx[20] = xx[18] * inputDot[0];\n  xx[21] = xx[332] + xx[20];\n  xx[27] = xx[332] + xx[21];\n  xx[340] = xx[11];\n  xx[341] = xx[44];\n  xx[342] = xx[44];\n  xx[343] = xx[44];\n  xx[344] = xx[44];\n  xx[345] = xx[44];\n  xx[346] = xx[232];\n  pm_math_Quaternion_xform_ra(xx + 136, xx + 118, xx + 57);\n  xx[36] = state[0] + xx[22];\n  xx[39] = 6.938893903907228e-18;\n  xx[41] = xx[39] * xx[202];\n  xx[42] = xx[39] * xx[201];\n  xx[68] = xx[12] * (xx[90] - xx[71]);\n  xx[71] = state[1] - xx[68];\n  xx[90] = state[2] - xx[101] + xx[11];\n  xx[372] = - xx[202];\n  xx[373] = - xx[203];\n  xx[374] = xx[200];\n  xx[375] = xx[201];\n  xx[376] = xx[57] + xx[36] - xx[12] * (xx[41] * xx[200] + xx[42] * xx[203]);\n  xx[377] = xx[12] * (xx[42] * xx[200] - xx[41] * xx[203]) + xx[58] + xx[71];\n  xx[378] = xx[12] * (xx[42] * xx[201] + xx[41] * xx[202]) - xx[39] + xx[59] +\n    xx[90];\n  bb[1] = sm_core_compiler_computeProximityInfoBrickCylinder(\n    simulation_b048d748_1_geometry_3(NULL), simulation_b048d748_1_geometry_2\n    (NULL), (pm_math_Transform3 *)(xx + 340), (pm_math_Transform3 *)(xx + 372),\n    xx + 41, (pm_math_Vector3 *)(xx + 57), (pm_math_Vector3 *)(xx + 213),\n    (pm_math_Vector3 *)(xx + 219), (pm_math_Vector3 *)(xx + 229));\n  xx[389] = xx[44];\n  xx[390] = xx[44];\n  xx[391] = xx[11];\n  xx[392] = xx[44];\n  xx[393] = xx[44];\n  xx[394] = xx[44];\n  xx[395] = - xx[39];\n  xx[39] = xx[330] + xx[14];\n  xx[42] = xx[331] + inputDot[1];\n  xx[299] = state[7];\n  xx[300] = state[8];\n  xx[301] = state[9];\n  pm_math_Quaternion_inverseXform_ra(xx + 136, xx + 299, xx + 314);\n  xx[109] = xx[314] + state[11];\n  xx[113] = xx[315] - state[10];\n  xx[299] = xx[54] + xx[109];\n  xx[300] = xx[55] + xx[113];\n  xx[301] = xx[56] + xx[316];\n  pm_math_Quaternion_inverseXform_ra(xx + 196, xx + 299, xx + 54);\n  xx[130] = xx[110] * inputDot[1];\n  xx[365] = xx[39];\n  xx[366] = xx[42];\n  xx[367] = xx[21];\n  xx[368] = xx[54] - xx[130];\n  xx[369] = xx[55] + xx[17];\n  xx[370] = xx[56];\n  xx[54] = 1000.0;\n  xx[55] = 1.0e-4;\n  xx[56] = 0.3;\n  xx[140] = 0.2119573811760597;\n  xx[205] = 9.126024771145405e-4;\n  sm_core_compiler_computeSpatialContactWrenches(\n    0, 1, bb[1], xx + 41, (const pm_math_Vector3 *)(xx + 57), (const\n    pm_math_Vector3 *)(xx + 213), (const pm_math_Vector3 *)(xx + 219), (const\n    pm_math_Vector3 *)(xx + 229),\n    (const pm_math_Transform3 *)(xx + 340), (const pm_math_Transform3 *)(xx +\n    389), (const pm_math_Transform3 *)(xx + 340), (const pm_math_Transform3 *)\n    (xx + 372), NULL, (const pm_math_SpatialVector *)(xx + 365),\n    0, 1, 1.0e6, xx[54], xx[55], xx[56], xx[140], xx[205], NULL, NULL,\n    NULL, (pm_math_SpatialVector *)(xx + 396));\n  xx[41] = inputDot[0] * inputDot[1];\n  xx[57] = xx[18] * xx[41];\n  xx[18] = - xx[30];\n  xx[30] = sin(xx[18]);\n  xx[58] = xx[11] - xx[12] * xx[30] * xx[30];\n  xx[213] = xx[32] * (xx[60] - xx[17] * xx[27] - xx[110] * inputDdot[1]) - xx\n    [399];\n  xx[214] = xx[32] * (xx[61] - xx[130] * xx[27] - xx[110] * xx[57] + xx[110] *\n                      xx[58] * inputDdot[0]) - xx[400];\n  xx[215] = xx[32] * (xx[62] + xx[17] * (xx[330] + xx[39]) + xx[130] * (xx[331]\n    + xx[42])) - (xx[401] + input[4]);\n  pm_math_Quaternion_xform_ra(xx + 196, xx + 213, xx + 59);\n  xx[372] = xx[73];\n  xx[373] = xx[76];\n  xx[374] = xx[78];\n  xx[375] = xx[98];\n  xx[376] = xx[36] - xx[22];\n  xx[377] = xx[68] + xx[71];\n  xx[378] = xx[101] - xx[11] + xx[90];\n  bb[1] = sm_core_compiler_computeProximityInfoCxpolyBrick(\n    simulation_b048d748_1_geometry_0(NULL), simulation_b048d748_1_geometry_3\n    (NULL), (pm_math_Transform3 *)(xx + 372), (pm_math_Transform3 *)(xx + 340),\n    xx + 17, (pm_math_Vector3 *)(xx + 213), (pm_math_Vector3 *)(xx + 219),\n    (pm_math_Vector3 *)(xx + 229), (pm_math_Vector3 *)(xx + 299));\n  xx[365] = state[10];\n  xx[366] = state[11];\n  xx[367] = state[12];\n  xx[368] = xx[109];\n  xx[369] = xx[113];\n  xx[370] = xx[316];\n  sm_core_compiler_computeSpatialContactWrenches(\n    0, 1, bb[1], xx + 17, (const pm_math_Vector3 *)(xx + 219), (const\n    pm_math_Vector3 *)(xx + 213), (const pm_math_Vector3 *)(xx + 299), (const\n    pm_math_Vector3 *)(xx + 229),\n    (const pm_math_Transform3 *)(xx + 340), (const pm_math_Transform3 *)(xx +\n    340), (const pm_math_Transform3 *)(xx + 340), (const pm_math_Transform3 *)\n    (xx + 372), NULL, (const pm_math_SpatialVector *)(xx + 365),\n    0, 1, 1300.0, xx[54], xx[55], 0.4, 0.3166621126427172, 9.173266606314467e-4,\n    NULL, NULL,\n    NULL, (pm_math_SpatialVector *)(xx + 389));\n  xx[213] = xx[109];\n  xx[214] = xx[113];\n  xx[215] = xx[316];\n  pm_math_Vector3_cross_ra(xx + 4, xx + 213, xx + 219);\n  xx[213] = - xx[314];\n  xx[214] = - xx[315];\n  xx[215] = - xx[316];\n  pm_math_Vector3_cross_ra(xx + 4, xx + 213, xx + 229);\n  xx[17] = xx[219] + xx[229];\n  xx[27] = xx[220] + xx[230];\n  xx[213] = xx[17];\n  xx[214] = xx[27];\n  xx[215] = xx[221] + xx[231];\n  pm_math_Matrix3x3_xform_ra(xx + 81, xx + 213, xx + 299);\n  xx[62] = xx[59] - xx[392] + xx[299];\n  xx[68] = xx[60] - xx[393] + xx[300];\n  xx[81] = xx[62];\n  xx[82] = xx[68];\n  xx[83] = xx[61] - xx[394] + xx[301];\n  xx[73] = pm_math_Vector3_dot_ra(xx + 23, xx + 81);\n  xx[76] = pm_math_Vector3_dot_ra(xx + 92, xx + 81);\n  xx[78] = pm_math_Vector3_dot_ra(xx + 103, xx + 81);\n  pm_math_Vector3_cross_ra(xx + 4, xx + 4, xx + 81);\n  xx[84] = xx[39];\n  xx[85] = xx[42];\n  xx[86] = xx[21];\n  xx[87] = xx[79] * xx[39];\n  xx[88] = xx[79] * xx[42];\n  xx[89] = xx[80] * xx[21];\n  pm_math_Vector3_cross_ra(xx + 84, xx + 87, xx + 299);\n  xx[84] = xx[14];\n  xx[85] = inputDot[1];\n  xx[86] = xx[20];\n  pm_math_Vector3_cross_ra(xx + 330, xx + 84, xx + 87);\n  xx[84] = xx[299] - xx[396] + xx[79] * (xx[87] - xx[57] + xx[58] * inputDdot[0]);\n  xx[85] = xx[300] - xx[397] + xx[79] * (xx[88] + inputDdot[1]);\n  xx[86] = xx[301] - xx[398] + xx[80] * (xx[89] - xx[41] * (xx[13] - xx[11]) -\n    xx[12] * cos(xx[18]) * xx[30] * inputDdot[0]);\n  pm_math_Quaternion_xform_ra(xx + 196, xx + 84, xx + 87);\n  pm_math_Vector3_cross_ra(xx + 118, xx + 59, xx + 84);\n  xx[325] = - xx[121];\n  xx[326] = - xx[124];\n  xx[327] = - xx[127];\n  xx[328] = - xx[122];\n  xx[329] = - xx[125];\n  xx[330] = - xx[128];\n  xx[331] = xx[133];\n  xx[332] = xx[134];\n  xx[333] = xx[135];\n  pm_math_Matrix3x3_xform_ra(xx + 325, xx + 213, xx + 57);\n  xx[13] = xx[81] - xx[389] + xx[87] + xx[84] + xx[57];\n  xx[14] = xx[82] - xx[390] + xx[88] + xx[85] + xx[58] + xx[62];\n  xx[18] = xx[83] - xx[391] + xx[89] + xx[86] + xx[59];\n  xx[57] = - xx[73];\n  xx[58] = - xx[76];\n  xx[59] = - xx[78];\n  xx[60] = xx[68] - xx[13];\n  xx[61] = - xx[14];\n  xx[62] = - xx[18];\n  solveSymmetricPosDef(xx + 160, xx + 57, 6, 1, xx + 81, xx + 365);\n  pm_math_Matrix3x3_xform_ra(xx + 325, xx + 23, xx + 57);\n  pm_math_Matrix3x3_xform_ra(xx + 325, xx + 92, xx + 23);\n  pm_math_Matrix3x3_xform_ra(xx + 325, xx + 103, xx + 60);\n  xx[450] = xx[57];\n  xx[451] = xx[23];\n  xx[452] = xx[60];\n  xx[453] = xx[35];\n  xx[454] = xx[43];\n  xx[455] = xx[46];\n  xx[456] = xx[58];\n  xx[457] = xx[24];\n  xx[458] = xx[61];\n  xx[459] = xx[154] - xx[145] + xx[125];\n  xx[460] = xx[53];\n  xx[461] = xx[129];\n  xx[462] = xx[59];\n  xx[463] = xx[25];\n  xx[464] = xx[62];\n  xx[465] = xx[157] - xx[148] + xx[126];\n  xx[466] = xx[158] - xx[149] - xx[123];\n  xx[467] = xx[132];\n  xx[468] = xx[65];\n  xx[469] = xx[95];\n  xx[470] = xx[106];\n  xx[471] = xx[72];\n  xx[472] = xx[77];\n  xx[473] = xx[133];\n  xx[474] = xx[66];\n  xx[475] = xx[96];\n  xx[476] = xx[107];\n  xx[477] = xx[64];\n  xx[478] = xx[63];\n  xx[479] = xx[134];\n  xx[480] = xx[67];\n  xx[481] = xx[97];\n  xx[482] = xx[108];\n  xx[483] = xx[74];\n  xx[484] = xx[75];\n  xx[485] = xx[135];\n  solveSymmetricPosDef(xx + 160, xx + 450, 6, 6, xx + 486, xx + 57);\n  xx[23] = xx[507];\n  xx[24] = xx[513];\n  xx[25] = xx[519];\n  xx[20] = 9.806649999999999;\n  xx[21] = xx[20] * state[4];\n  xx[30] = xx[20] * state[5];\n  xx[35] = xx[12] * (xx[21] * state[6] - xx[30] * state[3]);\n  xx[39] = xx[12] * (xx[21] * state[3] + xx[30] * state[6]);\n  xx[41] = xx[12] * (xx[21] * state[4] + xx[30] * state[5]);\n  xx[57] = xx[35];\n  xx[58] = xx[39];\n  xx[59] = xx[20] - xx[41];\n  xx[21] = pm_math_Vector3_dot_ra(xx + 23, xx + 57);\n  xx[23] = xx[84] - xx[21];\n  xx[60] = xx[508];\n  xx[61] = xx[514];\n  xx[62] = xx[520];\n  xx[24] = pm_math_Vector3_dot_ra(xx + 60, xx + 57);\n  xx[25] = xx[85] - xx[24];\n  xx[60] = xx[509];\n  xx[61] = xx[515];\n  xx[62] = xx[521];\n  xx[30] = pm_math_Vector3_dot_ra(xx + 60, xx + 57);\n  xx[42] = xx[86] - xx[30];\n  xx[60] = state[23];\n  xx[61] = state[24];\n  xx[62] = state[25];\n  xx[43] = - state[16];\n  xx[63] = xx[43];\n  xx[64] = xx[204];\n  xx[65] = xx[206];\n  xx[66] = xx[208];\n  xx[87] = state[20];\n  xx[88] = state[21];\n  xx[89] = state[22];\n  pm_math_Quaternion_inverseXform_ra(xx + 63, xx + 87, xx + 92);\n  pm_math_Vector3_cross_ra(xx + 60, xx + 92, xx + 63);\n  xx[87] = - xx[92];\n  xx[88] = - xx[93];\n  xx[89] = - xx[94];\n  pm_math_Vector3_cross_ra(xx + 60, xx + 87, xx + 95);\n  xx[46] = 3.469446951953614e-18;\n  xx[53] = xx[46] * state[18];\n  xx[66] = xx[46] * state[17];\n  xx[118] = state[18];\n  xx[119] = state[19];\n  xx[120] = xx[43];\n  xx[121] = xx[204];\n  xx[122] = state[13] - xx[12] * (xx[53] * state[16] + xx[66] * state[19]);\n  xx[123] = xx[12] * (xx[66] * state[16] - xx[53] * state[19]) + state[14];\n  xx[124] = xx[12] * (xx[66] * state[17] + xx[53] * state[18]) - xx[46] + state\n    [15];\n  bb[1] = sm_core_compiler_computeProximityInfoBrickCylinder(\n    simulation_b048d748_1_geometry_3(NULL), simulation_b048d748_1_geometry_1\n    (NULL), (pm_math_Transform3 *)(xx + 340), (pm_math_Transform3 *)(xx + 118),\n    xx + 43, (pm_math_Vector3 *)(xx + 87), (pm_math_Vector3 *)(xx + 103),\n    (pm_math_Vector3 *)(xx + 106), (pm_math_Vector3 *)(xx + 125));\n  xx[142] = xx[44];\n  xx[143] = xx[44];\n  xx[144] = xx[11];\n  xx[145] = xx[44];\n  xx[146] = xx[44];\n  xx[147] = xx[44];\n  xx[148] = - xx[46];\n  xx[149] = state[23];\n  xx[150] = state[24];\n  xx[151] = state[25];\n  xx[152] = xx[92];\n  xx[153] = xx[93];\n  xx[154] = xx[94];\n  sm_core_compiler_computeSpatialContactWrenches(\n    0, 1, bb[1], xx + 43, (const pm_math_Vector3 *)(xx + 87), (const\n    pm_math_Vector3 *)(xx + 103), (const pm_math_Vector3 *)(xx + 106), (const\n    pm_math_Vector3 *)(xx + 125),\n    (const pm_math_Transform3 *)(xx + 340), (const pm_math_Transform3 *)(xx +\n    142), (const pm_math_Transform3 *)(xx + 340), (const pm_math_Transform3 *)\n    (xx + 118), NULL, (const pm_math_SpatialVector *)(xx + 149),\n    0, 1, xx[54], 100.0, xx[55], xx[56], xx[140], xx[205], NULL, NULL,\n    NULL, (pm_math_SpatialVector *)(xx + 325));\n  xx[53] = xx[32] * (xx[63] + xx[95]) - xx[328];\n  xx[54] = xx[32] * (xx[64] + xx[96]) - xx[329];\n  xx[55] = xx[32] * (xx[65] + xx[97]) - (input[3] + xx[330]);\n  xx[32] = pm_math_Vector3_dot_ra(xx + 223, xx + 53);\n  xx[43] = pm_math_Vector3_dot_ra(xx + 254, xx + 53);\n  xx[46] = pm_math_Vector3_dot_ra(xx + 258, xx + 53);\n  xx[53] = xx[261] * state[23];\n  xx[54] = xx[261] * state[24];\n  xx[55] = xx[80] * state[25];\n  pm_math_Vector3_cross_ra(xx + 60, xx + 53, xx + 63);\n  xx[92] = - xx[32];\n  xx[93] = - xx[43];\n  xx[94] = - xx[46];\n  xx[95] = xx[325] - xx[63];\n  xx[96] = xx[326] - xx[64];\n  xx[97] = xx[327] - xx[65];\n  solveSymmetricPosDef(xx + 262, xx + 92, 6, 1, xx + 103, xx + 118);\n  xx[450] = xx[44];\n  xx[451] = xx[44];\n  xx[452] = xx[44];\n  xx[453] = xx[261];\n  xx[454] = xx[44];\n  xx[455] = xx[44];\n  xx[456] = xx[44];\n  xx[457] = xx[44];\n  xx[458] = xx[44];\n  xx[459] = xx[44];\n  xx[460] = xx[261];\n  xx[461] = xx[44];\n  xx[462] = xx[44];\n  xx[463] = xx[44];\n  xx[464] = xx[44];\n  xx[465] = xx[44];\n  xx[466] = xx[44];\n  xx[467] = xx[80];\n  xx[468] = xx[226];\n  xx[469] = xx[233];\n  xx[470] = xx[245];\n  xx[471] = xx[44];\n  xx[472] = xx[44];\n  xx[473] = xx[44];\n  xx[474] = xx[227];\n  xx[475] = xx[236];\n  xx[476] = xx[247];\n  xx[477] = xx[44];\n  xx[478] = xx[44];\n  xx[479] = xx[44];\n  xx[480] = xx[228];\n  xx[481] = xx[240];\n  xx[482] = xx[249];\n  xx[483] = xx[44];\n  xx[484] = xx[44];\n  xx[485] = xx[44];\n  solveSymmetricPosDef(xx + 262, xx + 450, 6, 6, xx + 522, xx + 92);\n  xx[53] = xx[544];\n  xx[54] = xx[550];\n  xx[55] = xx[556];\n  xx[56] = xx[20] * state[17];\n  xx[66] = xx[20] * state[18];\n  xx[87] = xx[12] * (xx[56] * state[19] - xx[66] * state[16]);\n  xx[88] = xx[12] * (xx[56] * state[16] + xx[66] * state[19]);\n  xx[89] = xx[20] - xx[12] * (xx[56] * state[17] + xx[66] * state[18]);\n  xx[20] = pm_math_Vector3_dot_ra(xx + 53, xx + 87);\n  xx[53] = xx[107] - xx[20];\n  xx[54] = xx[545];\n  xx[55] = xx[551];\n  xx[56] = xx[557];\n  xx[66] = pm_math_Vector3_dot_ra(xx + 54, xx + 87);\n  xx[54] = xx[108] - xx[66];\n  xx[92] = xx[11] - xx[12] * (xx[252] + xx[307]);\n  xx[93] = xx[12] * (xx[248] + xx[244]);\n  xx[94] = xx[209];\n  xx[95] = xx[543];\n  xx[96] = xx[549];\n  xx[97] = xx[555];\n  xx[55] = pm_math_Vector3_dot_ra(xx + 95, xx + 87);\n  xx[56] = xx[106] - xx[55];\n  xx[95] = - (xx[12] * (xx[141] + xx[48]));\n  xx[96] = xx[12] * (xx[298] - xx[257]);\n  xx[97] = xx[12] * (xx[49] + xx[252]) - xx[11];\n  xx[118] = xx[504];\n  xx[119] = xx[510];\n  xx[120] = xx[516];\n  xx[11] = pm_math_Vector3_dot_ra(xx + 118, xx + 57);\n  xx[48] = xx[110] * xx[51];\n  xx[49] = xx[48] * xx[38];\n  xx[51] = xx[110] * xx[40];\n  xx[40] = xx[51] * xx[38];\n  xx[67] = xx[48] * xx[28] + xx[51] * xx[37];\n  xx[118] = xx[49];\n  xx[119] = xx[40];\n  xx[120] = - xx[67];\n  pm_math_Vector3_cross_ra(xx + 337, xx + 118, xx + 121);\n  xx[118] = xx[12] * (xx[121] - xx[49] * xx[31]) - xx[51];\n  xx[119] = xx[12] * (xx[122] - xx[40] * xx[31]) + xx[48];\n  xx[120] = xx[12] * (xx[123] + xx[31] * xx[67]);\n  pm_math_Quaternion_xform_ra(xx + 136, xx + 118, xx + 121);\n  xx[37] = xx[110] * xx[38];\n  xx[118] = xx[12] * (xx[116] + xx[37] * xx[38]) - xx[110];\n  xx[119] = - (xx[12] * (xx[37] * xx[31] + xx[111] * xx[28]));\n  xx[120] = xx[12] * (xx[112] - xx[37] * xx[28]);\n  pm_math_Quaternion_xform_ra(xx + 136, xx + 118, xx + 110);\n  xx[28] = xx[241] * xx[202];\n  xx[31] = xx[241] * xx[203];\n  xx[118] = xx[540];\n  xx[119] = xx[546];\n  xx[120] = xx[552];\n  xx[37] = pm_math_Vector3_dot_ra(xx + 118, xx + 87);\n  xx[118] = xx[505];\n  xx[119] = xx[511];\n  xx[120] = xx[517];\n  xx[38] = pm_math_Vector3_dot_ra(xx + 118, xx + 57);\n  xx[118] = xx[541];\n  xx[119] = xx[547];\n  xx[120] = xx[553];\n  xx[40] = pm_math_Vector3_dot_ra(xx + 118, xx + 87);\n  xx[84] = xx[506];\n  xx[85] = xx[512];\n  xx[86] = xx[518];\n  xx[48] = pm_math_Vector3_dot_ra(xx + 84, xx + 57);\n  xx[57] = xx[542];\n  xx[58] = xx[548];\n  xx[59] = xx[554];\n  xx[49] = pm_math_Vector3_dot_ra(xx + 57, xx + 87);\n  xx[84] = - (xx[383] + xx[23] * xx[217] + xx[25] * xx[29] + xx[42] * xx[207] +\n              inputDdot[0] * xx[217] + xx[53] * xx[303] + xx[54] * xx[235]);\n  xx[85] = - (xx[384] + xx[23] * xx[237] + xx[25] * xx[34] + xx[42] * xx[47] +\n              inputDdot[0] * xx[237] + inputDdot[1] * (bb[0] ? xx[44] :\n    pm_math_Vector3_dot_ra(xx + 92, xx + 308)) + xx[56] * xx[312] + xx[54] * xx\n              [222]);\n  xx[86] = - (xx[385] + xx[23] * xx[131] + xx[25] * xx[33] + xx[42] * xx[45] +\n              inputDdot[0] * xx[131] + inputDdot[1] * (bb[0] ? xx[44] :\n    pm_math_Vector3_dot_ra(xx + 95, xx + 322)) + xx[56] * xx[212] + xx[53] * xx\n              [218]);\n  xx[87] = - (xx[386] + (xx[81] - xx[11]) * xx[234] + xx[23] * xx[352] + xx[25] *\n              xx[364] + xx[42] * xx[246] + inputDdot[0] * (bb[0] ? xx[44] :\n    - (xx[313] + xx[121])) + inputDdot[1] * (bb[0] ? xx[44] : - (xx[110] + xx[12]\n    * (xx[28] * xx[202] + xx[31] * xx[203]) - xx[241])) + (xx[103] - xx[37]) *\n              xx[50] + xx[56] * xx[358] + xx[53] * xx[371]);\n  xx[88] = - (xx[387] + (xx[82] - xx[38]) * xx[234] + xx[23] * xx[305] + xx[25] *\n              xx[69] + xx[42] * xx[117] + inputDdot[0] * (bb[0] ? xx[44] :\n    - (xx[379] + xx[243] + xx[122])) + inputDdot[1] * (bb[0] ? xx[44] : - (xx\n    [111] - xx[12] * (xx[31] * xx[200] + xx[28] * xx[201]))) + (xx[104] - xx[40])\n              * xx[50] + xx[56] * xx[15] + xx[53] * xx[52]);\n  xx[89] = - (xx[388] + (xx[83] - xx[48]) * xx[234] + xx[23] * xx[306] + xx[25] *\n              xx[115] + xx[42] * xx[114] + inputDdot[0] * (bb[0] ? xx[44] :\n    - (xx[319] + xx[123])) + inputDdot[1] * (bb[0] ? xx[44] : - (xx[12] * (xx[28]\n    * xx[200] - xx[31] * xx[201]) + xx[112])) + (xx[105] - xx[49]) * xx[50] +\n              xx[56] * xx[251] + xx[53] * xx[320]);\n  memcpy(xx + 372, xx + 414, 36 * sizeof(double));\n  factorAndSolveSymmetric(xx + 372, 6, xx + 103, ii + 0, xx + 84, xx + 92, xx +\n    450);\n  xx[79] = xx[95] * xx[234] - xx[73];\n  xx[80] = xx[96] * xx[234] - xx[76];\n  xx[81] = xx[97] * xx[234] - xx[78];\n  xx[82] = xx[92] * xx[217] + xx[93] * xx[237] + xx[94] * xx[131] + xx[95] * xx\n    [352] + xx[96] * xx[305] + xx[97] * xx[306] - (xx[13] - xx[68]);\n  xx[83] = xx[92] * xx[29] + xx[93] * xx[34] + xx[94] * xx[33] + xx[95] * xx[364]\n    + xx[96] * xx[69] + xx[97] * xx[115] - xx[14];\n  xx[84] = xx[92] * xx[207] + xx[93] * xx[47] + xx[94] * xx[45] + xx[95] * xx\n    [246] + xx[96] * xx[117] + xx[97] * xx[114] - xx[18];\n  solveSymmetricPosDef(xx + 160, xx + 79, 6, 1, xx + 72, xx + 103);\n  xx[13] = xx[72] - xx[11];\n  xx[11] = xx[73] - xx[38];\n  xx[14] = xx[74] - xx[48];\n  xx[18] = xx[75] - xx[21];\n  xx[21] = xx[76] - xx[24];\n  xx[23] = xx[77] - xx[30];\n  xx[28] = state[16];\n  xx[29] = state[17];\n  xx[30] = state[18];\n  xx[31] = state[19];\n  pm_math_Quaternion_compDeriv_ra(xx + 28, xx + 60, xx + 56);\n  xx[72] = xx[95] * xx[50] - xx[32];\n  xx[73] = xx[96] * xx[50] - xx[43];\n  xx[74] = xx[97] * xx[50] - xx[46];\n  xx[75] = xx[93] * xx[312] + xx[94] * xx[212] + xx[95] * xx[358] + xx[96] * xx\n    [15] + xx[97] * xx[251] - (xx[63] - xx[325]);\n  xx[76] = xx[92] * xx[303] + xx[94] * xx[218] + xx[95] * xx[371] + xx[96] * xx\n    [52] + xx[97] * xx[320] - (xx[64] - xx[326]);\n  xx[77] = xx[92] * xx[235] + xx[93] * xx[222] - (xx[65] - xx[327]);\n  solveSymmetricPosDef(xx + 262, xx + 72, 6, 1, xx + 28, xx + 60);\n  deriv[0] = state[7];\n  deriv[1] = state[8];\n  deriv[2] = state[9];\n  deriv[3] = xx[7];\n  deriv[4] = xx[8];\n  deriv[5] = xx[9];\n  deriv[6] = xx[10];\n  deriv[7] = xx[13];\n  deriv[8] = xx[11];\n  deriv[9] = xx[14];\n  deriv[10] = xx[18];\n  deriv[11] = xx[21];\n  deriv[12] = xx[23];\n  deriv[13] = state[20];\n  deriv[14] = state[21];\n  deriv[15] = state[22];\n  deriv[16] = xx[56];\n  deriv[17] = xx[57];\n  deriv[18] = xx[58];\n  deriv[19] = xx[59];\n  deriv[20] = xx[28] - xx[37];\n  deriv[21] = xx[29] - xx[40];\n  deriv[22] = xx[30] - xx[49];\n  deriv[23] = xx[31] - xx[55];\n  deriv[24] = xx[32] - xx[20];\n  deriv[25] = xx[33] - xx[66];\n  errorResult[0] = xx[44];\n  xx[7] = 9.87654321;\n  xx[8] = xx[18];\n  xx[9] = xx[21];\n  xx[10] = xx[23];\n  xx[15] = 0.01;\n  xx[23] = xx[15];\n  xx[24] = xx[15];\n  xx[25] = - 0.9;\n  pm_math_Vector3_cross_ra(xx + 8, xx + 23, xx + 28);\n  pm_math_Vector3_cross_ra(xx + 4, xx + 23, xx + 31);\n  pm_math_Vector3_cross_ra(xx + 4, xx + 31, xx + 42);\n  pm_math_Quaternion_xform_ra(xx + 136, xx + 23, xx + 45);\n  xx[23] = xx[45] + xx[36];\n  xx[24] = xx[46] + xx[71];\n  xx[25] = xx[47] + xx[90];\n  pm_math_Quaternion_inverseXform_ra(xx + 0, xx + 23, xx + 36);\n  pm_math_Vector3_cross_ra(xx + 8, xx + 36, xx + 0);\n  pm_math_Vector3_cross_ra(xx + 4, xx + 36, xx + 8);\n  xx[23] = xx[12] * (xx[31] + xx[109] - xx[8]) + xx[8];\n  xx[24] = xx[12] * (xx[32] + xx[113] - xx[9]) + xx[9];\n  xx[25] = xx[12] * (xx[33] + xx[316] - xx[10]) + xx[10];\n  pm_math_Vector3_cross_ra(xx + 4, xx + 23, xx + 8);\n  output[2] = xx[13];\n  output[5] = xx[11];\n  output[8] = xx[14];\n  output[21] = xx[35] + xx[16] * xx[13] + xx[26] * xx[11] + xx[99] * xx[14] +\n    xx[21] + xx[17] + xx[28] + xx[42] - xx[35] - xx[0] - xx[8];\n  output[22] = xx[39] + xx[19] * xx[13] + xx[70] * xx[11] + xx[100] * xx[14] -\n    xx[18] + xx[27] + xx[29] + xx[43] - xx[39] - xx[1] - xx[9];\n  output[23] = xx[22] * xx[13] - xx[41] + xx[91] * xx[11] + xx[102] * xx[14] +\n    xx[221] + xx[231] + xx[30] + xx[44] + xx[41] - xx[2] - xx[10];\n  return NULL;\n}\n"},{"name":"simulation_b048d748_1_compOutputsKin.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include <math.h>\n#include <string.h>\n#include \"pm_std.h\"\n#include \"sm_std.h\"\n#include \"ne_std.h\"\n#include \"ne_dae.h\"\n#include \"sm_ssci_run_time_errors.h\"\n#include \"sm_RuntimeDerivedValuesBundle.h\"\n#include \"simulation_b048d748_1_geometries.h\"\n\nPmfMessageId simulation_b048d748_1_compOutputsKin(const\n  RuntimeDerivedValuesBundle *rtdv, const double *state, const int *modeVector,\n  const double *input, const double *inputDot, const double *inputDdot, const\n  double *discreteState, double *output, NeuDiagnosticManager *neDiagMgr)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  boolean_T bb[1];\n  double xx[19];\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) modeVector;\n  (void) input;\n  (void) inputDot;\n  (void) inputDdot;\n  (void) discreteState;\n  (void) neDiagMgr;\n  xx[0] = 9.87654321;\n  xx[1] = 2.0;\n  xx[2] = xx[1] * (state[3] * state[5] + state[4] * state[6]);\n  xx[3] = xx[1] * (state[3] * state[4] - state[5] * state[6]);\n  xx[4] = xx[1] * (state[4] * state[4] + state[5] * state[5]);\n  xx[5] = - state[3];\n  xx[6] = - state[4];\n  xx[7] = - state[5];\n  xx[8] = - state[6];\n  xx[9] = state[0] + xx[2] - xx[2];\n  xx[10] = xx[3] + state[1] - xx[3];\n  xx[11] = xx[4] + state[2] - xx[4];\n  xx[1] = 1.0;\n  xx[2] = 0.0;\n  xx[12] = xx[1];\n  xx[13] = xx[2];\n  xx[14] = xx[2];\n  xx[15] = xx[2];\n  xx[16] = xx[2];\n  xx[17] = xx[2];\n  xx[18] = - xx[1];\n  bb[0] = sm_core_compiler_computeSignedDistanceCxpolyBrick(\n    simulation_b048d748_1_geometry_0(NULL), simulation_b048d748_1_geometry_3\n    (NULL), (pm_math_Transform3 *)(xx + 5), (pm_math_Transform3 *)(xx + 12), xx\n    + 3);\n  output[0] = state[0];\n  output[1] = state[7];\n  output[3] = state[1];\n  output[4] = state[8];\n  output[6] = state[2];\n  output[7] = state[9];\n  output[9] = state[3];\n  output[10] = state[4];\n  output[11] = state[5];\n  output[12] = state[6];\n  output[13] = xx[3] < xx[2] ? xx[1] : xx[2];\n  output[14] = state[3];\n  output[15] = state[4];\n  output[16] = state[5];\n  output[17] = state[6];\n  output[18] = state[10];\n  output[19] = state[11];\n  output[20] = state[12];\n  return NULL;\n}\n"},{"name":"simulation_b048d748_1_create.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include \"pm_std.h\"\n#include \"ne_std.h\"\n#include \"ne_dae.h\"\n#include \"pm_default_allocator.h\"\n#include \"sm_ssci_NeDaePrivateData.h\"\n#include \"sm_CTarget.h\"\n\nPmfMessageId sm_ssci_recordRunTimeError(\n  const char *errorId, const char *errorMsg, NeuDiagnosticManager* mgr);\n\n#define pm_allocator_alloc(_allocator, _m, _n) ((_allocator)->mCallocFcn((_allocator), (_m), (_n)))\n#define PM_ALLOCATE_ARRAY(_name, _type, _size, _allocator)\\\n _name = (_type *) pm_allocator_alloc(_allocator, sizeof(_type), _size)\n#define pm_size_to_int(_size)          ((int32_T) (_size))\n\nPmIntVector *pm_create_int_vector(size_t, PmAllocator *);\nint_T pm_create_int_vector_fields (PmIntVector *, size_t, PmAllocator *);\nint_T pm_create_real_vector_fields(PmRealVector *, size_t, PmAllocator *);\nint_T pm_create_char_vector_fields(PmCharVector *, size_t, PmAllocator *);\nint_T pm_create_bool_vector_fields(PmBoolVector *, size_t, PmAllocator *);\nvoid pm_rv_equals_rv(const PmRealVector *, const PmRealVector *);\nextern const NeAssertData simulation_b048d748_1_assertData[];\nextern const NeZCData simulation_b048d748_1_ZCData[];\nvoid simulation_b048d748_1_computeRuntimeParameters(\n  const double *runtimeRootVariables,\n  double *runtimeParameters);\nvoid simulation_b048d748_1_validateRuntimeParameters(\n  const double *runtimeParameters,\n  int32_T *assertSatisfactionFlags);\nvoid simulation_b048d748_1_computeAsmRuntimeDerivedValues(\n  const double *runtimeParameters,\n  RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle);\nvoid simulation_b048d748_1_computeSimRuntimeDerivedValues(\n  const double *runtimeParameters,\n  RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle);\nvoid simulation_b048d748_1_initializeGeometries(\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle);\nPmfMessageId simulation_b048d748_1_compDerivs(\n  const RuntimeDerivedValuesBundle *,\n  const int *,\n  const double *,\n  const int *,\n  const double *, const double *, const double *,\n  const double *,\n  double *,\n  double *,\n  NeuDiagnosticManager *neDiagMgr);\nPmfMessageId simulation_b048d748_1_numJacPerturbLoBounds(\n  const RuntimeDerivedValuesBundle *,\n  const int *,\n  const double *,\n  const int *,\n  const double *, const double *, const double *,\n  const double *,\n  double *,\n  double *,\n  NeuDiagnosticManager *neDiagMgr);\nPmfMessageId simulation_b048d748_1_numJacPerturbHiBounds(\n  const RuntimeDerivedValuesBundle *,\n  const int *,\n  const double *,\n  const int *,\n  const double *, const double *, const double *,\n  const double *,\n  double *,\n  double *,\n  NeuDiagnosticManager *neDiagMgr);\nPmfMessageId simulation_b048d748_1_checkDynamics(\n  const RuntimeDerivedValuesBundle *,\n  const double *,\n  const double *, const double *, const double *,\n  const double *,\n  const int *,\n  double *,\n  NeuDiagnosticManager *neDiagMgr);\nPmfMessageId simulation_b048d748_1_compOutputsDyn(\n  const RuntimeDerivedValuesBundle *,\n  const int *,\n  const double *,\n  const int *,\n  const double *, const double *, const double *,\n  const double *,\n  double *,\n  double *,\n  int *,\n  double *,\n  NeuDiagnosticManager *neDiagMgr);\nPmfMessageId simulation_b048d748_1_compOutputsKin(\n  const RuntimeDerivedValuesBundle *,\n  const double *,\n  const int *,\n  const double *, const double *, const double *,\n  const double *,\n  double *,\n  NeuDiagnosticManager *neDiagMgr);\nPmfMessageId simulation_b048d748_1_compOutputs (\n  const RuntimeDerivedValuesBundle *,\n  const int *,\n  const double *,\n  const int *,\n  const double *, const double *, const double *,\n  const double *,\n  double *,\n  double *,\n  int *,\n  double *,\n  NeuDiagnosticManager *neDiagMgr);\nPmfMessageId simulation_b048d748_1_computeAsmModeVector(\n  const double *, const double *, const double *,\n  int *,\n  double *,\n  NeuDiagnosticManager *neDiagMgr);\nPmfMessageId simulation_b048d748_1_computeSimModeVector(\n  const double *, const double *, const double *,\n  int *,\n  double *,\n  NeuDiagnosticManager *neDiagMgr);\nPmfMessageId simulation_b048d748_1_computeZeroCrossings(\n  const RuntimeDerivedValuesBundle *,\n  const double *,\n  const double *, const double *, const double *,\n  const double *,\n  double *,\n  double *,\n  NeuDiagnosticManager *neDiagMgr);\nPmfMessageId simulation_b048d748_1_recordLog(\n  const RuntimeDerivedValuesBundle *,\n  const int *,\n  const double *,\n  const int *,\n  const double *, const double *, const double *,\n  double *,\n  double *,\n  NeuDiagnosticManager *neDiagMgr);\nvoid simulation_b048d748_1_setTargets(\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  CTarget *targets);\nvoid simulation_b048d748_1_resetAsmStateVector(const void *mech, double\n  *stateVector);\nvoid simulation_b048d748_1_resetSimStateVector(const void *mech, double\n  *stateVector);\nvoid simulation_b048d748_1_initializeTrackedAngleState(\n  const void *mech,\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  const int *modeVector,\n  const double *motionData,\n  double *stateVector);\nvoid simulation_b048d748_1_computeDiscreteState(\n  const void *mech,\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  double *stateVector);\nvoid simulation_b048d748_1_adjustPosition(\n  const void *mech,\n  const double *dofDeltas,\n  double *stateVector);\nvoid simulation_b048d748_1_perturbAsmJointPrimitiveState(\n  const void *mech,\n  size_t stageIdx,\n  size_t primitiveIdx,\n  double magnitude,\n  boolean_T doPerturbVelocity,\n  double *stateVector);\nvoid simulation_b048d748_1_perturbSimJointPrimitiveState(\n  const void *mech,\n  size_t stageIdx,\n  size_t primitiveIdx,\n  double magnitude,\n  boolean_T doPerturbVelocity,\n  double *stateVector);\nvoid simulation_b048d748_1_perturbFlexibleBodyState(\n  const void *mech,\n  size_t stageIdx,\n  double magnitude,\n  boolean_T doPerturbVelocity,\n  double *stateVector);\nvoid simulation_b048d748_1_computePosDofBlendMatrix(\n  const void *mech,\n  size_t stageIdx,\n  size_t primitiveIdx,\n  const double *stateVector,\n  int partialType,\n  double *matrix);\nvoid simulation_b048d748_1_computeVelDofBlendMatrix(\n  const void *mech,\n  size_t stageIdx,\n  size_t primitiveIdx,\n  const double *stateVector,\n  int partialType,\n  double *matrix);\nvoid simulation_b048d748_1_projectPartiallyTargetedPos(\n  const void *mech,\n  size_t stageIdx,\n  size_t primitiveIdx,\n  const double *origStateVector,\n  int partialType,\n  double *stateVector);\nvoid simulation_b048d748_1_propagateMotion(\n  const void *mech,\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  const double *stateVector,\n  double *motionData);\nsize_t simulation_b048d748_1_computeAssemblyError(\n  const void *mech,\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  size_t constraintIdx,\n  const int *modeVector,\n  const double *motionData,\n  double *error);\nsize_t simulation_b048d748_1_computeAssemblyJacobian(\n  const void *mech,\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  size_t constraintIdx,\n  boolean_T forVelocitySatisfaction,\n  const double *stateVector,\n  const int *modeVector,\n  const double *motionData,\n  double *J);\nsize_t simulation_b048d748_1_computeFullAssemblyJacobian(\n  const void *mech,\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  const double *stateVector,\n  const int *modeVector,\n  const double *motionData,\n  double *J);\nboolean_T simulation_b048d748_1_isInKinematicSingularity(\n  const void *mech,\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  size_t constraintIdx,\n  const int *modeVector,\n  const double *motionData);\nvoid simulation_b048d748_1_convertStateVector(\n  const void *asmMech,\n  const RuntimeDerivedValuesBundle *asmRuntimeDerivedValuesBundle,\n  const void *simMech,\n  const double *asmStateVector,\n  const int *asmModeVector,\n  const int *simModeVector,\n  double *simStateVector);\nvoid simulation_b048d748_1_constructStateVector(\n  const void *mech,\n  const double *solverStateVector,\n  const double *u,\n  const double *uDot,\n  const double *discreteStateVector,\n  double *fullStateVector);\nvoid simulation_b048d748_1_extractSolverStateVector(\n  const void *mech,\n  const double *fullStateVector,\n  double *solverStateVector);\nboolean_T simulation_b048d748_1_isPositionViolation(\n  const void *mech,\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  const int *constraintEqnEnableFlags,\n  const double *stateVector,\n  const int *modeVector);\nboolean_T simulation_b048d748_1_isVelocityViolation(\n  const void *mech,\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  const int *constraintEqnEnableFlags,\n  const double *stateVector,\n  const int *modeVector);\nPmfMessageId simulation_b048d748_1_projectStateSim(\n  const void *mech,\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  const int *constraintEqnEnableFlags,\n  const int *modeVector,\n  double *stateVector,\n  void *neDiagMgr);\nvoid simulation_b048d748_1_computeConstraintError(\n  const void *mech,\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  const double *stateVector,\n  const int *modeVector,\n  double *error);\nvoid simulation_b048d748_1_resetModeVector(const void *mech, int *modeVector);\nboolean_T simulation_b048d748_1_hasJointDisToNormModeChange(\n  const void *mech,\n  const int *prevModeVector,\n  const int *modeVector);\nPmfMessageId simulation_b048d748_1_performJointDisToNormModeChange(\n  const void *mech,\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle,\n  const int *constraintEqnEnableFlags,\n  const int *prevModeVector,\n  const int *modeVector,\n  const double *inputVector,\n  double *stateVector,\n  void *neDiagMgr);\nvoid simulation_b048d748_1_onModeChangedCutJoints(\n  const void *mech,\n  const int *prevModeVector,\n  const int *modeVector,\n  double *stateVector);\nPmfMessageId simulation_b048d748_1_assemble(const double *u, double *udot,\n  double *x,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  (void) x;\n  (void) u;\n  (void) udot;\n  (void) neDiagMgr;\n  return NULL;\n}\n\nstatic\n  void dae_cg_setParameters_function(const NeDae *dae,\n  const NeParameterBundle *paramBundle)\n{\n  const NeDaePrivateData *smData = dae->mPrivateData;\n  const double *runtimeRootVariables = paramBundle->mRealParameters.mX;\n  if (smData->mRuntimeParameterScalars.mN == 0)\n    return;\n  simulation_b048d748_1_computeRuntimeParameters(\n    runtimeRootVariables,\n    smData->mRuntimeParameterScalars.mX);\n  simulation_b048d748_1_computeAsmRuntimeDerivedValues(\n    smData->mRuntimeParameterScalars.mX,\n    &dae->mPrivateData->mAsmRuntimeDerivedValuesBundle);\n  simulation_b048d748_1_computeSimRuntimeDerivedValues(\n    smData->mRuntimeParameterScalars.mX,\n    &dae->mPrivateData->mSimRuntimeDerivedValuesBundle);\n  simulation_b048d748_1_initializeGeometries\n    (&smData->mSimRuntimeDerivedValuesBundle);\n  sm_core_computeRedundantConstraintEquations(\n    &dae->mPrivateData->mSimulationDelegate,\n    &smData->mSimRuntimeDerivedValuesBundle);\n\n#if 0\n\n  {\n    size_t i;\n    const size_t n = smData->mSimulationDelegate.mRunTimeEnabledEquations.mSize;\n    pmf_printf(\"\\nRuntime Enabled Equations (%lu)\\n\", n);\n    for (i = 0; i < n; ++i)\n      pmf_printf(\"  %2lu:  %d\\n\", i,\n                 smData->mSimulationDelegate.mRunTimeEnabledEquations.mValues[i]);\n  }\n\n#endif\n\n}\n\nstatic\n  PmfMessageId dae_cg_pAssert_method(const NeDae *dae,\n  const NeSystemInput *systemInput,\n  NeDaeMethodOutput *daeMethodOutput,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  const NeDaePrivateData *smData = dae->mPrivateData;\n  const double *runtimeParams = smData->mRuntimeParameterScalars.mX;\n  int32_T *assertSatisfactionFlags = daeMethodOutput->mPASSERT.mX;\n  (void) systemInput;\n  (void) neDiagMgr;\n  simulation_b048d748_1_validateRuntimeParameters(\n    runtimeParams, assertSatisfactionFlags);\n  return NULL;\n}\n\nstatic\n  PmfMessageId dae_cg_deriv_method(const NeDae *dae,\n  const NeSystemInput *systemInput,\n  NeDaeMethodOutput *daeMethodOutput,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  const NeDaePrivateData *smData = dae->mPrivateData;\n  PmfMessageId errorId = NULL;\n  double errorResult = 0.0;\n  if (smData->mCachedDerivativesAvailable)\n    memcpy(daeMethodOutput->mXP0.mX, smData->mCachedDerivatives.mX,\n           26 * sizeof(real_T));\n  else\n    errorId = simulation_b048d748_1_compDerivs(\n      &smData->mSimRuntimeDerivedValuesBundle,\n      smData->mSimulationDelegate\n      .mRunTimeEnabledEquations.mValues,\n      systemInput->mX.mX,\n      systemInput->mM.mX,\n      systemInput->mU.mX,\n      systemInput->mU.mX + 5,\n      systemInput->mV.mX + 5,\n      systemInput->mD.mX,\n      daeMethodOutput->mXP0.mX,\n      &errorResult,\n      neDiagMgr);\n  return errorId;\n}\n\nstatic\n  PmfMessageId dae_cg_numJacPerturbLoBounds_method(\n  const NeDae *dae,\n  const NeSystemInput *systemInput,\n  NeDaeMethodOutput *daeMethodOutput,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  const NeDaePrivateData *smData = dae->mPrivateData;\n  PmfMessageId errorId = NULL;\n  double errorResult = 0.0;\n  errorId = simulation_b048d748_1_numJacPerturbLoBounds(\n    &smData->mSimRuntimeDerivedValuesBundle,\n    smData->mSimulationDelegate\n    .mRunTimeEnabledEquations.mValues,\n    systemInput->mX.mX,\n    systemInput->mM.mX,\n    systemInput->mU.mX,\n    systemInput->mU.mX + 5,\n    systemInput->mV.mX + 5,\n    systemInput->mD.mX,\n    daeMethodOutput->mNUMJAC_DX_LO.mX,\n    &errorResult,\n    neDiagMgr);\n  return errorId;\n}\n\nstatic\n  PmfMessageId dae_cg_numJacPerturbHiBounds_method(\n  const NeDae *dae,\n  const NeSystemInput *systemInput,\n  NeDaeMethodOutput *daeMethodOutput,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  const NeDaePrivateData *smData = dae->mPrivateData;\n  PmfMessageId errorId = NULL;\n  double errorResult = 0.0;\n  errorId = simulation_b048d748_1_numJacPerturbHiBounds(\n    &smData->mSimRuntimeDerivedValuesBundle,\n    smData->mSimulationDelegate\n    .mRunTimeEnabledEquations.mValues,\n    systemInput->mX.mX,\n    systemInput->mM.mX,\n    systemInput->mU.mX,\n    systemInput->mU.mX + 5,\n    systemInput->mV.mX + 5,\n    systemInput->mD.mX,\n    daeMethodOutput->mNUMJAC_DX_HI.mX,\n    &errorResult,\n    neDiagMgr);\n  return errorId;\n}\n\nstatic\n  PmfMessageId dae_cg_compOutputs_method(const NeDae *dae,\n  const NeSystemInput *systemInput,\n  NeDaeMethodOutput *daeMethodOutput,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  PmfMessageId errorId = NULL;\n  NeDaePrivateData *smData = dae->mPrivateData;\n  if (smData->mDoComputeDynamicOutputs) {\n    int derivErr = 0;\n    double errorResult = 0.0;\n    errorId = simulation_b048d748_1_compOutputsDyn(\n      &smData->mSimRuntimeDerivedValuesBundle,\n      smData->mSimulationDelegate\n      .mRunTimeEnabledEquations.mValues,\n      systemInput->mX.mX,\n      systemInput->mM.mX,\n      systemInput->mU.mX,\n      systemInput->mU.mX + 5,\n      systemInput->mV.mX + 5,\n      systemInput->mD.mX,\n      smData->mCachedDerivatives.mX, daeMethodOutput->mY.mX,\n      &derivErr, &errorResult, neDiagMgr);\n    smData->mCachedDerivativesAvailable = (derivErr == 0);\n  } else\n    errorId = simulation_b048d748_1_compOutputsKin(\n      &smData->mSimRuntimeDerivedValuesBundle,\n      systemInput->mX.mX,\n      systemInput->mM.mX,\n      systemInput->mU.mX,\n      systemInput->mU.mX + 5,\n      systemInput->mV.mX + 5,\n      systemInput->mD.mX,\n      daeMethodOutput->mY.mX, neDiagMgr);\n  return errorId;\n}\n\nstatic\n  PmfMessageId dae_cg_mode_method(const NeDae *dae,\n  const NeSystemInput *systemInput,\n  NeDaeMethodOutput *daeMethodOutput,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  const NeDaePrivateData *smData = dae->mPrivateData;\n  PmfMessageId errorId = NULL;\n  double errorResult = 0.0;\n  errorId = simulation_b048d748_1_computeSimModeVector(\n    systemInput->mU.mX,\n    systemInput->mU.mX + 5,\n    systemInput->mV.mX + 5,\n    daeMethodOutput->mMODE.mX,\n    &errorResult,\n    neDiagMgr);\n  memcpy(smData->mCachedModeVector.mX, daeMethodOutput->mMODE.mX,\n         1 * sizeof(int32_T));\n  return errorId;\n}\n\nstatic\n  PmfMessageId dae_cg_zeroCrossing_method(const NeDae *dae,\n  const NeSystemInput *systemInput,\n  NeDaeMethodOutput *daeMethodOutput,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  const NeDaePrivateData *smData = dae->mPrivateData;\n  double errorResult = 0.0;\n  return\n    simulation_b048d748_1_computeZeroCrossings(\n    &smData->mSimRuntimeDerivedValuesBundle,\n    systemInput->mX.mX,\n    systemInput->mU.mX,\n    systemInput->mU.mX + 5,\n    systemInput->mV.mX + 5,\n    systemInput->mD.mX,\n    daeMethodOutput->mZC.mX,\n    &errorResult,\n    neDiagMgr);\n}\n\nstatic\n  void dae_cg_setupLoggerFcn(const NeDae *dae,\n  NeLoggerBuilder *neLoggerBuilder)\n{\n  (void) dae;\n  (void) neLoggerBuilder;\n}\n\nstatic\n  PmfMessageId dae_cg_recordLog_method(const NeDae *dae,\n  const NeSystemInput *systemInput,\n  PmRealVector *output,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  const NeDaePrivateData *smData = dae->mPrivateData;\n  PmfMessageId errorId = NULL;\n  double errorResult = 0.0;\n  double *fullStateVector = smData->mSimulationFullStateVector.mX;\n  simulation_b048d748_1_constructStateVector(\n    NULL,\n    systemInput->mX.mX,\n    systemInput->mU.mX,\n    systemInput->mU.mX + 5,\n    systemInput->mD.mX,\n    fullStateVector);\n  errorId = simulation_b048d748_1_recordLog(\n    &smData->mSimRuntimeDerivedValuesBundle,\n    smData->mSimulationDelegate\n    .mRunTimeEnabledEquations.mValues,\n    fullStateVector,\n    systemInput->mM.mX,\n    systemInput->mU.mX,\n    systemInput->mU.mX + 5,\n    systemInput->mV.mX + 5,\n    output->mX,\n    &errorResult,\n    neDiagMgr);\n  return errorId;\n}\n\nstatic\n  PmfMessageId dae_cg_project_solve(const NeDae *dae,\n  const NeSystemInput *systemInput,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  NeDaePrivateData *smData = dae->mPrivateData;\n  return\n    sm_core_projectState(\n    false,\n    &smData->mSimulationDelegate,\n    &smData->mSimRuntimeDerivedValuesBundle,\n    systemInput->mM.mX,\n    systemInput->mU.mX,\n    systemInput->mU.mX + 5,\n    systemInput->mD.mX,\n    systemInput->mX.mX, neDiagMgr);\n}\n\nstatic\n  PmfMessageId dae_cg_check_solve(const NeDae *dae,\n  const NeSystemInput *systemInput,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  NeDaePrivateData *smData = dae->mPrivateData;\n  PmfMessageId errorId = NULL;\n  if (smData->mNumConstraintEqns > 0)\n    errorId = sm_core_projectState(\n      false,\n      &smData->mSimulationDelegate,\n      &smData->mSimRuntimeDerivedValuesBundle,\n      systemInput->mM.mX,\n      systemInput->mU.mX,\n      systemInput->mU.mX + 5,\n      systemInput->mD.mX,\n      systemInput->mX.mX, neDiagMgr);\n  if (errorId == NULL) {\n    double result = 0.0;\n    errorId = simulation_b048d748_1_checkDynamics(\n      &smData->mSimRuntimeDerivedValuesBundle,\n      systemInput->mX.mX,\n      systemInput->mU.mX,\n      systemInput->mU.mX + 5,\n      systemInput->mV.mX + 5,\n      systemInput->mD.mX,\n      systemInput->mM.mX,\n      &result, neDiagMgr);\n  }\n\n  return errorId;\n}\n\nstatic\n  PmfMessageId dae_cg_CIC_MODE_solve(const NeDae *dae,\n  const NeSystemInput *systemInput,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  NeDaePrivateData *smData = dae->mPrivateData;\n  PmfMessageId errorId = NULL;\n  double errorResult = 0.0;\n  const size_t mvSize = smData->mModeVectorSize;\n  boolean_T modeChanged = false;\n  if (mvSize > 0) {\n    errorId = simulation_b048d748_1_computeSimModeVector(\n      systemInput->mU.mX,\n      systemInput->mU.mX + 5,\n      systemInput->mV.mX + 5,\n      systemInput->mM.mX,\n      &errorResult,\n      neDiagMgr);\n    if (errorId != NULL)\n      return errorId;\n\n    {\n      size_t i;\n      for (i = 0; i < mvSize; ++i)\n        if (systemInput->mM.mX[i] != smData->mCachedModeVector.mX[i]) {\n          modeChanged = true;\n          break;\n        }\n    }\n  }\n\n  if (modeChanged) {\n    errorId = sm_core_onModeChanged(\n      &smData->mSimulationDelegate,\n      &smData->mSimRuntimeDerivedValuesBundle,\n      systemInput->mU.mX,\n      systemInput->mU.mX + 5,\n      systemInput->mD.mX,\n      smData->mCachedModeVector.mX,\n      systemInput->mM.mX,\n      systemInput->mX.mX,\n      neDiagMgr);\n    if (errorId != NULL)\n      return errorId;\n    memcpy(smData->mCachedModeVector.mX, systemInput->mM.mX,\n           1 * sizeof(int32_T));\n  }\n\n  errorId =\n    sm_core_projectState(\n    true,\n    &smData->mSimulationDelegate,\n    &smData->mSimRuntimeDerivedValuesBundle,\n    systemInput->mM.mX,\n    systemInput->mU.mX,\n    systemInput->mU.mX + 5,\n    systemInput->mD.mX,\n    systemInput->mX.mX, neDiagMgr);\n  return errorId;\n}\n\nstatic\n  PmfMessageId dae_cg_assemble_solve(const NeDae *dae,\n  const NeSystemInput *systemInput,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  NeDaePrivateData *smData = dae->mPrivateData;\n  const SmMechanismDelegate *delegate = &smData->mAssemblyDelegate;\n  const RuntimeDerivedValuesBundle *runtimeDerivedValuesBundle =\n    &smData->mAsmRuntimeDerivedValuesBundle;\n  PmfMessageId errorId = NULL;\n  size_t i;\n  double errorResult = 0.0;\n  const size_t numTargets = 16;\n  unsigned int asmStatus = 0;\n  double *assemblyFullStateVector = smData->mAssemblyFullStateVector.mX;\n  double *simulationFullStateVector = smData->mSimulationFullStateVector.mX;\n  (*delegate->mSetTargets)(runtimeDerivedValuesBundle, smData->mTargets);\n\n  {\n    const double *u = systemInput->mU.mX;\n    const double *uDot = u + smData->mInputVectorSize;\n    CTarget *target = smData->mTargets + smData->mNumInternalTargets;\n    for (i = 0; i < smData->mNumInputMotionPrimitives; ++i) {\n      const size_t inputOffset = smData->mMotionInputOffsets.mX[i];\n      (target++)->mValue[0] = u [inputOffset];\n      (target++)->mValue[0] = uDot[inputOffset];\n    }\n  }\n\n  if (smData->mAssemblyModeVector.mN > 0) {\n    errorId = simulation_b048d748_1_computeAsmModeVector(\n      systemInput->mU.mX,\n      systemInput->mU.mX + 5,\n      systemInput->mV.mX + 5,\n      smData->mAssemblyModeVector.mX,\n      &errorResult,\n      neDiagMgr);\n    if (errorId != NULL)\n      return errorId;\n  }\n\n  sm_core_computeStateVector(\n    delegate, runtimeDerivedValuesBundle, smData->mAssemblyModeVector.mX,\n    numTargets, smData->mTargets, assemblyFullStateVector);\n  asmStatus = sm_core_checkAssembly(\n    delegate, runtimeDerivedValuesBundle, assemblyFullStateVector,\n    smData->mAssemblyModeVector.mX,\n    NULL, NULL, NULL);\n  if (asmStatus != 1) {\n    return sm_ssci_recordRunTimeError(\n      \"physmod:sm:ssci:core:dae:dae:assemblyFailure\",\n      asmStatus == 2 ?\n      \"Model not assembled. The following violation occurred: Position Violation. The failure occurred during the attempt to assemble all joints in the system and satisfy any motion inputs. If an Update Diagram operation completes successfully, the failure is likely caused by motion inputs. Consider adjusting the motion inputs to specify a different starting configuration. Also consider adjusting or adding joint targets to better guide the assembly.\"\n      :\n      (asmStatus == 3 ?\n       \"Model not assembled. The following violation occurred: Velocity Violation. The failure occurred during the attempt to assemble all joints in the system and satisfy any motion inputs. If an Update Diagram operation completes successfully, the failure is likely caused by motion inputs. Consider adjusting the motion inputs to specify a different starting configuration. Also consider adjusting or adding joint targets to better guide the assembly.\"\n       :\n       \"Model not assembled. The following violation occurred: Singularity Violation. The failure occurred during the attempt to assemble all joints in the system and satisfy any motion inputs. If an Update Diagram operation completes successfully, the failure is likely caused by motion inputs. Consider adjusting the motion inputs to specify a different starting configuration. Also consider adjusting or adding joint targets to better guide the assembly.\"),\n      neDiagMgr);\n  }\n\n#if 0\n\n  simulation_b048d748_1_checkTargets(\n    &smData->mSimRuntimeDerivedValuesBundle,\n    assemblyFullStateVector);\n\n#endif\n\n  if (smData->mModeVectorSize > 0) {\n    errorId = simulation_b048d748_1_computeSimModeVector(\n      systemInput->mU.mX,\n      systemInput->mU.mX + 5,\n      systemInput->mV.mX + 5,\n      systemInput->mM.mX,\n      &errorResult,\n      neDiagMgr);\n    if (errorId != NULL)\n      return errorId;\n    memcpy(smData->mCachedModeVector.mX, systemInput->mM.mX,\n           1 * sizeof(int32_T));\n  }\n\n  (*delegate->mConvertStateVector)(\n    NULL, runtimeDerivedValuesBundle, NULL, assemblyFullStateVector,\n    smData->mAssemblyModeVector.mX, systemInput->mM.mX,\n    simulationFullStateVector);\n  for (i = 0; i < smData->mStateVectorSize; ++i)\n    systemInput->mX.mX[i] = simulationFullStateVector[smData->\n      mStateVectorMap.mX[i]];\n  memcpy(systemInput->mD.mX,\n         simulationFullStateVector +\n         smData->mFullStateVectorSize - smData->mDiscreteStateSize,\n         smData->mDiscreteStateSize * sizeof(double));\n  return errorId;\n}\n\ntypedef struct {\n  size_t first;\n  size_t second;\n} SizePair;\n\nstatic void checkMemAllocStatus(int_T status)\n{\n  (void) status;\n}\n\nstatic\n  PmCharVector cStringToCharVector(const char *src)\n{\n  const size_t n = strlen(src);\n  PmCharVector charVect;\n  const int_T status =\n    pm_create_char_vector_fields(&charVect, n + 1, pm_default_allocator());\n  checkMemAllocStatus(status);\n  strcpy(charVect.mX, src);\n  return charVect;\n}\n\nstatic\n  void initBasicAttributes(NeDaePrivateData *smData)\n{\n  size_t i;\n  smData->mStateVectorSize = 26;\n  smData->mFullStateVectorSize = 30;\n  smData->mDiscreteStateSize = 0;\n  smData->mModeVectorSize = 1;\n  smData->mNumZeroCrossings = 1;\n  smData->mInputVectorSize = 5;\n  smData->mOutputVectorSize = 24;\n  smData->mNumConstraintEqns = 6;\n  smData->mFundamentalSampleTime = +0.000000000000000000e+00;\n  for (i = 0; i < 4; ++i)\n    smData->mChecksum[i] = 0;\n}\n\nstatic\n  void initStateVector(NeDaePrivateData *smData)\n{\n  PmAllocator *alloc = pm_default_allocator();\n  const int32_T stateVectorMap[26] = {\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n    10, 11, 12, 17, 18, 19, 20, 21, 22, 23,\n    24, 25, 26, 27, 28, 29\n  };\n\n  const CTarget targets[16] = {\n    { 0, 16, 0, false, 0, 0, \"1\", false, false, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 16, 0, false, 0, 0, \"1\", true, false, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 16, 1, false, 0, 0, \"1\", false, false, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 16, 1, false, 0, 0, \"1\", true, false, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 16, 2, false, 0, 0, \"1\", false, false, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 16, 2, false, 0, 0, \"1\", true, false, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 1, 16, 3, false, 0, 0, \"1\", false, false, +1.000000000000000000e+00, false,\n      4, { +1.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 2, 16, 3, false, 0, 0, \"1\", true, false, +1.000000000000000000e+00, false,\n      3, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 50, 0, false, 0, 0, \"1\", false, true, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 50, 0, false, 0, 0, \"1\", true, true, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 50, 1, false, 0, 0, \"1\", false, true, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 50, 1, false, 0, 0, \"1\", true, true, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 50, 0, false, 0, 3, \"\", false, false, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 50, 0, false, 0, 3, \"\", true, false, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 50, 1, false, 0, 3, \"\", false, false, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } },\n\n    { 0, 50, 1, false, 0, 3, \"\", true, false, +1.000000000000000000e+00, false,\n      1, { +0.000000000000000000e+00, +0.000000000000000000e+00,\n        +0.000000000000000000e+00, +0.000000000000000000e+00 }, { +\n        0.000000000000000000e+00 } }\n  };\n\n  const size_t numTargets = 16;\n  int_T status;\n  size_t i;\n  status = pm_create_real_vector_fields(\n    &smData->mAssemblyFullStateVector, 30, alloc);\n  checkMemAllocStatus(status);\n  status = pm_create_real_vector_fields(\n    &smData->mSimulationFullStateVector, 30, alloc);\n  checkMemAllocStatus(status);\n  status = pm_create_int_vector_fields(\n    &smData->mStateVectorMap, smData->mStateVectorSize, alloc);\n  checkMemAllocStatus(status);\n  memcpy(smData->mStateVectorMap.mX, stateVectorMap,\n         smData->mStateVectorSize * sizeof(int32_T));\n  smData->mNumInternalTargets = 12;\n  smData->mNumInputMotionPrimitives = 2;\n  PM_ALLOCATE_ARRAY(smData->mTargets, CTarget, numTargets, alloc);\n  for (i = 0; i < numTargets; ++i)\n    sm_compiler_CTarget_copy(targets + i, smData->mTargets + i);\n}\n\nstatic void initAsserts(NeDaePrivateData *smData)\n{\n  PmAllocator *alloc = pm_default_allocator();\n  int_T status = 0;\n  smData->mNumParamAsserts = 0;\n  smData->mParamAssertObjects = NULL;\n  smData->mParamAssertPaths = NULL;\n  smData->mParamAssertDescriptors = NULL;\n  smData->mParamAssertMessages = NULL;\n  smData->mParamAssertMessageIds = NULL;\n  status = pm_create_bool_vector_fields(\n    &smData->mParamAssertIsWarnings, smData->mNumParamAsserts, alloc);\n  checkMemAllocStatus(status);\n  if (smData->mNumParamAsserts > 0) {\n    const NeAssertData *ad = simulation_b048d748_1_assertData;\n    size_t i;\n    PM_ALLOCATE_ARRAY(smData->mParamAssertObjects,\n                      PmCharVector, 0, alloc);\n    PM_ALLOCATE_ARRAY(smData->mParamAssertPaths,\n                      PmCharVector, 0, alloc);\n    PM_ALLOCATE_ARRAY(smData->mParamAssertDescriptors,\n                      PmCharVector, 0, alloc);\n    PM_ALLOCATE_ARRAY(smData->mParamAssertMessages,\n                      PmCharVector, 0, alloc);\n    PM_ALLOCATE_ARRAY(smData->mParamAssertMessageIds,\n                      PmCharVector, 0, alloc);\n    for (i = 0; i < smData->mNumParamAsserts; ++i, ++ad) {\n      smData->mParamAssertObjects [i] = cStringToCharVector(ad->mObject );\n      smData->mParamAssertPaths [i] = cStringToCharVector(ad->mPath );\n      smData->mParamAssertDescriptors[i] = cStringToCharVector(ad->mDescriptor);\n      smData->mParamAssertMessages [i] = cStringToCharVector(ad->mMessage );\n      smData->mParamAssertMessageIds [i] = cStringToCharVector(ad->mMessageID );\n      smData->mParamAssertIsWarnings.mX[i] = ad->mIsWarn;\n    }\n  }\n}\n\nstatic\n  void initModeVector(NeDaePrivateData *smData)\n{\n  {\n    size_t i;\n    const int_T status = pm_create_int_vector_fields(\n      &smData->mAssemblyModeVector, 1,\n      pm_default_allocator());\n    checkMemAllocStatus(status);\n    for (i = 0; i < smData->mAssemblyModeVector.mN; ++i)\n      smData->mAssemblyModeVector.mX[i] = 0;\n  }\n\n  {\n    size_t i;\n    const int_T status = pm_create_int_vector_fields(\n      &smData->mCachedModeVector, 1, pm_default_allocator());\n    checkMemAllocStatus(status);\n    for (i = 0; i < smData->mModeVectorSize; ++i)\n      smData->mCachedModeVector.mX[i] = 0;\n  }\n}\n\nstatic void initZeroCrossings(NeDaePrivateData *smData)\n{\n  PmAllocator *alloc = pm_default_allocator();\n  int_T status = 0;\n  smData->mZeroCrossingObjects = NULL;\n  smData->mZeroCrossingPaths = NULL;\n  smData->mZeroCrossingDescriptors = NULL;\n  status = pm_create_int_vector_fields(\n    &smData->mZeroCrossingTypes, 1, alloc);\n  checkMemAllocStatus(status);\n  if (smData->mNumZeroCrossings > 0) {\n    const NeZCData *zcd = simulation_b048d748_1_ZCData;\n    size_t i;\n    PM_ALLOCATE_ARRAY(smData->mZeroCrossingObjects,\n                      PmCharVector, 1, alloc);\n    PM_ALLOCATE_ARRAY(smData->mZeroCrossingPaths,\n                      PmCharVector, 1, alloc);\n    PM_ALLOCATE_ARRAY(smData->mZeroCrossingDescriptors,\n                      PmCharVector, 1, alloc);\n    for (i = 0; i < smData->mNumZeroCrossings; ++i, ++zcd) {\n      smData->mZeroCrossingObjects [i] = cStringToCharVector(zcd->mObject);\n      smData->mZeroCrossingPaths [i] = cStringToCharVector(zcd->mPath );\n      smData->mZeroCrossingDescriptors[i] = cStringToCharVector(zcd->mDescriptor);\n      smData->mZeroCrossingTypes.mX[i] = zcd->mType;\n    }\n  }\n}\n\nstatic\n  void initVariables(NeDaePrivateData *smData)\n{\n  const char *varFullPaths[26] = {\n    \"Plant.Rocket_Body.Free_Movement.Px.p\",\n    \"Plant.Rocket_Body.Free_Movement.Py.p\",\n    \"Plant.Rocket_Body.Free_Movement.Pz.p\",\n    \"Plant.Rocket_Body.Free_Movement.S.Q\",\n    \"Plant.Rocket_Body.Free_Movement.S.Q\",\n    \"Plant.Rocket_Body.Free_Movement.S.Q\",\n    \"Plant.Rocket_Body.Free_Movement.S.Q\",\n    \"Plant.Rocket_Body.Free_Movement.Px.v\",\n    \"Plant.Rocket_Body.Free_Movement.Py.v\",\n    \"Plant.Rocket_Body.Free_Movement.Pz.v\",\n    \"Plant.Rocket_Body.Free_Movement.S.w\",\n    \"Plant.Rocket_Body.Free_Movement.S.w\",\n    \"Plant.Rocket_Body.Free_Movement.S.w\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.Px.p\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.Py.p\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.Pz.p\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.S.Q\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.S.Q\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.S.Q\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.S.Q\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.Px.v\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.Py.v\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.Pz.v\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.S.w\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.S.w\",\n    \"Plant.TVC_Physics.Rigid_Transform2.implicit6dof1.S.w\"\n  };\n\n  const char *varObjects[26] = {\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ Rocket Body/Free Movement\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\",\n    \"simulation/Plant/ TVC Physics/Rigid Transform2\"\n  };\n\n  smData->mNumVarScalars = 26;\n  smData->mVarFullPaths = NULL;\n  smData->mVarObjects = NULL;\n  if (smData->mNumVarScalars > 0) {\n    size_t s;\n    PmAllocator *alloc = pm_default_allocator();\n    PM_ALLOCATE_ARRAY(smData->mVarFullPaths, PmCharVector, 26, alloc);\n    PM_ALLOCATE_ARRAY(smData->mVarObjects, PmCharVector, 26, alloc);\n    for (s = 0; s < smData->mNumVarScalars; ++s) {\n      smData->mVarFullPaths[s] = cStringToCharVector(varFullPaths[s]);\n      smData->mVarObjects[s] = cStringToCharVector(varObjects[s]);\n    }\n  }\n}\n\nstatic\n  void initRuntimeParameters(NeDaePrivateData *smData)\n{\n  PmAllocator *alloc = pm_default_allocator();\n  int_T status = 0;\n  size_t i = 0;\n  const int32_T *rtpRootVarRows = NULL;\n  const int32_T *rtpRootVarCols = NULL;\n  const char **rtpFullPaths = NULL;\n  smData->mNumRtpRootVars = 0;\n  status = pm_create_int_vector_fields(\n    &smData->mRtpRootVarRows, smData->mNumRtpRootVars, alloc);\n  checkMemAllocStatus(status);\n  memcpy(smData->mRtpRootVarRows.mX, rtpRootVarRows,\n         smData->mNumRtpRootVars * sizeof(int32_T));\n  status = pm_create_int_vector_fields(\n    &smData->mRtpRootVarCols, smData->mNumRtpRootVars, alloc);\n  checkMemAllocStatus(status);\n  memcpy(smData->mRtpRootVarCols.mX, rtpRootVarCols,\n         smData->mNumRtpRootVars * sizeof(int32_T));\n  smData->mRtpFullPaths = NULL;\n  if (smData->mNumRtpRootVars > 0) {\n    size_t v;\n    PM_ALLOCATE_ARRAY(smData->mRtpFullPaths, PmCharVector, 0, alloc);\n    for (v = 0; v < smData->mNumRtpRootVars; ++v) {\n      smData->mRtpFullPaths[v] = cStringToCharVector(rtpFullPaths[v]);\n    }\n  }\n\n  smData->mNumRuntimeRootVarScalars = 0;\n  status = pm_create_real_vector_fields(\n    &smData->mRuntimeParameterScalars, 0,\n    alloc);\n  checkMemAllocStatus(status);\n  for (i = 0; i < smData->mRuntimeParameterScalars.mN; ++i)\n    smData->mRuntimeParameterScalars.mX[i] = 0.0;\n  sm_core_RuntimeDerivedValuesBundle_create(\n    &smData->mAsmRuntimeDerivedValuesBundle,\n    0,\n    0);\n  sm_core_RuntimeDerivedValuesBundle_create(\n    &smData->mSimRuntimeDerivedValuesBundle,\n    0,\n    0);\n}\n\nstatic\n  void initIoInfoHelper(\n  size_t n,\n  const char *portPathsSource[],\n  const char *unitsSource[],\n  const SizePair dimensions[],\n  boolean_T doInputs,\n  NeDaePrivateData *smData)\n{\n  PmCharVector *portPaths = NULL;\n  PmCharVector *units = NULL;\n  SscIoInfo *infos = NULL;\n  if (n > 0) {\n    size_t s;\n    PmAllocator *alloc = pm_default_allocator();\n    PM_ALLOCATE_ARRAY(portPaths, PmCharVector, n, alloc);\n    PM_ALLOCATE_ARRAY(units, PmCharVector, n, alloc);\n    PM_ALLOCATE_ARRAY(infos, SscIoInfo, n, alloc);\n    for (s = 0; s < n; ++s) {\n      portPaths[s] = cStringToCharVector(portPathsSource[s]);\n      units[s] = cStringToCharVector(unitsSource[s]);\n\n      {\n        SscIoInfo *info = infos + s;\n        info->mName = info->mIdentifier = portPaths[s].mX;\n        ssc_array_size_set_scalar(&info->mSize);\n        ssc_array_size_set_dim(&info->mSize, 0, dimensions[s].first);\n        ssc_array_size_set_dim(&info->mSize, 1, dimensions[s].second);\n        info->mUnit = units[s].mX;\n      }\n    }\n  }\n\n  if (doInputs) {\n    smData->mNumInputs = n;\n    smData->mInputPortPaths = portPaths;\n    smData->mInputUnits = units;\n    smData->mInputInfos = infos;\n  } else {\n    smData->mNumOutputs = n;\n    smData->mOutputPortPaths = portPaths;\n    smData->mOutputUnits = units;\n    smData->mOutputInfos = infos;\n  }\n}\n\nstatic\n  void initIoInfo(NeDaePrivateData *smData)\n{\n  const char *inputPortPaths[5] = {\n    \"Plant.TVC_Physics.Universal_Joint.qxi\",\n    \"Plant.TVC_Physics.Universal_Joint.qyi\",\n    \"Plant.TVC_Physics.Staging_Joint.mode\",\n    \"Plant.TVC_Physics.External_Force_and_Torque.fz\",\n    \"Plant.TVC_Physics.Stage_2_Thrust.fz\"\n  };\n\n  const char *inputUnits[5] = {\n    \"rad\",\n    \"rad\",\n    \"1\",\n    \"kg*m/s^2\",\n    \"kg*m/s^2\"\n  };\n\n  const SizePair inputDimensions[5] = {\n    { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 },\n\n    { 1, 1 }\n  };\n\n  const char *outputPortPaths[18] = {\n    \"Plant.Rocket_Body.Free_Movement.px\",\n    \"Plant.Rocket_Body.Free_Movement.vx\",\n    \"Plant.Rocket_Body.Free_Movement.ax\",\n    \"Plant.Rocket_Body.Free_Movement.py\",\n    \"Plant.Rocket_Body.Free_Movement.vy\",\n    \"Plant.Rocket_Body.Free_Movement.ay\",\n    \"Plant.Rocket_Body.Free_Movement.pz\",\n    \"Plant.Rocket_Body.Free_Movement.vz\",\n    \"Plant.Rocket_Body.Free_Movement.az\",\n    \"Plant.Rocket_Body.Free_Movement.Q\",\n    \"Plant.Rocket_Body.Spatial_Contact_Force.con\",\n    \"Plant.Rocket_Body.Subsystem.IMU_Sensor.Q\",\n    \"Plant.Rocket_Body.Subsystem.IMU_Sensor.wx\",\n    \"Plant.Rocket_Body.Subsystem.IMU_Sensor.wy\",\n    \"Plant.Rocket_Body.Subsystem.IMU_Sensor.wz\",\n    \"Plant.Rocket_Body.Subsystem.IMU_Sensor.ax\",\n    \"Plant.Rocket_Body.Subsystem.IMU_Sensor.ay\",\n    \"Plant.Rocket_Body.Subsystem.IMU_Sensor.az\"\n  };\n\n  const char *outputUnits[18] = {\n    \"m\",\n    \"m/s\",\n    \"m/s^2\",\n    \"m\",\n    \"m/s\",\n    \"m/s^2\",\n    \"m\",\n    \"m/s\",\n    \"m/s^2\",\n    \"1\",\n    \"1\",\n    \"1\",\n    \"rad/s\",\n    \"rad/s\",\n    \"rad/s\",\n    \"m/s^2\",\n    \"m/s^2\",\n    \"m/s^2\"\n  };\n\n  const SizePair outputDimensions[18] = {\n    { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 },\n\n    { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 },\n\n    { 1, 1 }, { 4, 1 }, { 1, 1 }, { 4, 1 },\n\n    { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 },\n\n    { 1, 1 }, { 1, 1 }\n  };\n\n  initIoInfoHelper(5, inputPortPaths, inputUnits, inputDimensions,\n                   true, smData);\n  initIoInfoHelper(18, outputPortPaths, outputUnits, outputDimensions,\n                   false, smData);\n}\n\nstatic\n  void initInputDerivs(NeDaePrivateData *smData)\n{\n  const int32_T numInputDerivs[5] = {\n    2, 2, 0, 0, 0\n  };\n\n  PmAllocator *alloc = pm_default_allocator();\n  const int_T status = pm_create_int_vector_fields(\n    &smData->mNumInputDerivs, smData->mInputVectorSize, alloc);\n  checkMemAllocStatus(status);\n  memcpy(smData->mNumInputDerivs.mX, numInputDerivs,\n         5 * sizeof(int32_T));\n  smData->mInputOrder = 2;\n}\n\nstatic\n  void initDirectFeedthrough(NeDaePrivateData *smData)\n{\n  const boolean_T directFeedthroughVector[5] = {\n    true, true, true, false, false\n  };\n\n  const boolean_T directFeedthroughMatrix[240] = {\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, false, false, true, false, false, true, false, false,\n    true, false, false, false, false, false, false, false, false, false,\n    false, false, false, true, true, true, false, false, true, false,\n    false, true, false, false, true, false, false, false, false, false,\n    false, false, false, false, false, false, false, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, true, true, true, true, true, true, true, true,\n    true, true, false, false, true, false, false, true, false, false,\n    true, false, false, false, false, false, false, false, false, false,\n    false, false, false, true, true, true, false, false, true, false,\n    false, true, false, false, true, false, false, false, false, false,\n    false, false, false, false, false, false, false, true, true, true\n  };\n\n  PmAllocator *alloc = pm_default_allocator();\n\n  {\n    const int_T status = pm_create_bool_vector_fields(\n      &smData->mDirectFeedthroughVector, 5, alloc);\n    checkMemAllocStatus(status);\n    memcpy(smData->mDirectFeedthroughVector.mX, directFeedthroughVector,\n           5 * sizeof(boolean_T));\n  }\n\n  {\n    const int_T status = pm_create_bool_vector_fields(\n      &smData->mDirectFeedthroughMatrix, 240, alloc);\n    checkMemAllocStatus(status);\n    memcpy(smData->mDirectFeedthroughMatrix.mX, directFeedthroughMatrix,\n           240 * sizeof(boolean_T));\n  }\n}\n\nstatic\n  void initOutputDerivProc(NeDaePrivateData *smData)\n{\n  PmAllocator *alloc = pm_default_allocator();\n  const int32_T outputFunctionMap[24] = {\n    0, 0, 1, 0, 0, 1, 0, 0, 1, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, 1, 1\n  };\n\n  smData->mOutputFunctionMap = pm_create_int_vector(24, alloc);\n  memcpy(smData->mOutputFunctionMap->mX, outputFunctionMap,\n         24 * sizeof(int32_T));\n  smData->mNumOutputClasses = 2;\n  smData->mHasKinematicOutputs = true;\n  smData->mHasDynamicOutputs = true;\n  smData->mIsOutputClass0Dynamic = false;\n  smData->mDoComputeDynamicOutputs = false;\n  smData->mCachedDerivativesAvailable = false;\n\n  {\n    size_t i = 0;\n    const int_T status = pm_create_real_vector_fields(\n      &smData->mCachedDerivatives, 26, pm_default_allocator());\n    checkMemAllocStatus(status);\n    for (i = 0; i < smData->mCachedDerivatives.mN; ++i)\n      smData->mCachedDerivatives.mX[i] = 0.0;\n  }\n}\n\n#if 0\n\nstatic void initializeSizePairVector(const SmSizePair *data,\n  SmSizePairVector *vector)\n{\n  const size_t n = sm_core_SmSizePairVector_size(vector);\n  size_t i;\n  for (i = 0; i < n; ++i, ++data)\n    sm_core_SmSizePairVector_setValue(vector, i, data++);\n}\n\n#endif\n\nstatic\n  void initAssemblyDelegate(SmMechanismDelegate *delegate)\n{\n  SmMechanismDelegateScratchpad *scratchpad = NULL;\n  const SmSizePair jointToStageIdx[2] = {\n    { 16, 0 }, { 50, 1 }\n  };\n\n  const size_t primitiveIndices[3 + 1] = {\n    0, 4, 6, 10\n  };\n\n  const SmSizePair stateOffsets[10] = {\n    { 0, 7 }, { 1, 8 }, { 2, 9 }, { 3, 10 }, { 13, 15 }, { 14, 16 },\n\n    { 17, 24 }, { 18, 25 }, { 19, 26 }, { 20, 27 }\n  };\n\n  const SmSizePair dofOffsets[10] = {\n    { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 6 }, { 6, 7 }, { 7, 8 },\n\n    { 8, 9 }, { 9, 10 }, { 10, 11 }, { 11, 14 }\n  };\n\n  const size_t *flexibleStages = NULL;\n  const size_t remodIndices[2] = {\n    13, 14\n  };\n\n  const size_t equationsPerConstraint[1] = {\n    6\n  };\n\n  const int32_T hasAllVelocityDisabledEquations[1] = {\n    0\n  };\n\n  const int32_T runtimeEnabledEquations[6] = {\n    1, 1, 1, 1, 1, 1\n  };\n\n  const size_t dofToVelSlot[14] = {\n    7, 8, 9, 10, 11, 12, 15, 16, 24, 25,\n    26, 27, 28, 29\n  };\n\n  const size_t constraintDofs[14] = {\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n    10, 11, 12, 13\n  };\n\n  const size_t constraintDofOffsets[1 + 1] = {\n    0, 14\n  };\n\n  const size_t Jm = 6;\n  const size_t Jn = 14;\n  SmSizePair zeroSizePair;\n  zeroSizePair.mFirst = zeroSizePair.mSecond = 0;\n  sm_core_MechanismDelegate_allocScratchpad(delegate);\n  scratchpad = delegate->mScratchpad;\n  delegate->mTargetStrengthFree = 0;\n  delegate->mTargetStrengthSuggested = 1;\n  delegate->mTargetStrengthDesired = 2;\n  delegate->mTargetStrengthRequired = 3;\n  delegate->mConsistencyTol = +1.000000000000000062e-09;\n  delegate->mTreeJointDof = 14;\n  delegate->mDof = 14;\n  delegate->mStateSize = 30;\n  delegate->mContinuousStateSize = 30;\n  delegate->mModeVectorSize = 1;\n  delegate->mNumStages = 3;\n  delegate->mNumConstraints = 1;\n  delegate->mNumAllConstraintEquations = 6;\n  sm_core_SmSizePairVector_create(\n    &delegate->mJointToStageIdx, 2, &zeroSizePair);\n  memcpy(sm_core_SmSizePairVector_nonConstValues(&delegate->mJointToStageIdx),\n         jointToStageIdx, 2 * sizeof(SmSizePair));\n  sm_core_SmSizeTVector_create(\n    &delegate->mPrimitiveIndices, delegate->mNumStages + 1, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mPrimitiveIndices),\n         primitiveIndices, (delegate->mNumStages + 1) * sizeof(size_t));\n  sm_core_SmSizePairVector_create(\n    &delegate->mStateOffsets, 10, &zeroSizePair);\n  memcpy(sm_core_SmSizePairVector_nonConstValues(&delegate->mStateOffsets),\n         stateOffsets, 10 * sizeof(SmSizePair));\n  sm_core_SmSizePairVector_create(\n    &delegate->mDofOffsets, 10, &zeroSizePair);\n  memcpy(sm_core_SmSizePairVector_nonConstValues(&delegate->mDofOffsets),\n         dofOffsets, 10 * sizeof(SmSizePair));\n  sm_core_SmSizeTVector_create(\n    &delegate->mFlexibleStages, 0, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mFlexibleStages),\n         flexibleStages, 0 * sizeof(size_t));\n  sm_core_SmSizeTVector_create(\n    &delegate->mRemodIndices, 2, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mRemodIndices),\n         remodIndices, 2 * sizeof(size_t));\n  sm_core_SmSizeTVector_create(\n    &delegate->mEquationsPerConstraint, delegate->mNumConstraints, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mEquationsPerConstraint),\n         equationsPerConstraint, delegate->mNumConstraints * sizeof(size_t));\n  sm_core_SmIntVector_create(\n    &delegate->mHasAllVelocityDisabledEquations, delegate->mNumConstraints, 0);\n  memcpy(\n         sm_core_SmIntVector_nonConstValues\n         (&delegate->mHasAllVelocityDisabledEquations),\n         hasAllVelocityDisabledEquations, delegate->mNumConstraints * sizeof\n         (int32_T));\n  sm_core_SmIntVector_create(\n    &delegate->mRunTimeEnabledEquations,\n    delegate->mNumAllConstraintEquations, 0);\n  memcpy(\n         sm_core_SmIntVector_nonConstValues(&delegate->mRunTimeEnabledEquations),\n         runtimeEnabledEquations, delegate->mNumAllConstraintEquations *\n         sizeof(int32_T));\n  sm_core_SmSizeTVector_create(\n    &delegate->mDofToVelSlot, delegate->mDof, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mDofToVelSlot),\n         dofToVelSlot, delegate->mDof * sizeof(size_t));\n  sm_core_SmSizeTVector_create(\n    &delegate->mConstraintDofs, 14, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mConstraintDofs),\n         constraintDofs, 14 * sizeof(size_t));\n  sm_core_SmSizeTVector_create(\n    &delegate->mConstraintDofOffsets, delegate->mNumConstraints + 1, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mConstraintDofOffsets),\n         constraintDofOffsets, (delegate->mNumConstraints + 1) * sizeof(size_t));\n  sm_core_SmBoundedSet_create(&scratchpad->mPosRequired, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mPosDesired, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mPosSuggested, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mPosFree, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mPosNonRequired, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mPosSuggAndFree, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mVelRequired, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mVelDesired, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mVelSuggested, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mVelFree, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mVelNonRequired, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mVelSuggAndFree, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mConstraintFilter, 1);\n  sm_core_SmBoundedSet_create(&scratchpad->mActiveConstraints, 1);\n  sm_core_SmBoundedSet_create(&scratchpad->mActiveDofs, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mActiveDofs0, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mNewConstraints, 1);\n  sm_core_SmBoundedSet_create(&scratchpad->mNewDofs, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mUnsatisfiedConstraints, 1);\n  sm_core_SmSizeTVector_create(&scratchpad->mActiveConstraintsVect,\n    1, 0);\n  sm_core_SmSizeTVector_create(&scratchpad->mActiveDofsVect, 14, 0);\n  sm_core_SmSizeTVector_create(&scratchpad->mFullDofToActiveDof, 14, 0);\n  sm_core_SmSizePairVector_create(\n    &scratchpad->mPartiallyPosTargetedPrims, 10, &zeroSizePair);\n  sm_core_SmSizePairVector_create(\n    &scratchpad->mPartiallyVelTargetedPrims, 10, &zeroSizePair);\n  sm_core_SmSizeTVector_create(&scratchpad->mPosPartialTypes, 10, 0);\n  sm_core_SmSizeTVector_create(&scratchpad->mVelPartialTypes, 10, 0);\n  sm_core_SmSizeTVector_create(&scratchpad->mPartiallyActivePrims, 10, 0);\n  sm_core_SmSizePairVector_create(\n    &scratchpad->mBaseFrameVelOffsets, 2, &zeroSizePair);\n  sm_core_SmSizePairVector_create(&scratchpad->mCvQuaternionVelOffsets,\n    0,\n    &zeroSizePair);\n  sm_core_SmRealVector_create(&scratchpad->mCvQuaternionAzimuthValues,\n    0, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mInitialState, 30, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mStartState, 30, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mTestState, 30, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mFullStateVector, 30, 0.0);\n  sm_core_SmIntVector_create(&scratchpad->mModeVector, 1, 0);\n  sm_core_SmRealVector_create(&scratchpad->mJacobianRowMaj, Jm * Jn, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mJacobian, Jm * Jn, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mJacobianPrimSubmatrix, Jm * 6, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mConstraintNonhomoTerms, Jm, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mConstraintError, Jm, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mBestConstraintError, Jm, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mDeltas,\n    Jn * (Jm <= Jn ? Jm : Jn), 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mSvdWork, 453, 0.0);\n  sm_core_SmRealVector_create(\n    &scratchpad->mLineSearchScaledDeltaVect, 14, 0.0);\n  sm_core_SmRealVector_create(\n    &scratchpad->mLineSearchTestStateVect, 30, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mLineSearchErrorVect, Jm, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mActiveDofVelsVect, 14, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mVelSystemRhs, Jm, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mMotionData, 46, 0.0);\n  delegate->mSetTargets = simulation_b048d748_1_setTargets;\n  delegate->mResetStateVector = simulation_b048d748_1_resetAsmStateVector;\n  delegate->mInitializeTrackedAngleState =\n    simulation_b048d748_1_initializeTrackedAngleState;\n  delegate->mComputeDiscreteState = simulation_b048d748_1_computeDiscreteState;\n  delegate->mAdjustPosition = simulation_b048d748_1_adjustPosition;\n  delegate->mPerturbJointPrimitiveState =\n    simulation_b048d748_1_perturbAsmJointPrimitiveState;\n  delegate->mPerturbFlexibleBodyState = NULL;\n  delegate->mComputePosDofBlendMatrix =\n    simulation_b048d748_1_computePosDofBlendMatrix;\n  delegate->mComputeVelDofBlendMatrix =\n    simulation_b048d748_1_computeVelDofBlendMatrix;\n  delegate->mProjectPartiallyTargetedPos =\n    simulation_b048d748_1_projectPartiallyTargetedPos;\n  delegate->mPropagateMotion = simulation_b048d748_1_propagateMotion;\n  delegate->mComputeAssemblyError = simulation_b048d748_1_computeAssemblyError;\n  delegate->mComputeAssemblyJacobian =\n    simulation_b048d748_1_computeAssemblyJacobian;\n  delegate->mComputeFullAssemblyJacobian =\n    simulation_b048d748_1_computeFullAssemblyJacobian;\n  delegate->mIsInKinematicSingularity =\n    simulation_b048d748_1_isInKinematicSingularity;\n  delegate->mConvertStateVector = simulation_b048d748_1_convertStateVector;\n  delegate->mConstructStateVector = NULL;\n  delegate->mExtractSolverStateVector = NULL;\n  delegate->mIsPositionViolation = NULL;\n  delegate->mIsVelocityViolation = NULL;\n  delegate->mProjectStateSim = NULL;\n  delegate->mComputeConstraintError = NULL;\n  delegate->mResetModeVector = NULL;\n  delegate->mHasJointDisToNormModeChange = NULL;\n  delegate->mPerformJointDisToNormModeChange = NULL;\n  delegate->mOnModeChangedCutJoints = NULL;\n  delegate->mMech = NULL;\n}\n\nstatic\n  void initSimulationDelegate(SmMechanismDelegate *delegate)\n{\n  SmMechanismDelegateScratchpad *scratchpad = NULL;\n  const SmSizePair jointToStageIdx[2] = {\n    { 16, 0 }, { 50, 1 }\n  };\n\n  const size_t primitiveIndices[3 + 1] = {\n    0, 4, 6, 10\n  };\n\n  const SmSizePair stateOffsets[10] = {\n    { 0, 7 }, { 1, 8 }, { 2, 9 }, { 3, 10 }, { 13, 15 }, { 14, 16 },\n\n    { 17, 24 }, { 18, 25 }, { 19, 26 }, { 20, 27 }\n  };\n\n  const SmSizePair dofOffsets[10] = {\n    { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 6 }, { 6, 7 }, { 7, 8 },\n\n    { 8, 9 }, { 9, 10 }, { 10, 11 }, { 11, 14 }\n  };\n\n  const size_t *flexibleStages = NULL;\n  const size_t remodIndices[2] = {\n    13, 14\n  };\n\n  const size_t equationsPerConstraint[1] = {\n    6\n  };\n\n  const int32_T hasAllVelocityDisabledEquations[1] = {\n    0\n  };\n\n  const int32_T runtimeEnabledEquations[6] = {\n    1, 1, 1, 1, 1, 1\n  };\n\n  const size_t dofToVelSlot[14] = {\n    7, 8, 9, 10, 11, 12, 15, 16, 24, 25,\n    26, 27, 28, 29\n  };\n\n  const size_t constraintDofs[14] = {\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n    10, 11, 12, 13\n  };\n\n  const size_t constraintDofOffsets[1 + 1] = {\n    0, 14\n  };\n\n  const size_t Jm = 6;\n  const size_t Jn = 14;\n  SmSizePair zeroSizePair;\n  zeroSizePair.mFirst = zeroSizePair.mSecond = 0;\n  sm_core_MechanismDelegate_allocScratchpad(delegate);\n  scratchpad = delegate->mScratchpad;\n  delegate->mTargetStrengthFree = 0;\n  delegate->mTargetStrengthSuggested = 1;\n  delegate->mTargetStrengthDesired = 2;\n  delegate->mTargetStrengthRequired = 3;\n  delegate->mConsistencyTol = +1.000000000000000062e-09;\n  delegate->mTreeJointDof = 14;\n  delegate->mDof = 14;\n  delegate->mStateSize = 30;\n  delegate->mContinuousStateSize = 30;\n  delegate->mModeVectorSize = 1;\n  delegate->mNumStages = 3;\n  delegate->mNumConstraints = 1;\n  delegate->mNumAllConstraintEquations = 6;\n  sm_core_SmSizePairVector_create(\n    &delegate->mJointToStageIdx, 2, &zeroSizePair);\n  memcpy(sm_core_SmSizePairVector_nonConstValues(&delegate->mJointToStageIdx),\n         jointToStageIdx, 2 * sizeof(SmSizePair));\n  sm_core_SmSizeTVector_create(\n    &delegate->mPrimitiveIndices, delegate->mNumStages + 1, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mPrimitiveIndices),\n         primitiveIndices, (delegate->mNumStages + 1) * sizeof(size_t));\n  sm_core_SmSizePairVector_create(\n    &delegate->mStateOffsets, 10, &zeroSizePair);\n  memcpy(sm_core_SmSizePairVector_nonConstValues(&delegate->mStateOffsets),\n         stateOffsets, 10 * sizeof(SmSizePair));\n  sm_core_SmSizePairVector_create(\n    &delegate->mDofOffsets, 10, &zeroSizePair);\n  memcpy(sm_core_SmSizePairVector_nonConstValues(&delegate->mDofOffsets),\n         dofOffsets, 10 * sizeof(SmSizePair));\n  sm_core_SmSizeTVector_create(\n    &delegate->mFlexibleStages, 0, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mFlexibleStages),\n         flexibleStages, 0 * sizeof(size_t));\n  sm_core_SmSizeTVector_create(\n    &delegate->mRemodIndices, 2, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mRemodIndices),\n         remodIndices, 2 * sizeof(size_t));\n  sm_core_SmSizeTVector_create(\n    &delegate->mEquationsPerConstraint, delegate->mNumConstraints, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mEquationsPerConstraint),\n         equationsPerConstraint, delegate->mNumConstraints * sizeof(size_t));\n  sm_core_SmIntVector_create(\n    &delegate->mHasAllVelocityDisabledEquations, delegate->mNumConstraints, 0);\n  memcpy(sm_core_SmIntVector_nonConstValues\n         (&delegate->mHasAllVelocityDisabledEquations),\n         hasAllVelocityDisabledEquations, delegate->mNumConstraints * sizeof\n         (int32_T));\n  sm_core_SmIntVector_create(\n    &delegate->mRunTimeEnabledEquations,\n    delegate->mNumAllConstraintEquations, 0);\n  memcpy(\n         sm_core_SmIntVector_nonConstValues(&delegate->mRunTimeEnabledEquations),\n         runtimeEnabledEquations, delegate->mNumAllConstraintEquations *\n         sizeof(int32_T));\n  sm_core_SmSizeTVector_create(\n    &delegate->mDofToVelSlot, delegate->mDof, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mDofToVelSlot),\n         dofToVelSlot, delegate->mDof * sizeof(size_t));\n  sm_core_SmSizeTVector_create(\n    &delegate->mConstraintDofs, 14, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mConstraintDofs),\n         constraintDofs, 14 * sizeof(size_t));\n  sm_core_SmSizeTVector_create(\n    &delegate->mConstraintDofOffsets, delegate->mNumConstraints + 1, 0);\n  memcpy(sm_core_SmSizeTVector_nonConstValues(&delegate->mConstraintDofOffsets),\n         constraintDofOffsets, (delegate->mNumConstraints + 1) * sizeof(size_t));\n  sm_core_SmBoundedSet_create(&scratchpad->mPosRequired, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mPosDesired, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mPosSuggested, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mPosFree, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mPosNonRequired, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mPosSuggAndFree, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mVelRequired, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mVelDesired, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mVelSuggested, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mVelFree, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mVelNonRequired, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mVelSuggAndFree, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mConstraintFilter, 1);\n  sm_core_SmBoundedSet_create(&scratchpad->mActiveConstraints, 1);\n  sm_core_SmBoundedSet_create(&scratchpad->mActiveDofs, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mActiveDofs0, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mNewConstraints, 1);\n  sm_core_SmBoundedSet_create(&scratchpad->mNewDofs, 14);\n  sm_core_SmBoundedSet_create(&scratchpad->mUnsatisfiedConstraints, 1);\n  sm_core_SmSizeTVector_create(&scratchpad->mActiveConstraintsVect,\n    1, 0);\n  sm_core_SmSizeTVector_create(&scratchpad->mActiveDofsVect, 14, 0);\n  sm_core_SmSizeTVector_create(&scratchpad->mFullDofToActiveDof, 14, 0);\n  sm_core_SmSizePairVector_create(\n    &scratchpad->mPartiallyPosTargetedPrims, 10, &zeroSizePair);\n  sm_core_SmSizePairVector_create(\n    &scratchpad->mPartiallyVelTargetedPrims, 10, &zeroSizePair);\n  sm_core_SmSizeTVector_create(&scratchpad->mPosPartialTypes, 10, 0);\n  sm_core_SmSizeTVector_create(&scratchpad->mVelPartialTypes, 10, 0);\n  sm_core_SmSizeTVector_create(&scratchpad->mPartiallyActivePrims, 10, 0);\n  sm_core_SmSizePairVector_create(\n    &scratchpad->mBaseFrameVelOffsets, 2, &zeroSizePair);\n  sm_core_SmSizePairVector_create(&scratchpad->mCvQuaternionVelOffsets,\n    0,\n    &zeroSizePair);\n  sm_core_SmRealVector_create(&scratchpad->mCvQuaternionAzimuthValues,\n    0, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mInitialState, 30, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mStartState, 30, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mTestState, 30, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mFullStateVector, 30, 0.0);\n  sm_core_SmIntVector_create(&scratchpad->mModeVector, 1, 0);\n  sm_core_SmRealVector_create(&scratchpad->mJacobianRowMaj, Jm * Jn, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mJacobian, Jm * Jn, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mJacobianPrimSubmatrix, Jm * 6, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mConstraintNonhomoTerms, Jm, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mConstraintError, Jm, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mBestConstraintError, Jm, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mDeltas,\n    Jn * (Jm <= Jn ? Jm : Jn), 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mSvdWork, 453, 0.0);\n  sm_core_SmRealVector_create(\n    &scratchpad->mLineSearchScaledDeltaVect, 14, 0.0);\n  sm_core_SmRealVector_create(\n    &scratchpad->mLineSearchTestStateVect, 30, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mLineSearchErrorVect, Jm, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mActiveDofVelsVect, 14, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mVelSystemRhs, Jm, 0.0);\n  sm_core_SmRealVector_create(&scratchpad->mMotionData, 46, 0.0);\n  delegate->mSetTargets = NULL;\n  delegate->mResetStateVector = simulation_b048d748_1_resetSimStateVector;\n  delegate->mInitializeTrackedAngleState = NULL;\n  delegate->mComputeDiscreteState = NULL;\n  delegate->mAdjustPosition = NULL;\n  delegate->mPerturbJointPrimitiveState =\n    simulation_b048d748_1_perturbSimJointPrimitiveState;\n  delegate->mPerturbFlexibleBodyState =\n    simulation_b048d748_1_perturbFlexibleBodyState;\n  delegate->mComputePosDofBlendMatrix = NULL;\n  delegate->mComputeVelDofBlendMatrix = NULL;\n  delegate->mProjectPartiallyTargetedPos = NULL;\n  delegate->mPropagateMotion = NULL;\n  delegate->mComputeAssemblyError = NULL;\n  delegate->mComputeAssemblyJacobian = NULL;\n  delegate->mComputeFullAssemblyJacobian = NULL;\n  delegate->mIsInKinematicSingularity = NULL;\n  delegate->mConvertStateVector = NULL;\n  delegate->mConstructStateVector = simulation_b048d748_1_constructStateVector;\n  delegate->mExtractSolverStateVector =\n    simulation_b048d748_1_extractSolverStateVector;\n  delegate->mIsPositionViolation = simulation_b048d748_1_isPositionViolation;\n  delegate->mIsVelocityViolation = simulation_b048d748_1_isVelocityViolation;\n  delegate->mProjectStateSim = simulation_b048d748_1_projectStateSim;\n  delegate->mComputeConstraintError =\n    simulation_b048d748_1_computeConstraintError;\n  delegate->mResetModeVector = simulation_b048d748_1_resetModeVector;\n  delegate->mHasJointDisToNormModeChange =\n    simulation_b048d748_1_hasJointDisToNormModeChange;\n  delegate->mPerformJointDisToNormModeChange =\n    simulation_b048d748_1_performJointDisToNormModeChange;\n  delegate->mOnModeChangedCutJoints =\n    simulation_b048d748_1_onModeChangedCutJoints;\n  delegate->mMech = NULL;\n}\n\nstatic\n  void initMechanismDelegates(NeDaePrivateData *smData)\n{\n  PmAllocator *alloc = pm_default_allocator();\n  const int32_T motionInputOffsets[2] = {\n    0, 1\n  };\n\n  int_T status = 0;\n  initAssemblyDelegate(&smData->mAssemblyDelegate);\n  initSimulationDelegate(&smData->mSimulationDelegate);\n  status = pm_create_int_vector_fields(\n    &smData->mMotionInputOffsets, smData->mNumInputMotionPrimitives, alloc);\n  checkMemAllocStatus(status);\n  memcpy(smData->mMotionInputOffsets.mX, motionInputOffsets,\n         2 * sizeof(int32_T));\n}\n\nstatic\n  void initComputationFcnPtrs(NeDaePrivateData *smData)\n{\n  smData->mSetParametersFcn = dae_cg_setParameters_function;\n  smData->mPAssertFcn = dae_cg_pAssert_method;\n  smData->mDerivativeFcn = dae_cg_deriv_method;\n  smData->mNumJacPerturbLoBoundsFcn = dae_cg_numJacPerturbLoBounds_method;\n  smData->mNumJacPerturbHiBoundsFcn = dae_cg_numJacPerturbHiBounds_method;\n  smData->mOutputFcn = dae_cg_compOutputs_method;\n  smData->mModeFcn = dae_cg_mode_method;\n  smData->mZeroCrossingFcn = dae_cg_zeroCrossing_method;\n  smData->mProjectionFcn = dae_cg_project_solve;\n  smData->mCIC_MODE_Fcn = dae_cg_CIC_MODE_solve;\n  smData->mCheckFcn =\n    (smData->mStateVectorSize == 0) ? dae_cg_check_solve : NULL;\n  smData->mAssemblyFcn = dae_cg_assemble_solve;\n  smData->mSetupLoggerFcn = dae_cg_setupLoggerFcn;\n  smData->mLogFcn = dae_cg_recordLog_method;\n  smData->mResidualsFcn = NULL;\n  smData->mLinearizeFcn = NULL;\n  smData->mGenerateFcn = NULL;\n}\n\nstatic\n  void initLiveLinkToSm(NeDaePrivateData *smData)\n{\n  smData->mLiveSmLink = NULL;\n  smData->mLiveSmLink_destroy = NULL;\n  smData->mLiveSmLink_copy = NULL;\n}\n\nvoid simulation_b048d748_1_NeDaePrivateData_create(NeDaePrivateData *smData)\n{\n  initBasicAttributes (smData);\n  initStateVector (smData);\n  initAsserts (smData);\n  initModeVector (smData);\n  initZeroCrossings (smData);\n  initVariables (smData);\n  initRuntimeParameters (smData);\n  initIoInfo (smData);\n  initInputDerivs (smData);\n  initDirectFeedthrough (smData);\n  initOutputDerivProc (smData);\n  initMechanismDelegates (smData);\n  initComputationFcnPtrs (smData);\n  initLiveLinkToSm (smData);\n}\n"},{"name":"simulation_b048d748_1_deriv.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include <math.h>\n#include <string.h>\n#include \"pm_std.h\"\n#include \"sm_std.h\"\n#include \"ne_std.h\"\n#include \"ne_dae.h\"\n#include \"sm_ssci_run_time_errors.h\"\n#include \"sm_RuntimeDerivedValuesBundle.h\"\n#include \"simulation_b048d748_1_geometries.h\"\n\nPmfMessageId simulation_b048d748_1_compDerivs(const RuntimeDerivedValuesBundle\n  *rtdv, const int *eqnEnableFlags, const double *state, const int *modeVector,\n  const double *input, const double *inputDot, const double *inputDdot, const\n  double *discreteState, double *deriv, double *errorResult,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  boolean_T bb[2];\n  int ii[6];\n  double xx[551];\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) eqnEnableFlags;\n  (void) discreteState;\n  (void) neDiagMgr;\n  xx[0] = state[3];\n  xx[1] = state[4];\n  xx[2] = state[5];\n  xx[3] = state[6];\n  xx[4] = state[10];\n  xx[5] = state[11];\n  xx[6] = state[12];\n  pm_math_Quaternion_compDeriv_ra(xx + 0, xx + 4, xx + 7);\n  xx[0] = 1.0;\n  xx[1] = 2.0;\n  xx[2] = state[5] * state[5];\n  xx[3] = state[6] * state[6];\n  xx[11] = xx[1] * (xx[2] + xx[3]);\n  xx[12] = state[4] * state[5];\n  xx[13] = state[3] * state[6];\n  xx[14] = xx[1] * (xx[12] - xx[13]);\n  xx[15] = state[3] * state[5];\n  xx[16] = state[4] * state[6];\n  xx[17] = xx[1] * (xx[15] + xx[16]);\n  xx[18] = xx[0] - xx[11];\n  xx[19] = xx[14];\n  xx[20] = xx[17];\n  xx[21] = 1.1;\n  xx[22] = 0.5;\n  xx[23] = xx[22] * input[0];\n  xx[24] = cos(xx[23]);\n  xx[25] = xx[22] * input[1];\n  xx[22] = cos(xx[25]);\n  xx[26] = xx[24] * xx[22];\n  xx[27] = xx[26] * xx[26];\n  xx[28] = sin(xx[23]);\n  xx[23] = xx[22] * xx[28];\n  xx[29] = xx[23] * xx[23];\n  xx[30] = xx[1] * (xx[27] + xx[29]) - xx[0];\n  xx[31] = sin(xx[25]);\n  xx[32] = xx[24] * xx[31];\n  xx[24] = xx[32] * xx[23];\n  xx[33] = xx[28] * xx[31];\n  xx[28] = xx[26] * xx[33];\n  xx[34] = xx[24] - xx[28];\n  xx[35] = xx[1] * xx[34];\n  xx[36] = xx[23] * xx[33];\n  xx[37] = xx[26] * xx[32];\n  xx[38] = xx[1] * (xx[36] + xx[37]);\n  xx[39] = xx[1] * (xx[24] + xx[28]);\n  xx[40] = xx[32] * xx[32];\n  xx[41] = xx[1] * (xx[27] + xx[40]) - xx[0];\n  xx[42] = xx[32] * xx[33];\n  xx[43] = xx[26] * xx[23];\n  xx[44] = xx[1] * (xx[42] - xx[43]);\n  xx[45] = xx[1] * (xx[36] - xx[37]);\n  xx[46] = xx[1] * (xx[42] + xx[43]);\n  xx[47] = xx[33] * xx[33];\n  xx[48] = xx[1] * (xx[27] + xx[47]) - xx[0];\n  xx[49] = xx[30];\n  xx[50] = xx[35];\n  xx[51] = xx[38];\n  xx[52] = xx[39];\n  xx[53] = xx[41];\n  xx[54] = xx[44];\n  xx[55] = xx[45];\n  xx[56] = xx[46];\n  xx[57] = xx[48];\n  xx[27] = 0.1;\n  xx[58] = xx[27] * xx[30];\n  xx[59] = xx[27] * xx[39];\n  xx[60] = xx[27] * xx[45];\n  xx[61] = xx[27] * xx[35];\n  xx[62] = xx[27] * xx[41];\n  xx[63] = xx[27] * xx[46];\n  xx[64] = xx[27] * xx[38];\n  xx[65] = xx[27] * xx[44];\n  xx[66] = xx[27] * xx[48];\n  pm_math_Matrix3x3_compose_ra(xx + 49, xx + 58, xx + 67);\n  xx[58] = xx[21] + xx[67];\n  xx[59] = xx[21] + xx[71];\n  xx[76] = xx[58];\n  xx[77] = xx[68];\n  xx[78] = xx[69];\n  xx[79] = xx[70];\n  xx[80] = xx[59];\n  xx[81] = xx[72];\n  xx[82] = xx[73];\n  xx[83] = xx[74];\n  xx[84] = xx[21] + xx[75];\n  pm_math_Matrix3x3_xform_ra(xx + 76, xx + 18, xx + 60);\n  xx[21] = xx[1] * (xx[13] + xx[12]);\n  xx[63] = state[4] * state[4];\n  xx[64] = xx[1] * (xx[3] + xx[63]);\n  xx[65] = state[5] * state[6];\n  xx[66] = state[3] * state[4];\n  xx[85] = xx[1] * (xx[65] - xx[66]);\n  xx[86] = xx[21];\n  xx[87] = xx[0] - xx[64];\n  xx[88] = xx[85];\n  pm_math_Matrix3x3_xform_ra(xx + 76, xx + 86, xx + 89);\n  xx[92] = pm_math_Vector3_dot_ra(xx + 18, xx + 89);\n  xx[93] = xx[1] * (xx[16] - xx[15]);\n  xx[94] = xx[1] * (xx[66] + xx[65]);\n  xx[95] = xx[1] * (xx[63] + xx[2]);\n  xx[96] = xx[93];\n  xx[97] = xx[94];\n  xx[98] = xx[0] - xx[95];\n  pm_math_Matrix3x3_xform_ra(xx + 76, xx + 96, xx + 99);\n  xx[102] = pm_math_Vector3_dot_ra(xx + 18, xx + 99);\n  xx[103] = 0.04499999999999999;\n  xx[104] = xx[103] * xx[32];\n  xx[105] = xx[104] * xx[26];\n  xx[106] = xx[103] * xx[23];\n  xx[107] = xx[1] * (xx[105] + xx[106] * xx[33]);\n  xx[108] = xx[1] * (xx[106] * xx[26] - xx[104] * xx[33]);\n  xx[109] = xx[104] * xx[32];\n  xx[110] = xx[1] * (xx[106] * xx[23] + xx[109]) - xx[103] - xx[0];\n  xx[111] = - xx[107];\n  xx[112] = xx[108];\n  xx[113] = xx[110];\n  pm_math_Matrix3x3_postCross_ra(xx + 67, xx + 111, xx + 114);\n  xx[67] = - (xx[114] + xx[68]);\n  xx[68] = xx[117] + xx[59];\n  xx[59] = - xx[68];\n  xx[69] = - (xx[120] + xx[74]);\n  xx[123] = xx[67];\n  xx[124] = xx[59];\n  xx[125] = xx[69];\n  xx[71] = pm_math_Vector3_dot_ra(xx + 18, xx + 123);\n  xx[72] = xx[58] - xx[115];\n  xx[58] = xx[70] - xx[118];\n  xx[70] = xx[73] - xx[121];\n  xx[73] = xx[72];\n  xx[74] = xx[58];\n  xx[75] = xx[70];\n  xx[106] = pm_math_Vector3_dot_ra(xx + 18, xx + 73);\n  xx[126] = - xx[116];\n  xx[127] = - xx[119];\n  xx[128] = - xx[122];\n  xx[129] = pm_math_Vector3_dot_ra(xx + 18, xx + 126);\n  xx[130] = pm_math_Vector3_dot_ra(xx + 86, xx + 99);\n  xx[131] = pm_math_Vector3_dot_ra(xx + 86, xx + 123);\n  xx[132] = pm_math_Vector3_dot_ra(xx + 86, xx + 73);\n  xx[133] = pm_math_Vector3_dot_ra(xx + 86, xx + 126);\n  xx[134] = pm_math_Vector3_dot_ra(xx + 96, xx + 123);\n  xx[123] = pm_math_Vector3_dot_ra(xx + 96, xx + 73);\n  xx[73] = pm_math_Vector3_dot_ra(xx + 96, xx + 126);\n  xx[74] = 1.181250000000001e-4;\n  xx[75] = 1.0125e-4;\n  xx[135] = xx[74] * xx[30];\n  xx[136] = xx[74] * xx[39];\n  xx[137] = xx[74] * xx[45];\n  xx[138] = xx[74] * xx[35];\n  xx[139] = xx[74] * xx[41];\n  xx[140] = xx[74] * xx[46];\n  xx[141] = xx[75] * xx[38];\n  xx[142] = xx[75] * xx[44];\n  xx[143] = xx[75] * xx[48];\n  pm_math_Matrix3x3_compose_ra(xx + 49, xx + 135, xx + 144);\n  pm_math_Matrix3x3_preCross_ra(xx + 114, xx + 111, xx + 135);\n  xx[30] = xx[0] + xx[144] - xx[135] + xx[117];\n  xx[38] = xx[145] - xx[136] - xx[114];\n  xx[39] = xx[38] - xx[58];\n  xx[41] = xx[146] - xx[137];\n  xx[46] = xx[41] + xx[119];\n  xx[48] = xx[0] + xx[148] - xx[139] - xx[115];\n  xx[122] = xx[149] - xx[140];\n  xx[124] = xx[122] - xx[116];\n  xx[125] = xx[0] + xx[152] - xx[143];\n  xx[153] = pm_math_Vector3_dot_ra(xx + 18, xx + 60);\n  xx[154] = xx[92];\n  xx[155] = xx[102];\n  xx[156] = xx[71];\n  xx[157] = xx[106];\n  xx[158] = xx[129];\n  xx[159] = xx[92];\n  xx[160] = pm_math_Vector3_dot_ra(xx + 86, xx + 89);\n  xx[161] = xx[130];\n  xx[162] = xx[131];\n  xx[163] = xx[132];\n  xx[164] = xx[133];\n  xx[165] = xx[102];\n  xx[166] = xx[130];\n  xx[167] = pm_math_Vector3_dot_ra(xx + 96, xx + 99);\n  xx[168] = xx[134];\n  xx[169] = xx[123];\n  xx[170] = xx[73];\n  xx[171] = xx[71];\n  xx[172] = xx[131];\n  xx[173] = xx[134];\n  xx[174] = xx[30] + xx[68];\n  xx[175] = xx[39];\n  xx[176] = xx[46];\n  xx[177] = xx[106];\n  xx[178] = xx[132];\n  xx[179] = xx[123];\n  xx[180] = xx[39];\n  xx[181] = xx[48] + xx[72];\n  xx[182] = xx[124];\n  xx[183] = xx[129];\n  xx[184] = xx[133];\n  xx[185] = xx[73];\n  xx[186] = xx[46];\n  xx[187] = xx[124];\n  xx[188] = xx[125];\n  ii[0] = factorSymmetricPosDef(xx + 153, 6, xx + 129);\n  if (ii[0] != 0) {\n    return sm_ssci_recordRunTimeError(\n      \"physmod:sm:core:compiler:mechanism:mechanism:degenerateMassFoll\",\n      \"'simulation/Plant/ Rocket Body/Free Movement' has a degenerate mass distribution on its follower side.\",\n      neDiagMgr);\n  }\n\n  xx[39] = 0.0;\n  bb[0] = modeVector[0] == -1;\n  xx[46] = xx[0] - xx[1] * (xx[40] + xx[47]);\n  xx[68] = - state[3];\n  xx[71] = - state[4];\n  xx[73] = - state[5];\n  xx[92] = - state[6];\n  xx[129] = xx[68];\n  xx[130] = xx[71];\n  xx[131] = xx[73];\n  xx[132] = xx[92];\n  xx[102] = - xx[23];\n  xx[106] = - xx[32];\n  xx[123] = - xx[33];\n  xx[189] = - xx[26];\n  xx[190] = xx[102];\n  xx[191] = xx[106];\n  xx[192] = xx[123];\n  pm_math_Quaternion_compose_ra(xx + 129, xx + 189, xx + 193);\n  xx[124] = xx[46] * xx[195];\n  xx[133] = xx[1] * (xx[37] + xx[36]);\n  xx[36] = xx[133] * xx[196];\n  xx[37] = xx[46] * xx[194];\n  xx[134] = xx[36] + xx[37];\n  xx[197] = xx[133] * xx[195];\n  xx[198] = xx[124];\n  xx[199] = - xx[134];\n  xx[200] = xx[197];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 198, xx + 201);\n  xx[198] = xx[1] * (xx[124] * xx[193] + xx[201]) - xx[133];\n  xx[199] = xx[1] * (xx[202] - xx[134] * xx[193]);\n  xx[200] = xx[46] + xx[1] * (xx[197] * xx[193] + xx[203]);\n  xx[124] = state[16] * state[16];\n  xx[134] = state[17] * state[17];\n  xx[197] = xx[1] * (xx[124] + xx[134]) - xx[0];\n  xx[201] = state[17] * state[18];\n  xx[202] = state[16] * state[19];\n  xx[203] = xx[1] * (xx[201] + xx[202]);\n  xx[204] = state[17] * state[19];\n  xx[205] = state[16] * state[18];\n  xx[206] = xx[1] * (xx[204] - xx[205]);\n  xx[207] = xx[197];\n  xx[208] = xx[203];\n  xx[209] = xx[206];\n  xx[210] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 198, xx + 207);\n  xx[198] = xx[1] * (xx[28] + xx[24]);\n  xx[24] = xx[198] * xx[195];\n  xx[28] = xx[44] * xx[196];\n  xx[199] = xx[198] * xx[194];\n  xx[200] = xx[28] + xx[199];\n  xx[211] = xx[44] * xx[195];\n  xx[212] = xx[24];\n  xx[213] = - xx[200];\n  xx[214] = xx[211];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 212, xx + 215);\n  xx[212] = xx[1] * (xx[24] * xx[193] + xx[215]) - xx[44];\n  xx[213] = xx[1] * (xx[216] - xx[200] * xx[193]);\n  xx[214] = xx[198] + xx[1] * (xx[211] * xx[193] + xx[217]);\n  xx[24] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 212, xx + 207);\n  xx[200] = xx[45] * xx[195];\n  xx[211] = xx[0] - xx[1] * (xx[29] + xx[40]);\n  xx[40] = xx[211] * xx[196];\n  xx[212] = xx[45] * xx[194];\n  xx[213] = xx[40] + xx[212];\n  xx[214] = xx[211] * xx[195];\n  xx[215] = xx[200];\n  xx[216] = - xx[213];\n  xx[217] = xx[214];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 215, xx + 218);\n  xx[215] = xx[1] * (xx[200] * xx[193] + xx[218]) - xx[211];\n  xx[216] = xx[1] * (xx[219] - xx[213] * xx[193]);\n  xx[217] = xx[45] + xx[1] * (xx[214] * xx[193] + xx[220]);\n  xx[200] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 215, xx + 207);\n  xx[213] = xx[39];\n  xx[214] = xx[39];\n  xx[215] = xx[39];\n  xx[216] = xx[210];\n  xx[217] = xx[24];\n  xx[218] = xx[200];\n  solveSymmetricPosDef(xx + 153, xx + 213, 6, 1, xx + 219, xx + 225);\n  xx[213] = state[18] * state[18];\n  xx[214] = state[19] * state[19];\n  xx[215] = xx[1] * (xx[213] + xx[214]);\n  xx[216] = xx[0] - xx[215];\n  xx[217] = xx[1] * (xx[201] - xx[202]);\n  xx[218] = xx[1] * (xx[205] + xx[204]);\n  xx[219] = xx[27] * xx[216];\n  xx[220] = xx[27] * xx[217];\n  xx[221] = xx[27] * xx[218];\n  xx[225] = xx[1] * (xx[202] + xx[201]);\n  xx[226] = xx[27] * xx[225];\n  xx[227] = xx[1] * (xx[214] + xx[134]);\n  xx[228] = xx[0] - xx[227];\n  xx[229] = xx[27] * xx[228];\n  xx[230] = state[18] * state[19];\n  xx[231] = state[16] * state[17];\n  xx[232] = xx[1] * (xx[230] - xx[231]);\n  xx[233] = xx[27] * xx[232];\n  xx[234] = xx[226];\n  xx[235] = xx[229];\n  xx[236] = xx[233];\n  xx[237] = pm_math_Vector3_dot_ra(xx + 216, xx + 234);\n  xx[238] = xx[27] * xx[206];\n  xx[239] = xx[1] * (xx[231] + xx[230]);\n  xx[240] = xx[27] * xx[239];\n  xx[241] = xx[1] * (xx[134] + xx[213]);\n  xx[134] = xx[0] - xx[241];\n  xx[242] = xx[27] * xx[134];\n  xx[243] = xx[238];\n  xx[244] = xx[240];\n  xx[245] = xx[242];\n  xx[246] = pm_math_Vector3_dot_ra(xx + 216, xx + 243);\n  xx[247] = xx[225];\n  xx[248] = xx[228];\n  xx[249] = xx[232];\n  xx[250] = pm_math_Vector3_dot_ra(xx + 247, xx + 243);\n  xx[251] = xx[206];\n  xx[252] = xx[239];\n  xx[253] = xx[134];\n  xx[254] = 6.750000000000001e-5;\n  xx[255] = pm_math_Vector3_dot_ra(xx + 216, xx + 219);\n  xx[256] = xx[237];\n  xx[257] = xx[246];\n  xx[258] = xx[39];\n  xx[259] = xx[39];\n  xx[260] = xx[39];\n  xx[261] = xx[237];\n  xx[262] = pm_math_Vector3_dot_ra(xx + 247, xx + 234);\n  xx[263] = xx[250];\n  xx[264] = xx[39];\n  xx[265] = xx[39];\n  xx[266] = xx[39];\n  xx[267] = xx[246];\n  xx[268] = xx[250];\n  xx[269] = pm_math_Vector3_dot_ra(xx + 251, xx + 243);\n  xx[270] = xx[39];\n  xx[271] = xx[39];\n  xx[272] = xx[39];\n  xx[273] = xx[39];\n  xx[274] = xx[39];\n  xx[275] = xx[39];\n  xx[276] = xx[254];\n  xx[277] = xx[39];\n  xx[278] = xx[39];\n  xx[279] = xx[39];\n  xx[280] = xx[39];\n  xx[281] = xx[39];\n  xx[282] = xx[39];\n  xx[283] = xx[254];\n  xx[284] = xx[39];\n  xx[285] = xx[39];\n  xx[286] = xx[39];\n  xx[287] = xx[39];\n  xx[288] = xx[39];\n  xx[289] = xx[39];\n  xx[290] = xx[75];\n  ii[0] = factorSymmetricPosDef(xx + 255, 6, xx + 291);\n  if (ii[0] != 0) {\n    return sm_ssci_recordRunTimeError(\n      \"physmod:sm:core:compiler:mechanism:mechanism:degenerateMassImplicit6Dof\",\n      \"An implicit 6-DOF joint is attached to a degenerate mass distribution.\",\n      neDiagMgr);\n  }\n\n  xx[234] = - xx[218];\n  xx[235] = xx[1] * (xx[231] - xx[230]);\n  xx[236] = xx[241] - xx[0];\n  xx[237] = xx[194] * xx[195];\n  xx[241] = xx[193] * xx[196];\n  xx[243] = xx[1] * (xx[237] - xx[241]);\n  xx[244] = xx[193] * xx[193];\n  xx[245] = xx[195] * xx[195];\n  xx[246] = xx[1] * (xx[244] + xx[245]) - xx[0];\n  xx[250] = xx[195] * xx[196];\n  xx[291] = xx[193] * xx[194];\n  xx[292] = xx[1] * (xx[250] + xx[291]);\n  xx[293] = xx[243];\n  xx[294] = xx[246];\n  xx[295] = xx[292];\n  xx[296] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 234, xx + 293);\n  xx[234] = xx[217];\n  xx[235] = xx[228];\n  xx[236] = xx[239];\n  xx[228] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 234, xx + 293);\n  xx[297] = xx[39];\n  xx[298] = xx[39];\n  xx[299] = xx[39];\n  xx[300] = xx[39];\n  xx[301] = xx[296];\n  xx[302] = xx[228];\n  solveSymmetricPosDef(xx + 255, xx + 297, 6, 1, xx + 303, xx + 309);\n  xx[234] = xx[46] * xx[196];\n  xx[235] = xx[35] * xx[196];\n  xx[236] = xx[35] * xx[195];\n  xx[297] = xx[37] + xx[236];\n  xx[298] = xx[234];\n  xx[299] = xx[235];\n  xx[300] = - xx[297];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 298, xx + 301);\n  xx[298] = xx[35] + xx[1] * (xx[234] * xx[193] + xx[301]);\n  xx[299] = xx[1] * (xx[235] * xx[193] + xx[302]) - xx[46];\n  xx[300] = xx[1] * (xx[303] - xx[297] * xx[193]);\n  xx[37] = xx[1] * (xx[124] + xx[213]) - xx[0];\n  xx[213] = xx[1] * (xx[230] + xx[231]);\n  xx[301] = xx[217];\n  xx[302] = xx[37];\n  xx[303] = xx[213];\n  xx[230] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 298, xx + 301);\n  xx[231] = xx[0] - xx[1] * (xx[47] + xx[29]);\n  xx[29] = xx[198] * xx[196];\n  xx[47] = xx[231] * xx[196];\n  xx[234] = xx[231] * xx[195];\n  xx[235] = xx[199] + xx[234];\n  xx[297] = xx[29];\n  xx[298] = xx[47];\n  xx[299] = - xx[235];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 297, xx + 304);\n  xx[297] = xx[231] + xx[1] * (xx[29] * xx[193] + xx[304]);\n  xx[298] = xx[1] * (xx[47] * xx[193] + xx[305]) - xx[198];\n  xx[299] = xx[1] * (xx[306] - xx[235] * xx[193]);\n  xx[29] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 297, xx + 301);\n  xx[47] = xx[1] * (xx[43] + xx[42]);\n  xx[42] = xx[45] * xx[196];\n  xx[43] = xx[47] * xx[196];\n  xx[199] = xx[47] * xx[195];\n  xx[235] = xx[212] + xx[199];\n  xx[297] = xx[42];\n  xx[298] = xx[43];\n  xx[299] = - xx[235];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 297, xx + 304);\n  xx[297] = xx[47] + xx[1] * (xx[42] * xx[193] + xx[304]);\n  xx[298] = xx[1] * (xx[43] * xx[193] + xx[305]) - xx[45];\n  xx[299] = xx[1] * (xx[306] - xx[235] * xx[193]);\n  xx[42] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 297, xx + 301);\n  xx[309] = xx[39];\n  xx[310] = xx[39];\n  xx[311] = xx[39];\n  xx[312] = xx[230];\n  xx[313] = xx[29];\n  xx[314] = xx[42];\n  solveSymmetricPosDef(xx + 153, xx + 309, 6, 1, xx + 315, xx + 321);\n  xx[297] = xx[218];\n  xx[298] = xx[232];\n  xx[299] = xx[134];\n  xx[43] = xx[194] * xx[196];\n  xx[134] = xx[193] * xx[195];\n  xx[212] = xx[1] * (xx[43] + xx[134]);\n  xx[235] = xx[1] * (xx[250] - xx[291]);\n  xx[300] = xx[196] * xx[196];\n  xx[304] = xx[1] * (xx[244] + xx[300]) - xx[0];\n  xx[309] = xx[212];\n  xx[310] = xx[235];\n  xx[311] = xx[304];\n  xx[305] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 297, xx + 309);\n  xx[297] = xx[215] - xx[0];\n  xx[298] = - xx[225];\n  xx[299] = xx[1] * (xx[205] - xx[204]);\n  xx[215] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 297, xx + 309);\n  xx[312] = xx[39];\n  xx[313] = xx[39];\n  xx[314] = xx[39];\n  xx[315] = xx[305];\n  xx[316] = xx[39];\n  xx[317] = xx[215];\n  solveSymmetricPosDef(xx + 255, xx + 312, 6, 1, xx + 321, xx + 327);\n  xx[297] = xx[318] * xx[210] + xx[319] * xx[24] + xx[320] * xx[200] + xx[325] *\n    xx[296] + xx[326] * xx[228];\n  xx[298] = xx[236] + xx[36];\n  xx[36] = xx[35] * xx[194];\n  xx[236] = xx[133] * xx[194];\n  xx[312] = - xx[298];\n  xx[313] = xx[36];\n  xx[314] = xx[236];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 312, xx + 315);\n  xx[312] = xx[1] * (xx[315] - xx[298] * xx[193]);\n  xx[313] = xx[133] + xx[1] * (xx[36] * xx[193] + xx[316]);\n  xx[314] = xx[1] * (xx[236] * xx[193] + xx[317]) - xx[35];\n  xx[36] = xx[1] * (xx[204] + xx[205]);\n  xx[204] = xx[1] * (xx[124] + xx[214]) - xx[0];\n  xx[315] = xx[36];\n  xx[316] = xx[232];\n  xx[317] = xx[204];\n  xx[124] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 312, xx + 315);\n  xx[205] = xx[234] + xx[28];\n  xx[28] = xx[231] * xx[194];\n  xx[214] = xx[44] * xx[194];\n  xx[312] = - xx[205];\n  xx[313] = xx[28];\n  xx[314] = xx[214];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 312, xx + 327);\n  xx[312] = xx[1] * (xx[327] - xx[205] * xx[193]);\n  xx[313] = xx[44] + xx[1] * (xx[28] * xx[193] + xx[328]);\n  xx[314] = xx[1] * (xx[214] * xx[193] + xx[329]) - xx[231];\n  xx[28] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 312, xx + 315);\n  xx[44] = xx[199] + xx[40];\n  xx[40] = xx[47] * xx[194];\n  xx[199] = xx[211] * xx[194];\n  xx[312] = - xx[44];\n  xx[313] = xx[40];\n  xx[314] = xx[199];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 312, xx + 327);\n  xx[312] = xx[1] * (xx[327] - xx[44] * xx[193]);\n  xx[313] = xx[211] + xx[1] * (xx[40] * xx[193] + xx[328]);\n  xx[314] = xx[1] * (xx[199] * xx[193] + xx[329]) - xx[47];\n  xx[40] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 312, xx + 315);\n  xx[327] = xx[39];\n  xx[328] = xx[39];\n  xx[329] = xx[39];\n  xx[330] = xx[124];\n  xx[331] = xx[28];\n  xx[332] = xx[40];\n  solveSymmetricPosDef(xx + 153, xx + 327, 6, 1, xx + 333, xx + 339);\n  xx[312] = xx[1] * (xx[202] - xx[201]);\n  xx[313] = xx[227] - xx[0];\n  xx[314] = - xx[239];\n  xx[44] = xx[194] * xx[194];\n  xx[199] = xx[1] * (xx[244] + xx[44]) - xx[0];\n  xx[201] = xx[1] * (xx[237] + xx[241]);\n  xx[202] = xx[1] * (xx[43] - xx[134]);\n  xx[327] = xx[199];\n  xx[328] = xx[201];\n  xx[329] = xx[202];\n  xx[205] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 312, xx + 327);\n  xx[312] = xx[216];\n  xx[313] = xx[225];\n  xx[314] = xx[206];\n  xx[211] = bb[0] ? xx[39] : pm_math_Vector3_dot_ra(xx + 312, xx + 327);\n  xx[330] = xx[39];\n  xx[331] = xx[39];\n  xx[332] = xx[39];\n  xx[333] = xx[205];\n  xx[334] = xx[211];\n  xx[335] = xx[39];\n  solveSymmetricPosDef(xx + 255, xx + 330, 6, 1, xx + 339, xx + 345);\n  xx[214] = xx[336] * xx[210] + xx[337] * xx[24] + xx[338] * xx[200] + xx[343] *\n    xx[296] + xx[344] * xx[228];\n  xx[225] = - xx[0];\n  xx[227] = bb[0] ? xx[39] : xx[225];\n  xx[234] = 0.04500000000000001;\n  xx[236] = xx[234] * xx[46];\n  xx[239] = xx[236] * xx[196];\n  xx[244] = xx[234] * xx[35];\n  xx[298] = xx[244] * xx[196];\n  xx[299] = xx[236] * xx[194] + xx[244] * xx[195];\n  xx[312] = - xx[239];\n  xx[313] = - xx[298];\n  xx[314] = xx[299];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 312, xx + 330);\n  xx[306] = xx[1] * (xx[330] - xx[239] * xx[193]) - xx[244];\n  xx[239] = xx[108] * state[5];\n  xx[244] = state[6] * xx[110];\n  xx[312] = xx[239] + xx[244];\n  xx[333] = xx[71];\n  xx[334] = xx[73];\n  xx[335] = xx[92];\n  xx[313] = xx[108] * state[4];\n  xx[314] = state[4] * xx[110];\n  xx[345] = - xx[312];\n  xx[346] = xx[313];\n  xx[347] = xx[314];\n  pm_math_Vector3_cross_ra(xx + 333, xx + 345, xx + 348);\n  xx[345] = bb[0] ? xx[39] : - (xx[306] + xx[1] * (state[3] * xx[312] + xx[348])\n    + xx[1] * (xx[13] - xx[12]));\n  xx[312] = xx[234] * xx[198];\n  xx[198] = xx[312] * xx[196];\n  xx[346] = xx[234] * xx[231];\n  xx[231] = xx[346] * xx[196];\n  xx[347] = xx[312] * xx[194] + xx[346] * xx[195];\n  xx[351] = - xx[198];\n  xx[352] = - xx[231];\n  xx[353] = xx[347];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 351, xx + 354);\n  xx[351] = xx[107] * state[5];\n  xx[352] = xx[107] * state[4];\n  xx[353] = xx[244] - xx[352];\n  xx[244] = state[5] * xx[110];\n  xx[357] = - xx[351];\n  xx[358] = - xx[353];\n  xx[359] = xx[244];\n  pm_math_Vector3_cross_ra(xx + 333, xx + 357, xx + 360);\n  xx[357] = bb[0] ? xx[39] : - (xx[1] * (xx[354] - xx[198] * xx[193]) - xx[346]\n    + xx[110] + xx[1] * (xx[360] + xx[351] * state[3]) - xx[11] + xx[0]);\n  xx[11] = xx[234] * xx[45];\n  xx[45] = xx[11] * xx[196];\n  xx[198] = xx[234] * xx[47];\n  xx[47] = xx[198] * xx[196];\n  xx[346] = xx[11] * xx[194] + xx[198] * xx[195];\n  xx[363] = - xx[45];\n  xx[364] = - xx[47];\n  xx[365] = xx[346];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 363, xx + 366);\n  xx[351] = xx[107] * state[6];\n  xx[358] = xx[108] * state[6];\n  xx[359] = xx[239] - xx[352];\n  xx[363] = - xx[351];\n  xx[364] = xx[358];\n  xx[365] = - xx[359];\n  pm_math_Vector3_cross_ra(xx + 333, xx + 363, xx + 369);\n  xx[239] = bb[0] ? xx[39] : - (xx[1] * (xx[366] - xx[45] * xx[193]) - xx[198] +\n    xx[1] * (xx[369] + xx[351] * state[3]) - xx[108]);\n  xx[372] = xx[227];\n  xx[373] = xx[39];\n  xx[374] = xx[39];\n  xx[375] = xx[345];\n  xx[376] = xx[357];\n  xx[377] = xx[239];\n  solveSymmetricPosDef(xx + 153, xx + 372, 6, 1, xx + 378, xx + 384);\n  xx[45] = bb[0] ? xx[39] : xx[0];\n  xx[198] = 0.0225;\n  xx[333] = xx[198] * state[19];\n  xx[334] = xx[333] * state[16];\n  xx[335] = xx[198] * state[17];\n  xx[351] = bb[0] ? xx[39] : xx[1] * (xx[334] - xx[335] * state[18]);\n  xx[352] = xx[198] * state[18];\n  xx[363] = xx[333] * state[19];\n  xx[364] = bb[0] ? xx[39] : xx[198] - xx[1] * (xx[352] * state[18] + xx[363]);\n  xx[372] = xx[45];\n  xx[373] = xx[39];\n  xx[374] = xx[39];\n  xx[375] = xx[351];\n  xx[376] = xx[364];\n  xx[377] = xx[39];\n  solveSymmetricPosDef(xx + 255, xx + 372, 6, 1, xx + 384, xx + 390);\n  xx[365] = xx[381] * xx[210] + xx[382] * xx[24] + xx[383] * xx[200] + xx[388] *\n    xx[296] + xx[389] * xx[228];\n  xx[372] = xx[1] * (xx[331] - xx[298] * xx[193]);\n  xx[298] = bb[0] ? xx[39] : - (xx[372] + xx[1] * (xx[349] - xx[313] * state[3])\n    + xx[64] - xx[110] + xx[236] - xx[0]);\n  xx[64] = bb[0] ? xx[39] : - (xx[1] * (xx[355] - xx[231] * xx[193]) + xx[312] +\n    xx[1] * (state[3] * xx[353] + xx[361]) + xx[21]);\n  xx[21] = bb[0] ? xx[39] : - (xx[1] * (xx[367] - xx[47] * xx[193]) + xx[11] +\n    xx[1] * (xx[370] - xx[358] * state[3]) - xx[107]);\n  xx[390] = xx[39];\n  xx[391] = xx[227];\n  xx[392] = xx[39];\n  xx[393] = xx[298];\n  xx[394] = xx[64];\n  xx[395] = xx[21];\n  solveSymmetricPosDef(xx + 153, xx + 390, 6, 1, xx + 396, xx + 402);\n  xx[11] = bb[0] ? xx[39] : xx[1] * (xx[363] + xx[335] * state[17]) - xx[198];\n  xx[47] = bb[0] ? xx[39] : xx[1] * (xx[334] + xx[352] * state[17]);\n  xx[390] = xx[39];\n  xx[391] = xx[45];\n  xx[392] = xx[39];\n  xx[393] = xx[11];\n  xx[394] = xx[47];\n  xx[395] = xx[39];\n  solveSymmetricPosDef(xx + 255, xx + 390, 6, 1, xx + 402, xx + 408);\n  xx[110] = xx[399] * xx[210] + xx[400] * xx[24] + xx[401] * xx[200] + xx[406] *\n    xx[296] + xx[407] * xx[228];\n  xx[231] = xx[1] * (xx[332] + xx[299] * xx[193]);\n  xx[299] = bb[0] ? xx[39] : - (xx[231] + xx[108] + xx[1] * (xx[350] - xx[314] *\n    state[3]) - xx[94]);\n  xx[94] = bb[0] ? xx[39] : - (xx[1] * (xx[356] + xx[347] * xx[193]) + xx[1] *\n    (xx[362] - xx[244] * state[3]) + xx[107] + xx[93]);\n  xx[107] = bb[0] ? xx[39] : - (xx[1] * (xx[368] + xx[346] * xx[193]) + xx[1] *\n    (state[3] * xx[359] + xx[371]));\n  xx[358] = xx[39];\n  xx[359] = xx[39];\n  xx[360] = xx[227];\n  xx[361] = xx[299];\n  xx[362] = xx[94];\n  xx[363] = xx[107];\n  solveSymmetricPosDef(xx + 153, xx + 358, 6, 1, xx + 366, xx + 390);\n  xx[108] = bb[0] ? xx[39] : - (xx[1] * (xx[335] * state[16] + xx[333] * state\n    [18]));\n  xx[244] = bb[0] ? xx[39] : xx[1] * (xx[333] * state[17] - xx[352] * state[16]);\n  xx[330] = xx[39];\n  xx[331] = xx[39];\n  xx[332] = xx[45];\n  xx[333] = xx[108];\n  xx[334] = xx[244];\n  xx[335] = xx[39];\n  solveSymmetricPosDef(xx + 255, xx + 330, 6, 1, xx + 358, xx + 390);\n  xx[312] = xx[369] * xx[210] + xx[370] * xx[24] + xx[371] * xx[200] + xx[362] *\n    xx[296] + xx[363] * xx[228];\n  xx[313] = xx[336] * xx[230] + xx[337] * xx[29] + xx[338] * xx[42] + xx[342] *\n    xx[305] + xx[344] * xx[215];\n  xx[314] = xx[381] * xx[230] + xx[382] * xx[29] + xx[383] * xx[42] + xx[387] *\n    xx[305] + xx[389] * xx[215];\n  xx[321] = xx[399] * xx[230] + xx[400] * xx[29] + xx[401] * xx[42] + xx[405] *\n    xx[305] + xx[407] * xx[215];\n  xx[322] = xx[369] * xx[230] + xx[370] * xx[29] + xx[371] * xx[42] + xx[361] *\n    xx[305] + xx[363] * xx[215];\n  xx[323] = xx[381] * xx[124] + xx[382] * xx[28] + xx[383] * xx[40] + xx[387] *\n    xx[205] + xx[388] * xx[211];\n  xx[325] = xx[399] * xx[124] + xx[400] * xx[28] + xx[401] * xx[40] + xx[405] *\n    xx[205] + xx[406] * xx[211];\n  xx[330] = xx[369] * xx[124] + xx[370] * xx[28] + xx[371] * xx[40] + xx[361] *\n    xx[205] + xx[362] * xx[211];\n  xx[331] = xx[396] * xx[227] + xx[399] * xx[345] + xx[400] * xx[357] + xx[401] *\n    xx[239] + xx[402] * xx[45] + xx[405] * xx[351] + xx[406] * xx[364];\n  xx[332] = xx[366] * xx[227] + xx[369] * xx[345] + xx[370] * xx[357] + xx[371] *\n    xx[239] + xx[358] * xx[45] + xx[361] * xx[351] + xx[362] * xx[364];\n  xx[333] = xx[367] * xx[227] + xx[369] * xx[298] + xx[370] * xx[64] + xx[371] *\n    xx[21] + xx[359] * xx[45] + xx[361] * xx[11] + xx[362] * xx[47];\n  xx[407] = xx[222] * xx[210] + xx[223] * xx[24] + xx[224] * xx[200] + xx[307] *\n    xx[296] + xx[308] * xx[228];\n  xx[408] = xx[297];\n  xx[409] = xx[214];\n  xx[410] = xx[365];\n  xx[411] = xx[110];\n  xx[412] = xx[312];\n  xx[413] = xx[297];\n  xx[414] = xx[318] * xx[230] + xx[319] * xx[29] + xx[320] * xx[42] + xx[324] *\n    xx[305] + xx[326] * xx[215];\n  xx[415] = xx[313];\n  xx[416] = xx[314];\n  xx[417] = xx[321];\n  xx[418] = xx[322];\n  xx[419] = xx[214];\n  xx[420] = xx[313];\n  xx[421] = xx[336] * xx[124] + xx[337] * xx[28] + xx[338] * xx[40] + xx[342] *\n    xx[205] + xx[343] * xx[211];\n  xx[422] = xx[323];\n  xx[423] = xx[325];\n  xx[424] = xx[330];\n  xx[425] = xx[365];\n  xx[426] = xx[314];\n  xx[427] = xx[323];\n  xx[428] = xx[378] * xx[227] + xx[381] * xx[345] + xx[382] * xx[357] + xx[383] *\n    xx[239] + xx[384] * xx[45] + xx[387] * xx[351] + xx[388] * xx[364];\n  xx[429] = xx[331];\n  xx[430] = xx[332];\n  xx[431] = xx[110];\n  xx[432] = xx[321];\n  xx[433] = xx[325];\n  xx[434] = xx[331];\n  xx[435] = xx[397] * xx[227] + xx[399] * xx[298] + xx[400] * xx[64] + xx[401] *\n    xx[21] + xx[403] * xx[45] + xx[405] * xx[11] + xx[406] * xx[47];\n  xx[436] = xx[333];\n  xx[437] = xx[312];\n  xx[438] = xx[322];\n  xx[439] = xx[330];\n  xx[440] = xx[332];\n  xx[441] = xx[333];\n  xx[442] = xx[368] * xx[227] + xx[369] * xx[299] + xx[370] * xx[94] + xx[371] *\n    xx[107] + xx[360] * xx[45] + xx[361] * xx[108] + xx[362] * xx[244];\n  ii[0] = bb[0] ? 0 : 1;\n  xx[110] = xx[1] * (xx[16] + xx[15]);\n  xx[15] = state[3] * state[3];\n  xx[16] = xx[1] * (xx[15] + xx[63]) - xx[0];\n  xx[63] = xx[110] * state[10] - xx[16] * state[12];\n  xx[214] = xx[16] * state[11] - xx[14] * state[10];\n  xx[222] = xx[14] * state[12] - xx[110] * state[11];\n  xx[223] = xx[222] * state[11] - xx[63] * state[10];\n  xx[224] = xx[1] * (xx[12] + xx[13]);\n  xx[12] = xx[85] * state[10] - xx[224] * state[12];\n  xx[13] = xx[1] * (xx[15] + xx[2]) - xx[0];\n  xx[2] = xx[224] * state[11] - xx[13] * state[10];\n  xx[297] = xx[13] * state[12] - xx[85] * state[11];\n  xx[307] = xx[297] * state[11] - xx[12] * state[10];\n  xx[308] = xx[1] * (xx[15] + xx[3]) - xx[0];\n  xx[3] = xx[308] * state[10] - xx[93] * state[12];\n  xx[15] = xx[1] * (xx[65] + xx[66]);\n  xx[312] = xx[93] * state[11] - xx[15] * state[10];\n  xx[313] = xx[15] * state[12] - xx[308] * state[11];\n  xx[314] = xx[313] * state[11] - xx[3] * state[10];\n  xx[318] = xx[63] * state[12] - xx[214] * state[11];\n  xx[319] = xx[214] * state[10] - xx[222] * state[12];\n  xx[320] = xx[223];\n  xx[321] = xx[12] * state[12] - xx[2] * state[11];\n  xx[322] = xx[2] * state[10] - xx[297] * state[12];\n  xx[323] = xx[307];\n  xx[324] = xx[3] * state[12] - xx[312] * state[11];\n  xx[325] = xx[312] * state[10] - xx[313] * state[12];\n  xx[326] = xx[314];\n  pm_math_Matrix3x3_compose_ra(xx + 318, xx + 49, xx + 330);\n  xx[373] = xx[16];\n  xx[374] = xx[14];\n  xx[375] = xx[110];\n  xx[376] = xx[224];\n  xx[377] = xx[13];\n  xx[378] = xx[85];\n  xx[379] = xx[93];\n  xx[380] = xx[15];\n  xx[381] = xx[308];\n  xx[2] = xx[133] * inputDot[0];\n  xx[3] = xx[2] * xx[2];\n  xx[12] = xx[1] * xx[34] * inputDot[0] + inputDot[1];\n  xx[13] = xx[12] * xx[12];\n  xx[14] = xx[46] * inputDot[0];\n  xx[15] = xx[14] * xx[12];\n  xx[339] = xx[14];\n  xx[340] = xx[12];\n  xx[341] = xx[2];\n  xx[342] = xx[46];\n  xx[343] = xx[35];\n  xx[344] = xx[133];\n  pm_math_Vector3_cross_ra(xx + 339, xx + 342, xx + 346);\n  xx[16] = inputDot[0] * xx[348];\n  xx[34] = xx[2] * xx[14];\n  xx[63] = inputDot[0] * xx[347];\n  xx[85] = xx[14] * xx[14];\n  xx[93] = xx[2] * xx[12];\n  xx[110] = inputDot[0] * xx[346];\n  xx[382] = - (xx[3] + xx[13]);\n  xx[383] = xx[15] + xx[16];\n  xx[384] = xx[34] - xx[63];\n  xx[385] = xx[15] - xx[16];\n  xx[386] = - (xx[3] + xx[85]);\n  xx[387] = xx[93] + xx[110];\n  xx[388] = xx[34] + xx[63];\n  xx[389] = xx[93] - xx[110];\n  xx[390] = - (xx[13] + xx[85]);\n  pm_math_Matrix3x3_compose_ra(xx + 49, xx + 382, xx + 391);\n  pm_math_Matrix3x3_compose_ra(xx + 373, xx + 391, xx + 49);\n  xx[373] = xx[199];\n  xx[374] = xx[243];\n  xx[375] = xx[212];\n  xx[376] = xx[201];\n  xx[377] = xx[246];\n  xx[378] = xx[235];\n  xx[379] = xx[202];\n  xx[380] = xx[292];\n  xx[381] = xx[304];\n  pm_math_Quaternion_inverseXform_ra(xx + 189, xx + 4, xx + 342);\n  pm_math_Matrix3x3_postCross_ra(xx + 373, xx + 342, xx + 382);\n  pm_math_Matrix3x3_postCross_ra(xx + 382, xx + 339, xx + 373);\n  xx[339] = xx[331] + xx[50] + xx[1] * xx[374];\n  xx[340] = xx[334] + xx[53] + xx[1] * xx[377];\n  xx[341] = xx[337] + xx[56] + xx[1] * xx[380];\n  xx[3] = xx[36] * state[23] - xx[197] * state[25];\n  xx[13] = xx[197] * state[24] - xx[217] * state[23];\n  xx[15] = xx[232] * state[23] - xx[203] * state[25];\n  xx[16] = xx[203] * state[24] - xx[37] * state[23];\n  xx[34] = xx[204] * state[23] - xx[206] * state[25];\n  xx[63] = xx[206] * state[24] - xx[213] * state[23];\n  xx[346] = xx[3] * state[25] - xx[13] * state[24];\n  xx[347] = xx[15] * state[25] - xx[16] * state[24];\n  xx[348] = xx[34] * state[25] - xx[63] * state[24];\n  xx[85] = - state[17];\n  xx[93] = - state[18];\n  xx[110] = - state[19];\n  xx[352] = xx[85];\n  xx[353] = xx[93];\n  xx[354] = xx[110];\n  xx[133] = state[18] * state[24];\n  xx[197] = state[19] * state[25];\n  xx[199] = xx[133] + xx[197];\n  xx[201] = state[17] * state[24];\n  xx[203] = state[17] * state[25];\n  xx[358] = xx[199];\n  xx[359] = - xx[201];\n  xx[360] = - xx[203];\n  pm_math_Vector3_cross_ra(xx + 352, xx + 358, xx + 361);\n  xx[358] = xx[1] * (xx[361] - state[16] * xx[199]);\n  xx[359] = state[25] + xx[1] * (xx[201] * state[16] + xx[362]);\n  xx[360] = xx[1] * (xx[203] * state[16] + xx[363]) - state[24];\n  xx[199] = xx[342] + xx[14];\n  xx[201] = xx[199] * xx[195];\n  xx[203] = xx[344] + xx[2];\n  xx[2] = xx[203] * xx[196];\n  xx[206] = xx[199] * xx[194];\n  xx[212] = xx[2] + xx[206];\n  xx[214] = xx[203] * xx[195];\n  xx[361] = xx[201];\n  xx[362] = - xx[212];\n  xx[363] = xx[214];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 361, xx + 365);\n  xx[361] = xx[1] * (xx[201] * xx[193] + xx[365]) - xx[203];\n  xx[362] = xx[1] * (xx[366] - xx[212] * xx[193]);\n  xx[363] = xx[199] + xx[1] * (xx[214] * xx[193] + xx[367]);\n  xx[201] = xx[332] + xx[51] + xx[1] * xx[375];\n  xx[212] = xx[335] + xx[54] + xx[1] * xx[378];\n  xx[214] = xx[338] + xx[57] + xx[1] * xx[381];\n  xx[365] = xx[201];\n  xx[366] = xx[212];\n  xx[367] = xx[214];\n  xx[222] = xx[217] * state[25] - xx[36] * state[24];\n  xx[36] = xx[37] * state[25] - xx[232] * state[24];\n  xx[37] = xx[213] * state[25] - xx[204] * state[24];\n  xx[368] = xx[13] * state[23] - xx[222] * state[25];\n  xx[369] = xx[16] * state[23] - xx[36] * state[25];\n  xx[370] = xx[63] * state[23] - xx[37] * state[25];\n  xx[13] = state[18] * state[23];\n  xx[16] = state[17] * state[23];\n  xx[63] = xx[197] + xx[16];\n  xx[197] = state[18] * state[25];\n  xx[382] = - xx[13];\n  xx[383] = xx[63];\n  xx[384] = - xx[197];\n  pm_math_Vector3_cross_ra(xx + 352, xx + 382, xx + 385);\n  xx[382] = xx[1] * (xx[13] * state[16] + xx[385]) - state[25];\n  xx[383] = xx[1] * (xx[386] - state[16] * xx[63]);\n  xx[384] = state[23] + xx[1] * (xx[197] * state[16] + xx[387]);\n  xx[13] = xx[343] + xx[12];\n  xx[63] = xx[199] * xx[196];\n  xx[197] = xx[13] * xx[196];\n  xx[204] = xx[13] * xx[195];\n  xx[213] = xx[206] + xx[204];\n  xx[385] = xx[63];\n  xx[386] = xx[197];\n  xx[387] = - xx[213];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 385, xx + 388);\n  xx[385] = xx[13] + xx[1] * (xx[63] * xx[193] + xx[388]);\n  xx[386] = xx[1] * (xx[197] * xx[193] + xx[389]) - xx[199];\n  xx[387] = xx[1] * (xx[390] - xx[213] * xx[193]);\n  xx[388] = xx[330] + xx[49] + xx[1] * xx[373];\n  xx[389] = xx[333] + xx[52] + xx[1] * xx[376];\n  xx[390] = xx[336] + xx[55] + xx[1] * xx[379];\n  xx[49] = xx[222] * state[24] - xx[3] * state[23];\n  xx[3] = xx[36] * state[24] - xx[15] * state[23];\n  xx[15] = xx[37] * state[24] - xx[34] * state[23];\n  xx[50] = xx[49];\n  xx[51] = xx[3];\n  xx[52] = xx[15];\n  xx[34] = state[19] * state[23];\n  xx[36] = state[19] * state[24];\n  xx[37] = xx[16] + xx[133];\n  xx[53] = - xx[34];\n  xx[54] = - xx[36];\n  xx[55] = xx[37];\n  pm_math_Vector3_cross_ra(xx + 352, xx + 53, xx + 330);\n  xx[53] = state[24] + xx[1] * (xx[34] * state[16] + xx[330]);\n  xx[54] = xx[1] * (xx[36] * state[16] + xx[331]) - state[23];\n  xx[55] = xx[1] * (xx[332] - state[16] * xx[37]);\n  xx[16] = xx[204] + xx[2];\n  xx[2] = xx[13] * xx[194];\n  xx[34] = xx[203] * xx[194];\n  xx[330] = - xx[16];\n  xx[331] = xx[2];\n  xx[332] = xx[34];\n  pm_math_Vector3_cross_ra(xx + 194, xx + 330, xx + 333);\n  xx[330] = xx[1] * (xx[333] - xx[16] * xx[193]);\n  xx[331] = xx[203] + xx[1] * (xx[2] * xx[193] + xx[334]);\n  xx[332] = xx[1] * (xx[34] * xx[193] + xx[335]) - xx[13];\n  pm_math_Matrix3x3_xform_ra(xx + 318, xx + 111, xx + 333);\n  xx[318] = - (xx[103] * xx[393]);\n  xx[319] = - (xx[103] * xx[396]);\n  xx[320] = - (xx[103] * xx[399]);\n  pm_math_Quaternion_xform_ra(xx + 129, xx + 318, xx + 321);\n  xx[318] = xx[102];\n  xx[319] = xx[106];\n  xx[320] = xx[123];\n  xx[2] = xx[103] * xx[14];\n  xx[13] = xx[2] * xx[33];\n  xx[14] = xx[103] * xx[12];\n  xx[12] = xx[14] * xx[33];\n  xx[16] = xx[2] * xx[23] + xx[14] * xx[32];\n  xx[324] = xx[13];\n  xx[325] = xx[12];\n  xx[326] = - xx[16];\n  pm_math_Vector3_cross_ra(xx + 318, xx + 324, xx + 336);\n  xx[324] = xx[1] * (xx[336] - xx[13] * xx[26]) - xx[14];\n  xx[325] = xx[1] * (xx[337] - xx[12] * xx[26]) + xx[2];\n  xx[326] = xx[1] * (xx[338] + xx[26] * xx[16]);\n  pm_math_Vector3_cross_ra(xx + 4, xx + 324, xx + 12);\n  pm_math_Quaternion_xform_ra(xx + 129, xx + 12, xx + 324);\n  xx[373] = pm_math_Vector3_dot_ra(xx + 339, xx + 207) + pm_math_Vector3_dot_ra\n    (xx + 346, xx + 293) + pm_math_Vector3_dot_ra(xx + 358, xx + 361) * xx[1];\n  xx[374] = pm_math_Vector3_dot_ra(xx + 365, xx + 301) + pm_math_Vector3_dot_ra\n    (xx + 368, xx + 309) + pm_math_Vector3_dot_ra(xx + 382, xx + 385) * xx[1];\n  xx[375] = pm_math_Vector3_dot_ra(xx + 388, xx + 315) + pm_math_Vector3_dot_ra\n    (xx + 50, xx + 327) + pm_math_Vector3_dot_ra(xx + 53, xx + 330) * xx[1];\n  xx[376] = xx[198] * xx[49] - (xx[333] + xx[223] + xx[321] + xx[1] * xx[324] -\n    xx[234] * xx[201]);\n  xx[377] = xx[198] * xx[3] - (xx[334] + xx[307] + xx[322] + xx[1] * xx[325] -\n    xx[234] * xx[212]);\n  xx[378] = xx[198] * xx[15] - (xx[335] + xx[314] + xx[323] + xx[1] * xx[326] -\n    xx[234] * xx[214]);\n  zeroMajor(1, 6, ii + 0, xx + 373);\n  pm_math_Vector3_cross_ra(xx + 4, xx + 111, xx + 12);\n  pm_math_Vector3_cross_ra(xx + 4, xx + 12, xx + 49);\n  pm_math_Quaternion_inverseXform_ra(xx + 189, xx + 49, xx + 52);\n  xx[2] = xx[1] * xx[31] * xx[31];\n  xx[3] = (xx[0] - xx[2]) * inputDot[0];\n  xx[15] = xx[103] * xx[3];\n  xx[16] = xx[1] * xx[22] * xx[31];\n  xx[22] = xx[16] * inputDot[0];\n  xx[31] = xx[344] + xx[22];\n  xx[34] = xx[344] + xx[31];\n  xx[307] = xx[0];\n  xx[308] = xx[39];\n  xx[309] = xx[39];\n  xx[310] = xx[39];\n  xx[311] = xx[39];\n  xx[312] = xx[39];\n  xx[313] = xx[225];\n  pm_math_Quaternion_xform_ra(xx + 129, xx + 111, xx + 49);\n  xx[36] = state[0] + xx[17];\n  xx[37] = 6.938893903907228e-18;\n  xx[55] = xx[37] * xx[195];\n  xx[56] = xx[37] * xx[194];\n  xx[57] = xx[1] * (xx[66] - xx[65]);\n  xx[63] = state[1] - xx[57];\n  xx[65] = state[2] - xx[95] + xx[0];\n  xx[321] = - xx[195];\n  xx[322] = - xx[196];\n  xx[323] = xx[193];\n  xx[324] = xx[194];\n  xx[325] = xx[49] + xx[36] - xx[1] * (xx[55] * xx[193] + xx[56] * xx[196]);\n  xx[326] = xx[1] * (xx[56] * xx[193] - xx[55] * xx[196]) + xx[50] + xx[63];\n  xx[327] = xx[1] * (xx[56] * xx[194] + xx[55] * xx[195]) - xx[37] + xx[51] +\n    xx[65];\n  bb[1] = sm_core_compiler_computeProximityInfoBrickCylinder(\n    simulation_b048d748_1_geometry_3(NULL), simulation_b048d748_1_geometry_2\n    (NULL), (pm_math_Transform3 *)(xx + 307), (pm_math_Transform3 *)(xx + 321),\n    xx + 49, (pm_math_Vector3 *)(xx + 197), (pm_math_Vector3 *)(xx + 206),\n    (pm_math_Vector3 *)(xx + 212), (pm_math_Vector3 *)(xx + 222));\n  xx[328] = xx[39];\n  xx[329] = xx[39];\n  xx[330] = xx[0];\n  xx[331] = xx[39];\n  xx[332] = xx[39];\n  xx[333] = xx[39];\n  xx[334] = - xx[37];\n  xx[37] = xx[342] + xx[3];\n  xx[50] = xx[343] + inputDot[1];\n  xx[292] = state[7];\n  xx[293] = state[8];\n  xx[294] = state[9];\n  pm_math_Quaternion_inverseXform_ra(xx + 129, xx + 292, xx + 335);\n  xx[51] = xx[335] + state[11];\n  xx[55] = xx[336] - state[10];\n  xx[292] = xx[12] + xx[51];\n  xx[293] = xx[13] + xx[55];\n  xx[294] = xx[14] + xx[337];\n  pm_math_Quaternion_inverseXform_ra(xx + 189, xx + 292, xx + 12);\n  xx[56] = xx[103] * inputDot[1];\n  xx[358] = xx[37];\n  xx[359] = xx[50];\n  xx[360] = xx[31];\n  xx[361] = xx[12] - xx[56];\n  xx[362] = xx[13] + xx[15];\n  xx[363] = xx[14];\n  xx[12] = 1000.0;\n  xx[13] = 1.0e-4;\n  xx[14] = 0.3;\n  xx[66] = 0.2119573811760597;\n  xx[102] = 9.126024771145405e-4;\n  sm_core_compiler_computeSpatialContactWrenches(\n    0, 1, bb[1], xx + 49, (const pm_math_Vector3 *)(xx + 197), (const\n    pm_math_Vector3 *)(xx + 206), (const pm_math_Vector3 *)(xx + 212), (const\n    pm_math_Vector3 *)(xx + 222),\n    (const pm_math_Transform3 *)(xx + 307), (const pm_math_Transform3 *)(xx +\n    328), (const pm_math_Transform3 *)(xx + 307), (const pm_math_Transform3 *)\n    (xx + 321), NULL, (const pm_math_SpatialVector *)(xx + 358),\n    0, 1, 1.0e6, xx[12], xx[13], xx[14], xx[66], xx[102], NULL, NULL,\n    NULL, (pm_math_SpatialVector *)(xx + 365));\n  xx[49] = inputDot[0] * inputDot[1];\n  xx[106] = xx[16] * xx[49];\n  xx[16] = - xx[25];\n  xx[25] = sin(xx[16]);\n  xx[123] = xx[0] - xx[1] * xx[25] * xx[25];\n  xx[197] = xx[27] * (xx[52] - xx[15] * xx[34] - xx[103] * inputDdot[1]) - xx\n    [368];\n  xx[198] = xx[27] * (xx[53] - xx[56] * xx[34] - xx[103] * xx[106] + xx[103] *\n                      xx[123] * inputDdot[0]) - xx[369];\n  xx[199] = xx[27] * (xx[54] + xx[15] * (xx[342] + xx[37]) + xx[56] * (xx[343] +\n    xx[50])) - (xx[370] + input[4]);\n  pm_math_Quaternion_xform_ra(xx + 189, xx + 197, xx + 52);\n  xx[321] = xx[68];\n  xx[322] = xx[71];\n  xx[323] = xx[73];\n  xx[324] = xx[92];\n  xx[325] = xx[36] - xx[17];\n  xx[326] = xx[57] + xx[63];\n  xx[327] = xx[95] - xx[0] + xx[65];\n  bb[1] = sm_core_compiler_computeProximityInfoCxpolyBrick(\n    simulation_b048d748_1_geometry_0(NULL), simulation_b048d748_1_geometry_3\n    (NULL), (pm_math_Transform3 *)(xx + 321), (pm_math_Transform3 *)(xx + 307),\n    xx + 15, (pm_math_Vector3 *)(xx + 197), (pm_math_Vector3 *)(xx + 206),\n    (pm_math_Vector3 *)(xx + 212), (pm_math_Vector3 *)(xx + 222));\n  xx[328] = state[10];\n  xx[329] = state[11];\n  xx[330] = state[12];\n  xx[331] = xx[51];\n  xx[332] = xx[55];\n  xx[333] = xx[337];\n  sm_core_compiler_computeSpatialContactWrenches(\n    0, 1, bb[1], xx + 15, (const pm_math_Vector3 *)(xx + 206), (const\n    pm_math_Vector3 *)(xx + 197), (const pm_math_Vector3 *)(xx + 222), (const\n    pm_math_Vector3 *)(xx + 212),\n    (const pm_math_Transform3 *)(xx + 307), (const pm_math_Transform3 *)(xx +\n    307), (const pm_math_Transform3 *)(xx + 307), (const pm_math_Transform3 *)\n    (xx + 321), NULL, (const pm_math_SpatialVector *)(xx + 328),\n    0, 1, 1300.0, xx[12], xx[13], 0.4, 0.3166621126427172, 9.173266606314467e-4,\n    NULL, NULL,\n    NULL, (pm_math_SpatialVector *)(xx + 358));\n  xx[197] = xx[51];\n  xx[198] = xx[55];\n  xx[199] = xx[337];\n  pm_math_Vector3_cross_ra(xx + 4, xx + 197, xx + 55);\n  xx[197] = - xx[335];\n  xx[198] = - xx[336];\n  xx[199] = - xx[337];\n  pm_math_Vector3_cross_ra(xx + 4, xx + 197, xx + 206);\n  xx[197] = xx[55] + xx[206];\n  xx[198] = xx[56] + xx[207];\n  xx[199] = xx[57] + xx[208];\n  pm_math_Matrix3x3_xform_ra(xx + 76, xx + 197, xx + 55);\n  xx[15] = xx[52] - xx[361] + xx[55];\n  xx[17] = xx[53] - xx[362] + xx[56];\n  xx[76] = xx[15];\n  xx[77] = xx[17];\n  xx[78] = xx[54] - xx[363] + xx[57];\n  xx[34] = pm_math_Vector3_dot_ra(xx + 18, xx + 76);\n  xx[36] = pm_math_Vector3_dot_ra(xx + 86, xx + 76);\n  xx[51] = pm_math_Vector3_dot_ra(xx + 96, xx + 76);\n  pm_math_Vector3_cross_ra(xx + 4, xx + 4, xx + 55);\n  xx[4] = xx[37];\n  xx[5] = xx[50];\n  xx[6] = xx[31];\n  xx[76] = xx[74] * xx[37];\n  xx[77] = xx[74] * xx[50];\n  xx[78] = xx[75] * xx[31];\n  pm_math_Vector3_cross_ra(xx + 4, xx + 76, xx + 79);\n  xx[4] = xx[3];\n  xx[5] = inputDot[1];\n  xx[6] = xx[22];\n  pm_math_Vector3_cross_ra(xx + 342, xx + 4, xx + 76);\n  xx[3] = xx[79] - xx[365] + xx[74] * (xx[76] - xx[106] + xx[123] * inputDdot[0]);\n  xx[4] = xx[80] - xx[366] + xx[74] * (xx[77] + inputDdot[1]);\n  xx[5] = xx[81] - xx[367] + xx[75] * (xx[78] - xx[49] * (xx[2] - xx[0]) - xx[1]\n    * cos(xx[16]) * xx[25] * inputDdot[0]);\n  pm_math_Quaternion_xform_ra(xx + 189, xx + 3, xx + 76);\n  pm_math_Vector3_cross_ra(xx + 111, xx + 52, xx + 2);\n  xx[321] = - xx[114];\n  xx[322] = - xx[117];\n  xx[323] = - xx[120];\n  xx[324] = - xx[115];\n  xx[325] = - xx[118];\n  xx[326] = - xx[121];\n  xx[327] = xx[126];\n  xx[328] = xx[127];\n  xx[329] = xx[128];\n  pm_math_Matrix3x3_xform_ra(xx + 321, xx + 197, xx + 52);\n  xx[5] = xx[55] - xx[358] + xx[76] + xx[2] + xx[52];\n  xx[6] = xx[56] - xx[359] + xx[77] + xx[3] + xx[53] + xx[15];\n  xx[2] = xx[57] - xx[360] + xx[78] + xx[4] + xx[54];\n  xx[52] = - xx[34];\n  xx[53] = - xx[36];\n  xx[54] = - xx[51];\n  xx[55] = xx[17] - xx[5];\n  xx[56] = - xx[6];\n  xx[57] = - xx[2];\n  solveSymmetricPosDef(xx + 153, xx + 52, 6, 1, xx + 76, xx + 330);\n  pm_math_Matrix3x3_xform_ra(xx + 321, xx + 18, xx + 52);\n  pm_math_Matrix3x3_xform_ra(xx + 321, xx + 86, xx + 18);\n  pm_math_Matrix3x3_xform_ra(xx + 321, xx + 96, xx + 55);\n  xx[443] = xx[52];\n  xx[444] = xx[18];\n  xx[445] = xx[55];\n  xx[446] = xx[30];\n  xx[447] = xx[38];\n  xx[448] = xx[41];\n  xx[449] = xx[53];\n  xx[450] = xx[19];\n  xx[451] = xx[56];\n  xx[452] = xx[147] - xx[138] + xx[118];\n  xx[453] = xx[48];\n  xx[454] = xx[122];\n  xx[455] = xx[54];\n  xx[456] = xx[20];\n  xx[457] = xx[57];\n  xx[458] = xx[150] - xx[141] + xx[119];\n  xx[459] = xx[151] - xx[142] - xx[116];\n  xx[460] = xx[125];\n  xx[461] = xx[60];\n  xx[462] = xx[89];\n  xx[463] = xx[99];\n  xx[464] = xx[67];\n  xx[465] = xx[72];\n  xx[466] = xx[126];\n  xx[467] = xx[61];\n  xx[468] = xx[90];\n  xx[469] = xx[100];\n  xx[470] = xx[59];\n  xx[471] = xx[58];\n  xx[472] = xx[127];\n  xx[473] = xx[62];\n  xx[474] = xx[91];\n  xx[475] = xx[101];\n  xx[476] = xx[69];\n  xx[477] = xx[70];\n  xx[478] = xx[128];\n  solveSymmetricPosDef(xx + 153, xx + 443, 6, 6, xx + 479, xx + 52);\n  xx[18] = xx[500];\n  xx[19] = xx[506];\n  xx[20] = xx[512];\n  xx[3] = 9.806649999999999;\n  xx[4] = xx[3] * state[4];\n  xx[15] = xx[3] * state[5];\n  xx[48] = xx[1] * (xx[4] * state[6] - xx[15] * state[3]);\n  xx[49] = xx[1] * (xx[4] * state[3] + xx[15] * state[6]);\n  xx[50] = xx[3] - xx[1] * (xx[4] * state[4] + xx[15] * state[5]);\n  xx[4] = pm_math_Vector3_dot_ra(xx + 18, xx + 48);\n  xx[15] = xx[79] - xx[4];\n  xx[18] = xx[501];\n  xx[19] = xx[507];\n  xx[20] = xx[513];\n  xx[16] = pm_math_Vector3_dot_ra(xx + 18, xx + 48);\n  xx[18] = xx[80] - xx[16];\n  xx[52] = xx[502];\n  xx[53] = xx[508];\n  xx[54] = xx[514];\n  xx[19] = pm_math_Vector3_dot_ra(xx + 52, xx + 48);\n  xx[20] = xx[81] - xx[19];\n  xx[52] = state[23];\n  xx[53] = state[24];\n  xx[54] = state[25];\n  xx[22] = - state[16];\n  xx[55] = xx[22];\n  xx[56] = xx[85];\n  xx[57] = xx[93];\n  xx[58] = xx[110];\n  xx[59] = state[20];\n  xx[60] = state[21];\n  xx[61] = state[22];\n  pm_math_Quaternion_inverseXform_ra(xx + 55, xx + 59, xx + 67);\n  pm_math_Vector3_cross_ra(xx + 52, xx + 67, xx + 55);\n  xx[58] = - xx[67];\n  xx[59] = - xx[68];\n  xx[60] = - xx[69];\n  pm_math_Vector3_cross_ra(xx + 52, xx + 58, xx + 61);\n  xx[25] = 3.469446951953614e-18;\n  xx[30] = xx[25] * state[18];\n  xx[31] = xx[25] * state[17];\n  xx[86] = state[18];\n  xx[87] = state[19];\n  xx[88] = xx[22];\n  xx[89] = xx[85];\n  xx[90] = state[13] - xx[1] * (xx[30] * state[16] + xx[31] * state[19]);\n  xx[91] = xx[1] * (xx[31] * state[16] - xx[30] * state[19]) + state[14];\n  xx[92] = xx[1] * (xx[31] * state[17] + xx[30] * state[18]) - xx[25] + state[15];\n  bb[1] = sm_core_compiler_computeProximityInfoBrickCylinder(\n    simulation_b048d748_1_geometry_3(NULL), simulation_b048d748_1_geometry_1\n    (NULL), (pm_math_Transform3 *)(xx + 307), (pm_math_Transform3 *)(xx + 86),\n    xx + 22, (pm_math_Vector3 *)(xx + 58), (pm_math_Vector3 *)(xx + 70),\n    (pm_math_Vector3 *)(xx + 82), (pm_math_Vector3 *)(xx + 95));\n  xx[110] = xx[39];\n  xx[111] = xx[39];\n  xx[112] = xx[0];\n  xx[113] = xx[39];\n  xx[114] = xx[39];\n  xx[115] = xx[39];\n  xx[116] = - xx[25];\n  xx[117] = state[23];\n  xx[118] = state[24];\n  xx[119] = state[25];\n  xx[120] = xx[67];\n  xx[121] = xx[68];\n  xx[122] = xx[69];\n  sm_core_compiler_computeSpatialContactWrenches(\n    0, 1, bb[1], xx + 22, (const pm_math_Vector3 *)(xx + 58), (const\n    pm_math_Vector3 *)(xx + 70), (const pm_math_Vector3 *)(xx + 82), (const\n    pm_math_Vector3 *)(xx + 95),\n    (const pm_math_Transform3 *)(xx + 307), (const pm_math_Transform3 *)(xx +\n    110), (const pm_math_Transform3 *)(xx + 307), (const pm_math_Transform3 *)\n    (xx + 86), NULL, (const pm_math_SpatialVector *)(xx + 117),\n    0, 1, xx[12], 100.0, xx[13], xx[14], xx[66], xx[102], NULL, NULL,\n    NULL, (pm_math_SpatialVector *)(xx + 135));\n  xx[12] = xx[27] * (xx[55] + xx[61]) - xx[138];\n  xx[13] = xx[27] * (xx[56] + xx[62]) - xx[139];\n  xx[14] = xx[27] * (xx[57] + xx[63]) - (input[3] + xx[140]);\n  xx[22] = pm_math_Vector3_dot_ra(xx + 216, xx + 12);\n  xx[25] = pm_math_Vector3_dot_ra(xx + 247, xx + 12);\n  xx[27] = pm_math_Vector3_dot_ra(xx + 251, xx + 12);\n  xx[12] = xx[254] * state[23];\n  xx[13] = xx[254] * state[24];\n  xx[14] = xx[75] * state[25];\n  pm_math_Vector3_cross_ra(xx + 52, xx + 12, xx + 55);\n  xx[58] = - xx[22];\n  xx[59] = - xx[25];\n  xx[60] = - xx[27];\n  xx[61] = xx[135] - xx[55];\n  xx[62] = xx[136] - xx[56];\n  xx[63] = xx[137] - xx[57];\n  solveSymmetricPosDef(xx + 255, xx + 58, 6, 1, xx + 65, xx + 82);\n  xx[443] = xx[39];\n  xx[444] = xx[39];\n  xx[445] = xx[39];\n  xx[446] = xx[254];\n  xx[447] = xx[39];\n  xx[448] = xx[39];\n  xx[449] = xx[39];\n  xx[450] = xx[39];\n  xx[451] = xx[39];\n  xx[452] = xx[39];\n  xx[453] = xx[254];\n  xx[454] = xx[39];\n  xx[455] = xx[39];\n  xx[456] = xx[39];\n  xx[457] = xx[39];\n  xx[458] = xx[39];\n  xx[459] = xx[39];\n  xx[460] = xx[75];\n  xx[461] = xx[219];\n  xx[462] = xx[226];\n  xx[463] = xx[238];\n  xx[464] = xx[39];\n  xx[465] = xx[39];\n  xx[466] = xx[39];\n  xx[467] = xx[220];\n  xx[468] = xx[229];\n  xx[469] = xx[240];\n  xx[470] = xx[39];\n  xx[471] = xx[39];\n  xx[472] = xx[39];\n  xx[473] = xx[221];\n  xx[474] = xx[233];\n  xx[475] = xx[242];\n  xx[476] = xx[39];\n  xx[477] = xx[39];\n  xx[478] = xx[39];\n  solveSymmetricPosDef(xx + 255, xx + 443, 6, 6, xx + 515, xx + 58);\n  xx[12] = xx[537];\n  xx[13] = xx[543];\n  xx[14] = xx[549];\n  xx[30] = xx[3] * state[17];\n  xx[31] = xx[3] * state[18];\n  xx[58] = xx[1] * (xx[30] * state[19] - xx[31] * state[16]);\n  xx[59] = xx[1] * (xx[30] * state[16] + xx[31] * state[19]);\n  xx[60] = xx[3] - xx[1] * (xx[30] * state[17] + xx[31] * state[18]);\n  xx[3] = pm_math_Vector3_dot_ra(xx + 12, xx + 58);\n  xx[12] = xx[69] - xx[3];\n  xx[61] = xx[538];\n  xx[62] = xx[544];\n  xx[63] = xx[550];\n  xx[13] = pm_math_Vector3_dot_ra(xx + 61, xx + 58);\n  xx[14] = xx[70] - xx[13];\n  xx[61] = xx[0] - xx[1] * (xx[245] + xx[300]);\n  xx[62] = xx[1] * (xx[241] + xx[237]);\n  xx[63] = xx[202];\n  xx[71] = xx[536];\n  xx[72] = xx[542];\n  xx[73] = xx[548];\n  xx[30] = pm_math_Vector3_dot_ra(xx + 71, xx + 58);\n  xx[31] = xx[68] - xx[30];\n  xx[71] = - (xx[1] * (xx[134] + xx[43]));\n  xx[72] = xx[1] * (xx[291] - xx[250]);\n  xx[73] = xx[1] * (xx[44] + xx[245]) - xx[0];\n  xx[82] = xx[497];\n  xx[83] = xx[503];\n  xx[84] = xx[509];\n  xx[0] = pm_math_Vector3_dot_ra(xx + 82, xx + 48);\n  xx[37] = xx[103] * xx[46];\n  xx[38] = xx[37] * xx[33];\n  xx[41] = xx[103] * xx[35];\n  xx[35] = xx[41] * xx[33];\n  xx[43] = xx[37] * xx[23] + xx[41] * xx[32];\n  xx[82] = xx[38];\n  xx[83] = xx[35];\n  xx[84] = - xx[43];\n  pm_math_Vector3_cross_ra(xx + 318, xx + 82, xx + 85);\n  xx[82] = xx[1] * (xx[85] - xx[38] * xx[26]) - xx[41];\n  xx[83] = xx[1] * (xx[86] - xx[35] * xx[26]) + xx[37];\n  xx[84] = xx[1] * (xx[87] + xx[26] * xx[43]);\n  pm_math_Quaternion_xform_ra(xx + 129, xx + 82, xx + 85);\n  xx[32] = xx[103] * xx[33];\n  xx[82] = xx[1] * (xx[109] + xx[32] * xx[33]) - xx[103];\n  xx[83] = - (xx[1] * (xx[32] * xx[26] + xx[104] * xx[23]));\n  xx[84] = xx[1] * (xx[105] - xx[32] * xx[23]);\n  pm_math_Quaternion_xform_ra(xx + 129, xx + 82, xx + 88);\n  xx[23] = xx[234] * xx[195];\n  xx[26] = xx[234] * xx[196];\n  xx[82] = xx[533];\n  xx[83] = xx[539];\n  xx[84] = xx[545];\n  xx[32] = pm_math_Vector3_dot_ra(xx + 82, xx + 58);\n  xx[82] = xx[498];\n  xx[83] = xx[504];\n  xx[84] = xx[510];\n  xx[33] = pm_math_Vector3_dot_ra(xx + 82, xx + 48);\n  xx[82] = xx[534];\n  xx[83] = xx[540];\n  xx[84] = xx[546];\n  xx[35] = pm_math_Vector3_dot_ra(xx + 82, xx + 58);\n  xx[79] = xx[499];\n  xx[80] = xx[505];\n  xx[81] = xx[511];\n  xx[37] = pm_math_Vector3_dot_ra(xx + 79, xx + 48);\n  xx[48] = xx[535];\n  xx[49] = xx[541];\n  xx[50] = xx[547];\n  xx[38] = pm_math_Vector3_dot_ra(xx + 48, xx + 58);\n  xx[79] = - (xx[373] + xx[15] * xx[210] + xx[18] * xx[24] + xx[20] * xx[200] +\n              inputDdot[0] * xx[210] + xx[12] * xx[296] + xx[14] * xx[228]);\n  xx[80] = - (xx[374] + xx[15] * xx[230] + xx[18] * xx[29] + xx[20] * xx[42] +\n              inputDdot[0] * xx[230] + inputDdot[1] * (bb[0] ? xx[39] :\n    pm_math_Vector3_dot_ra(xx + 61, xx + 301)) + xx[31] * xx[305] + xx[14] * xx\n              [215]);\n  xx[81] = - (xx[375] + xx[15] * xx[124] + xx[18] * xx[28] + xx[20] * xx[40] +\n              inputDdot[0] * xx[124] + inputDdot[1] * (bb[0] ? xx[39] :\n    pm_math_Vector3_dot_ra(xx + 71, xx + 315)) + xx[31] * xx[205] + xx[12] * xx\n              [211]);\n  xx[82] = - (xx[376] + (xx[76] - xx[0]) * xx[227] + xx[15] * xx[345] + xx[18] *\n              xx[357] + xx[20] * xx[239] + inputDdot[0] * (bb[0] ? xx[39] :\n    - (xx[306] + xx[85])) + inputDdot[1] * (bb[0] ? xx[39] : - (xx[88] + xx[1] *\n    (xx[23] * xx[195] + xx[26] * xx[196]) - xx[234])) + (xx[65] - xx[32]) * xx\n              [45] + xx[31] * xx[351] + xx[12] * xx[364]);\n  xx[83] = - (xx[377] + (xx[77] - xx[33]) * xx[227] + xx[15] * xx[298] + xx[18] *\n              xx[64] + xx[20] * xx[21] + inputDdot[0] * (bb[0] ? xx[39] : - (xx\n    [372] + xx[236] + xx[86])) + inputDdot[1] * (bb[0] ? xx[39] : - (xx[89] -\n    xx[1] * (xx[26] * xx[193] + xx[23] * xx[194]))) + (xx[66] - xx[35]) * xx[45]\n              + xx[31] * xx[11] + xx[12] * xx[47]);\n  xx[84] = - (xx[378] + (xx[78] - xx[37]) * xx[227] + xx[15] * xx[299] + xx[18] *\n              xx[94] + xx[20] * xx[107] + inputDdot[0] * (bb[0] ? xx[39] :\n    - (xx[231] + xx[87])) + inputDdot[1] * (bb[0] ? xx[39] : - (xx[1] * (xx[23] *\n    xx[193] - xx[26] * xx[194]) + xx[90])) + (xx[67] - xx[38]) * xx[45] + xx[31]\n              * xx[108] + xx[12] * xx[244]);\n  memcpy(xx + 306, xx + 407, 36 * sizeof(double));\n  factorAndSolveSymmetric(xx + 306, 6, xx + 65, ii + 0, xx + 79, xx + 58, xx +\n    365);\n  xx[65] = xx[61] * xx[227] - xx[34];\n  xx[66] = xx[62] * xx[227] - xx[36];\n  xx[67] = xx[63] * xx[227] - xx[51];\n  xx[68] = xx[58] * xx[210] + xx[59] * xx[230] + xx[60] * xx[124] + xx[61] * xx\n    [345] + xx[62] * xx[298] + xx[63] * xx[299] - (xx[5] - xx[17]);\n  xx[69] = xx[58] * xx[24] + xx[59] * xx[29] + xx[60] * xx[28] + xx[61] * xx[357]\n    + xx[62] * xx[64] + xx[63] * xx[94] - xx[6];\n  xx[70] = xx[58] * xx[200] + xx[59] * xx[42] + xx[60] * xx[40] + xx[61] * xx\n    [239] + xx[62] * xx[21] + xx[63] * xx[107] - xx[2];\n  solveSymmetricPosDef(xx + 153, xx + 65, 6, 1, xx + 71, xx + 77);\n  xx[40] = state[16];\n  xx[41] = state[17];\n  xx[42] = state[18];\n  xx[43] = state[19];\n  pm_math_Quaternion_compDeriv_ra(xx + 40, xx + 52, xx + 48);\n  xx[64] = xx[61] * xx[45] - xx[22];\n  xx[65] = xx[62] * xx[45] - xx[25];\n  xx[66] = xx[63] * xx[45] - xx[27];\n  xx[67] = xx[59] * xx[305] + xx[60] * xx[205] + xx[61] * xx[351] + xx[62] * xx\n    [11] + xx[63] * xx[108] - (xx[55] - xx[135]);\n  xx[68] = xx[58] * xx[296] + xx[60] * xx[211] + xx[61] * xx[364] + xx[62] * xx\n    [47] + xx[63] * xx[244] - (xx[56] - xx[136]);\n  xx[69] = xx[58] * xx[228] + xx[59] * xx[215] - (xx[57] - xx[137]);\n  solveSymmetricPosDef(xx + 255, xx + 64, 6, 1, xx + 20, xx + 40);\n  deriv[0] = state[7];\n  deriv[1] = state[8];\n  deriv[2] = state[9];\n  deriv[3] = xx[7];\n  deriv[4] = xx[8];\n  deriv[5] = xx[9];\n  deriv[6] = xx[10];\n  deriv[7] = xx[71] - xx[0];\n  deriv[8] = xx[72] - xx[33];\n  deriv[9] = xx[73] - xx[37];\n  deriv[10] = xx[74] - xx[4];\n  deriv[11] = xx[75] - xx[16];\n  deriv[12] = xx[76] - xx[19];\n  deriv[13] = state[20];\n  deriv[14] = state[21];\n  deriv[15] = state[22];\n  deriv[16] = xx[48];\n  deriv[17] = xx[49];\n  deriv[18] = xx[50];\n  deriv[19] = xx[51];\n  deriv[20] = xx[20] - xx[32];\n  deriv[21] = xx[21] - xx[35];\n  deriv[22] = xx[22] - xx[38];\n  deriv[23] = xx[23] - xx[30];\n  deriv[24] = xx[24] - xx[3];\n  deriv[25] = xx[25] - xx[13];\n  errorResult[0] = xx[39];\n  return NULL;\n}\n\nPmfMessageId simulation_b048d748_1_numJacPerturbLoBounds(const\n  RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags, const double\n  *state, const int *modeVector, const double *input, const double *inputDot,\n  const double *inputDdot, const double *discreteState, double *bounds, double\n  *errorResult, NeuDiagnosticManager *neDiagMgr)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  double xx[2];\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) eqnEnableFlags;\n  (void) state;\n  (void) modeVector;\n  (void) input;\n  (void) inputDot;\n  (void) inputDdot;\n  (void) discreteState;\n  (void) neDiagMgr;\n  xx[0] = 1.0e-9;\n  xx[1] = 1.0e-8;\n  bounds[0] = xx[0];\n  bounds[1] = xx[0];\n  bounds[2] = xx[0];\n  bounds[3] = xx[1];\n  bounds[4] = xx[1];\n  bounds[5] = xx[1];\n  bounds[6] = xx[1];\n  bounds[7] = xx[0];\n  bounds[8] = xx[0];\n  bounds[9] = xx[0];\n  bounds[10] = xx[1];\n  bounds[11] = xx[1];\n  bounds[12] = xx[1];\n  bounds[13] = xx[0];\n  bounds[14] = xx[0];\n  bounds[15] = xx[0];\n  bounds[16] = xx[1];\n  bounds[17] = xx[1];\n  bounds[18] = xx[1];\n  bounds[19] = xx[1];\n  bounds[20] = xx[0];\n  bounds[21] = xx[0];\n  bounds[22] = xx[0];\n  bounds[23] = xx[1];\n  bounds[24] = xx[1];\n  bounds[25] = xx[1];\n  errorResult[0] = 0.0;\n  return NULL;\n}\n\nPmfMessageId simulation_b048d748_1_numJacPerturbHiBounds(const\n  RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags, const double\n  *state, const int *modeVector, const double *input, const double *inputDot,\n  const double *inputDdot, const double *discreteState, double *bounds, double\n  *errorResult, NeuDiagnosticManager *neDiagMgr)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  double xx[2];\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) eqnEnableFlags;\n  (void) state;\n  (void) modeVector;\n  (void) input;\n  (void) inputDot;\n  (void) inputDdot;\n  (void) discreteState;\n  (void) neDiagMgr;\n  xx[0] = +pmf_get_inf();\n  xx[1] = 0.1;\n  bounds[0] = xx[0];\n  bounds[1] = xx[0];\n  bounds[2] = xx[0];\n  bounds[3] = xx[1];\n  bounds[4] = xx[1];\n  bounds[5] = xx[1];\n  bounds[6] = xx[1];\n  bounds[7] = xx[0];\n  bounds[8] = xx[0];\n  bounds[9] = xx[0];\n  bounds[10] = xx[0];\n  bounds[11] = xx[0];\n  bounds[12] = xx[0];\n  bounds[13] = xx[0];\n  bounds[14] = xx[0];\n  bounds[15] = xx[0];\n  bounds[16] = xx[1];\n  bounds[17] = xx[1];\n  bounds[18] = xx[1];\n  bounds[19] = xx[1];\n  bounds[20] = xx[0];\n  bounds[21] = xx[0];\n  bounds[22] = xx[0];\n  bounds[23] = xx[0];\n  bounds[24] = xx[0];\n  bounds[25] = xx[0];\n  errorResult[0] = 0.0;\n  return NULL;\n}\n"},{"name":"simulation_b048d748_1_gateway.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n#include \"nesl_rtw.h\"\n#include \"simulation_b048d748_1.h\"\n#include \"simulation_b048d748_1_gateway.h\"\n\nvoid simulation_b048d748_1_gateway(void)\n{\n  NeModelParameters modelparams = { (NeSolverType) 0, 0.001, 0.001, 0.001, 0, 0,\n    (NeModifyAbsTol) 0, 0.001, 0, 0, 0, 0, (SscLoggingSetting) 0, 621213981, 1,\n    0, 0, };\n\n  NeSolverParameters solverparams = { 0, 0, 1, 0, 0, 0.001, 0.001, 1e-09, 0, 0,\n    100, 0, 1, (NeConsistencySolver) 0, (NeIndexReductionMethod) 1, 0, 1e-09,\n    (NeToleranceSource) 1, 0.001, 0.001, 0.001, 0, (NeLocalSolverChoice) 0, 1, 1,\n    0.001, 0, 3, 2, 0, 2, (NeLinearAlgebraChoice) 0, 0,\n    (NeEquationFormulationChoice) 0, 1024, 1, 0.001, (NePartitionStorageMethod)\n    0, 1024, (NePartitionMethod) 0, 0, (NeMultibodyLocalSolverChoice) 0, 0.001,\n  };\n\n  const NeOutputParameters* outputparameters = NULL;\n  NeDae* dae;\n  size_t numOutputs = 0;\n  int* rtpDaes = NULL;\n  int rtwLogDaes[1] = { 0 };\n\n  int* solverHitDaes = NULL;\n\n  {\n    static const NeOutputParameters outputparameters_init[] = { { 0, 0, }, { 0,\n        1, }, };\n\n    outputparameters = outputparameters_init;\n    numOutputs = sizeof(outputparameters_init)/sizeof(outputparameters_init[0]);\n  }\n\n  simulation_b048d748_1_dae(&dae,\n    &modelparams,\n    &solverparams);\n  nesl_register_simulator_group(\n    \"simulation/Plant/ World Setup/Solver Configuration_1\",\n    1,\n    &dae,\n    &solverparams,\n    &modelparams,\n    numOutputs,\n    outputparameters,\n    0,\n    rtpDaes,\n    1,\n    rtwLogDaes,\n    0,\n    solverHitDaes);\n}\n"},{"name":"simulation_b048d748_1_gateway.h","type":"header","group":"other","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"// Simscape target specific file.\n//  This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n\n\n#ifndef __simulation_b048d748_1_gateway_h__\n#define __simulation_b048d748_1_gateway_h__\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern void simulation_b048d748_1_gateway(void);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n#endif                           // #ifndef __simulation_b048d748_1_gateway_h__\n"},{"name":"simulation_b048d748_1_geometries.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include <math.h>\n#include <string.h>\n#include \"pm_std.h\"\n#include \"sm_std.h\"\n#include \"ne_std.h\"\n#include \"ne_dae.h\"\n#include \"sm_ssci_run_time_errors.h\"\n#include \"sm_RuntimeDerivedValuesBundle.h\"\n\nconst sm_core_compiler_ConvexPolyhedron *simulation_b048d748_1_geometry_0(const\n  RuntimeDerivedValuesBundle *rtdv)\n{\n  static const double hull_points[504] = { 0.01499999966472387,\n    -0.2920377254486084,\n    -4.097772021759914e-16, -0.01499999966472387, -0.2920377254486084,\n    -4.097772021759914e-16, -0.01499999966472387, 0.2920377254486084,\n    -4.097772021759914e-16, 0.01499999966472387, 0.2920377254486084,\n    -4.097772021759914e-16, 0.2920377254486084, -0.01499999966472387,\n    -4.097772021759914e-16, 2.327791415154934e-3, -0.07851865142583847,\n    1.962280988693237, 0.01159810367971659, -0.07769221812486649,\n    1.962280988693237, 0.02070560306310654, -0.07577516883611679,\n    1.962280988693237, 0.03792485222220421, -0.06879173964262009,\n    1.962280988693237, 0.02952244132757187, -0.07279439270496368,\n    1.962280988693237, 0.04579487815499306, -0.06382340937852859,\n    1.962280988693237, 0.05302204191684723, -0.05795913189649582,\n    1.962280988693237, -0.2920377254486084, -0.01499999966472387,\n    -4.097772021759914e-16, -0.2920377254486084, 0.01499999966472387,\n    -4.097772021759914e-16, -0.05636246129870415, -0.05471627786755562,\n    1.962280988693237, -0.0494953840970993, -0.06099839881062508,\n    1.962280988693237, -0.04193351045250893, -0.06642422825098038,\n    1.962280988693237, -0.03378297761082649, -0.07091761380434036,\n    1.962280988693237, -0.02515820600092411, -0.07441547513008118,\n    1.962280988693237, -0.01618026942014694, -0.0768686980009079,\n    1.962280988693237, -6.975197698920965e-3, -0.07824285328388214,\n    1.962280988693237, -0.07841518521308899, -4.6535381115973e-3,\n    1.962280988693237, -0.07731441408395767, -0.01389528904110193,\n    1.962280988693237, -0.07512830942869186, -0.02294198051095009,\n    1.962280988693237, -0.07188757508993149, -0.03166661784052849,\n    1.962280988693237, -0.06763768941164017, -0.03994672000408173,\n    1.962280988693237, -0.06243832036852837, -0.04766606539487839,\n    1.962280988693237, -0.05636246129870415, 0.05471627786755562,\n    1.962280988693237, -0.06243832036852837, 0.04766606539487839,\n    1.962280988693237, -0.07188757508993149, 0.03166661784052849,\n    1.962280988693237, -0.06763768941164017, 0.03994672000408173,\n    1.962280988693237, -0.07512830942869186, 0.02294198051095009,\n    1.962280988693237, -0.07731441408395767, 0.01389528904110193,\n    1.962280988693237, -0.07841518521308899, 4.6535381115973e-3,\n    1.962280988693237, 2.327791415154934e-3, 0.07851865142583847,\n    1.962280988693237, -6.975197698920965e-3, 0.07824285328388214,\n    1.962280988693237, -0.01618026942014694, 0.0768686980009079,\n    1.962280988693237, -0.02515820600092411, 0.07441547513008118,\n    1.962280988693237, -0.03378297761082649, 0.07091761380434036,\n    1.962280988693237, -0.04193351045250893, 0.06642422825098038,\n    1.962280988693237, -0.0494953840970993, 0.06099839881062508,\n    1.962280988693237, 0.05302204191684723, 0.05795913189649582,\n    1.962280988693237, 0.2920377254486084, 0.01499999966472387,\n    -4.097772021759914e-16, 0.04579487815499306, 0.06382340937852859,\n    1.962280988693237, 0.03792485222220421, 0.06879173964262009,\n    1.962280988693237, 0.02952244132757187, 0.07279439270496368,\n    1.962280988693237, 0.01159810367971659, 0.07769221812486649,\n    1.962280988693237, 0.02070560306310654, 0.07577516883611679,\n    1.962280988693237, 0.0763554647564888, 0.01845103874802589,\n    1.962280988693237, 0.07363726943731308, 0.02735233679413795,\n    1.962280988693237, 0.05880919843912125, 0.02184449695050716,\n    2.089521408081055, 0.06098004058003426, 0.01473561953753233,\n    2.089521408081055, 0.07800179719924927, 9.290730580687523e-3,\n    1.962280988693237, 0.06988536566495895, 0.03586966544389725,\n    1.962280988693237, 0.05581280589103699, 0.02864672243595123,\n    2.089521408081055, 0.06515242904424667, 0.04388346523046494,\n    1.962280988693237, 0.05950490012764931, 0.05128123983740807,\n    1.962280988693237, 0.05203292518854141, 0.03504680842161179,\n    2.089521408081055, 0.04234518483281136, 0.04628811031579971,\n    2.089521408081055, 0.04752260819077492, 0.04095491766929626,\n    2.089521408081055, 0.03028806112706661, 0.0549393966794014,\n    2.089521408081055, 0.03657332807779312, 0.05097151920199394,\n    2.089521408081055, 0.0235776137560606, 0.05813604593276978,\n    2.089521408081055, 9.262635372579098e-3, 0.06204762309789658,\n    2.089521408081055, -5.57062728330493e-3, 0.06248737871646881,\n    2.089521408081055, 1.859052455984056e-3, 0.06270763278007507,\n    2.089521408081055, -0.01292210724204779, 0.06138992309570312,\n    2.089521408081055, -0.02698022313416004, 0.05663719028234482,\n    2.089521408081055, -0.0200921893119812, 0.05943069607019424,\n    2.089521408081055, -0.03348951041698456, 0.05304862558841705,\n    2.089521408081055, -0.03952867910265923, 0.04871537163853645,\n    2.089521408081055, -0.04986534267663956, 0.03806772083044052,\n    2.089521408081055, -0.0450129508972168, 0.0436982586979866,\n    2.089521408081055, -0.05401773005723953, 0.03190279752016068,\n    2.089521408081055, -0.05999999493360519, 0.01832223683595657,\n    2.089521408081055, -0.05741183459758759, 0.02529002353549004,\n    2.089521408081055, -0.06262500584125519, 3.716472070664167e-3,\n    2.089521408081055, -0.06174588948488235, 0.01109724491834641,\n    2.089521408081055, -0.06262500584125519, -3.716472070664167e-3,\n    2.089521408081055, -0.05999999493360519, -0.01832223683595657,\n    2.089521408081055, -0.06174588948488235, -0.01109724491834641,\n    2.089521408081055, -0.05401773005723953, -0.03190279752016068,\n    2.089521408081055, -0.05741183459758759, -0.02529002353549004,\n    2.089521408081055, -0.03952867910265923, -0.04871537163853645,\n    2.089521408081055, -0.0450129508972168, -0.0436982586979866,\n    2.089521408081055, -0.04986534267663956, -0.03806772083044052,\n    2.089521408081055, -0.03348951041698456, -0.05304862558841705,\n    2.089521408081055, -0.02698022313416004, -0.05663719028234482,\n    2.089521408081055, -0.01292210724204779, -0.06138992309570312,\n    2.089521408081055, -0.0200921893119812, -0.05943069607019424,\n    2.089521408081055, -5.57062728330493e-3, -0.06248737871646881,\n    2.089521408081055, 9.262635372579098e-3, -0.06204762309789658,\n    2.089521408081055, 1.859052455984056e-3, -0.06270763278007507,\n    2.089521408081055, 0.0235776137560606, -0.05813604593276978,\n    2.089521408081055, 0.01653619110584259, -0.0605165921151638,\n    2.089521408081055, 0.03028806112706661, -0.0549393966794014,\n    2.089521408081055, 0.04234518483281136, -0.04628811031579971,\n    2.089521408081055, 0.03657332807779312, -0.05097151920199394,\n    2.089521408081055, 0.05950490012764931, -0.05128123983740807,\n    1.962280988693237, 0.06515242904424667, -0.04388346523046494,\n    1.962280988693237, 0.05203292518854141, -0.03504680842161179,\n    2.089521408081055, 0.04752260819077492, -0.04095491766929626,\n    2.089521408081055, 0.06988536566495895, -0.03586966544389725,\n    1.962280988693237, 0.05581280589103699, -0.02864672243595123,\n    2.089521408081055, 0.07363726943731308, -0.02735233679413795,\n    1.962280988693237, 0.0763554647564888, -0.01845103874802589,\n    1.962280988693237, 0.05880919843912125, -0.02184449695050716,\n    2.089521408081055, 0.07800179719924927, -9.290730580687523e-3,\n    1.962280988693237, 0.06098004058003426, -0.01473561953753233,\n    2.089521408081055, 0.07855315506458282, 0.0,\n    1.962280988693237, 0.06273519247770309, 0.0,\n    2.089521408081055, 0.0622948557138443, -7.41988979279995e-3,\n    2.089521408081055, 0.03649136424064636, 0.0,\n    2.21502685546875, 0.03623523190617561, -4.315949510782957e-3,\n    2.21502685546875, 0.03547044098377228, -8.571312762796879e-3,\n    2.21502685546875, 0.0622948557138443, 7.41988979279995e-3,\n    2.089521408081055, 0.0, 0.0,\n    2.337944507598877, 0.03623523190617561, 4.315949510782957e-3,\n    2.21502685546875, 0.03420772030949593, -0.01270635239779949,\n    2.21502685546875, 0.03246479853987694, -0.01666302420198917,\n    2.21502685546875, 0.03026614338159561, -0.02038578316569328,\n    2.21502685546875, 0.0276426188647747, -0.02382236905395985,\n    2.21502685546875, 0.02463105134665966, -0.02692454308271408,\n    2.21502685546875, 0.02127371542155743, -0.02964875474572182,\n    2.21502685546875, 0.01761774532496929, -0.03195676207542419,\n    2.21502685546875, 0.01371446065604687, -0.03381616622209549,\n    2.21502685546875, 9.618655778467655e-3, -0.03520086780190468,\n    2.21502685546875, 5.38782449439168e-3, -0.03609142452478409,\n    2.21502685546875, 1.081360504031181e-3, -0.03647533804178238,\n    2.21502685546875, -3.240283345803618e-3, -0.03634721785783768,\n    2.21502685546875, -7.516440469771624e-3, -0.03570885956287384,\n    2.21502685546875, -0.0116870841011405, -0.03456922993063927,\n    2.21502685546875, -0.01569366455078125, -0.03294432535767555,\n    2.21502685546875, -0.01947994343936443, -0.03085695207118988,\n    2.21502685546875, -0.02299276366829872, -0.0283364150673151,\n    2.21502685546875, -0.02618281915783882, -0.02541809529066086,\n    2.21502685546875, -0.02900532260537148, -0.02214296348392963,\n    2.21502685546875, -0.03142065554857254, -0.01855699345469475,\n    2.21502685546875, -0.03339491039514542, -0.01471052411943674,\n    2.21502685546875, -0.03490037471055984, -0.01065754983574152,\n    2.21502685546875, -0.03591591492295265, -6.454967427998781e-3,\n    2.21502685546875, -0.03642727434635162, -2.161771291866899e-3,\n    2.21502685546875, -0.03642727434635162, 2.161771291866899e-3,\n    2.21502685546875, -0.03591591492295265, 6.454967427998781e-3,\n    2.21502685546875, -0.03490037471055984, 0.01065754983574152,\n    2.21502685546875, -0.03339491039514542, 0.01471052411943674,\n    2.21502685546875, -0.03142065554857254, 0.01855699345469475,\n    2.21502685546875, -0.02900532260537148, 0.02214296348392963,\n    2.21502685546875, -0.02618281915783882, 0.02541809529066086,\n    2.21502685546875, -0.02299276366829872, 0.0283364150673151,\n    2.21502685546875, -0.01947994343936443, 0.03085695207118988,\n    2.21502685546875, -0.01569366455078125, 0.03294432535767555,\n    2.21502685546875, -0.0116870841011405, 0.03456922993063927,\n    2.21502685546875, -7.516440469771624e-3, 0.03570885956287384,\n    2.21502685546875, -3.240283345803618e-3, 0.03634721785783768,\n    2.21502685546875, 1.081360504031181e-3, 0.03647533804178238,\n    2.21502685546875, 5.38782449439168e-3, 0.03609142452478409,\n    2.21502685546875, 9.618655778467655e-3, 0.03520086780190468,\n    2.21502685546875, 0.01371446065604687, 0.03381616622209549,\n    2.21502685546875, 0.01761774532496929, 0.03195676207542419,\n    2.21502685546875, 0.02127371542155743, 0.02964875474572182,\n    2.21502685546875, 0.02463105134665966, 0.02692454308271408,\n    2.21502685546875, 0.0276426188647747, 0.02382236905395985,\n    2.21502685546875, 0.03026614338159561, 0.02038578316569328,\n    2.21502685546875, 0.03246479853987694, 0.01666302420198917,\n    2.21502685546875, 0.03420772030949593, 0.01270635239779949,\n    2.21502685546875, 0.03547044098377228, 8.571312762796879e-3,\n    2.21502685546875, 0.01653619110584259, 0.0605165921151638,\n    2.089521408081055 };\n\n  static const int vx_index[168] = { 0, 11,\n    23, 35, 46,\n    57, 64, 68,\n    74, 78, 83,\n    89, 94, 103,\n    114, 121, 126,\n    130, 135, 141,\n    146, 150, 155,\n    161, 165, 171,\n    175, 180, 187,\n    192, 198, 202,\n    206, 212, 217,\n    224, 228, 233,\n    239, 244, 248,\n    253, 258, 268,\n    274, 278, 283,\n    287, 293, 298,\n    303, 309, 314,\n    320, 324, 332,\n    337, 343, 349,\n    356, 360, 367,\n    373, 379, 387,\n    395, 399, 404,\n    409, 415, 422,\n    429, 436, 440,\n    446, 453, 459,\n    465, 470, 476,\n    483, 488, 494,\n    500, 507, 511,\n    518, 525, 530,\n    535, 541, 549,\n    557, 561, 567,\n    571, 578, 585,\n    591, 597, 602,\n    608, 612, 616,\n    624, 629, 634,\n    640, 646, 651,\n    656, 662, 668,\n    674, 678, 684,\n    690, 743, 747,\n    752, 756, 761,\n    767, 772, 776,\n    781, 786, 792,\n    796, 802, 806,\n    812, 816, 822,\n    827, 831, 837,\n    841, 847, 851,\n    856, 861, 867,\n    872, 877, 882,\n    886, 892, 896,\n    902, 906, 911,\n    917, 921, 927,\n    931, 937, 941,\n    947, 952, 957,\n    961, 966, 972,\n    977, 981, 986,\n    992 };\n\n  static const int vx_valency[168] = { 11, 12,\n    12, 11, 11,\n    7, 4, 6,\n    4, 5, 6,\n    5, 9, 11,\n    7, 5, 4,\n    5, 6, 5,\n    4, 5, 6,\n    4, 6, 4,\n    5, 7, 5,\n    6, 4, 4,\n    6, 5, 7,\n    4, 5, 6,\n    5, 4, 5,\n    5, 10, 6,\n    4, 5, 4,\n    6, 5, 5,\n    6, 5, 6,\n    4, 8, 5,\n    6, 6, 7,\n    4, 7, 6,\n    6, 8, 8,\n    4, 5, 5,\n    6, 7, 7,\n    7, 4, 6,\n    7, 6, 6,\n    5, 6, 7,\n    5, 6, 6,\n    7, 4, 7,\n    7, 5, 5,\n    6, 8, 8,\n    4, 6, 4,\n    7, 7, 6,\n    6, 5, 6,\n    4, 4, 8,\n    5, 5, 6,\n    6, 5, 5,\n    6, 6, 6,\n    4, 6, 6,\n    53, 4, 5,\n    4, 5, 6,\n    5, 4, 5,\n    5, 6, 4,\n    6, 4, 6,\n    4, 6, 5,\n    4, 6, 4,\n    6, 4, 5,\n    5, 6, 5,\n    5, 5, 4,\n    6, 4, 6,\n    4, 5, 6,\n    4, 6, 4,\n    6, 4, 6,\n    5, 5, 4,\n    5, 6, 5,\n    4, 5, 6,\n    4 };\n\n  static const int vx_adjacency_graph[996] = { 1, 2,\n    3, 4, 11,\n    10, 8, 9,\n    7, 6, 5,\n    2, 0, 5,\n    20, 19, 18,\n    17, 16, 15,\n    14, 12, 13,\n    0, 1, 13,\n    27, 40, 39,\n    38, 37, 36,\n    35, 34, 3,\n    0, 2, 34,\n    46, 47, 45,\n    44, 43, 41,\n    42, 4, 0,\n    3, 42, 109,\n    107, 105, 104,\n    102, 99, 98,\n    11, 1, 0,\n    6, 91, 92,\n    90, 20, 5,\n    0, 7, 91,\n    6, 0, 9,\n    93, 94, 91,\n    9, 0, 10,\n    95, 0, 8,\n    95, 93, 7,\n    8, 0, 11,\n    96, 97, 95,\n    10, 0, 4,\n    98, 96, 13,\n    1, 14, 26,\n    25, 24, 23,\n    22, 21, 1,\n    12, 21, 33,\n    32, 31, 29,\n    30, 28, 27,\n    2, 12, 1,\n    15, 83, 84,\n    85, 26, 14,\n    1, 16, 86,\n    83, 15, 1,\n    17, 86, 16,\n    1, 18, 87,\n    86, 17, 1,\n    19, 88, 89,\n    87, 18, 1,\n    20, 90, 88,\n    19, 1, 5,\n    90, 13, 12,\n    22, 78, 33,\n    21, 12, 23,\n    79, 80, 78,\n    22, 12, 24,\n    79, 23, 12,\n    25, 81, 82,\n    79, 24, 12,\n    26, 81, 12,\n    14, 85, 81,\n    25, 2, 13,\n    28, 71, 72,\n    70, 40, 27,\n    13, 30, 73,\n    71, 30, 13,\n    31, 74, 75,\n    73, 13, 29,\n    73, 28, 29,\n    13, 32, 74,\n    31, 13, 33,\n    76, 77, 74,\n    32, 13, 21,\n    78, 76, 3,\n    2, 35, 64,\n    65, 63, 46,\n    34, 2, 36,\n    64, 35, 2,\n    37, 66, 64,\n    36, 2, 38,\n    67, 68, 66,\n    37, 2, 39,\n    69, 67, 38,\n    2, 40, 69,\n    39, 2, 27,\n    70, 69, 42,\n    3, 43, 58,\n    56, 3, 41,\n    56, 55, 53,\n    49, 48, 52,\n    109, 4, 41,\n    3, 44, 60,\n    61, 58, 43,\n    3, 45, 60,\n    44, 3, 47,\n    62, 60, 47,\n    3, 34, 63,\n    3, 46, 63,\n    167, 62, 45,\n    49, 50, 51,\n    52, 42, 50,\n    48, 42, 53,\n    54, 48, 49,\n    54, 165, 166,\n    51, 48, 50,\n    166, 115, 52,\n    48, 51, 115,\n    110, 109, 42,\n    54, 49, 42,\n    55, 49, 53,\n    55, 57, 163,\n    164, 165, 50,\n    54, 53, 42,\n    56, 57, 57,\n    55, 42, 41,\n    58, 59, 55,\n    56, 59, 162,\n    163, 54, 56,\n    41, 43, 61,\n    161, 162, 59,\n    56, 58, 162,\n    57, 43, 44,\n    45, 62, 158,\n    159, 61, 43,\n    60, 159, 160,\n    161, 58, 45,\n    47, 167, 157,\n    158, 60, 46,\n    34, 65, 155,\n    156, 157, 167,\n    47, 34, 35,\n    36, 66, 153,\n    154, 155, 65,\n    34, 64, 155,\n    63, 36, 37,\n    68, 153, 64,\n    37, 38, 69,\n    151, 68, 37,\n    67, 151, 152,\n    153, 66, 38,\n    39, 40, 70,\n    150, 151, 67,\n    40, 27, 72,\n    148, 149, 150,\n    69, 27, 28,\n    73, 146, 147,\n    148, 72, 27,\n    71, 148, 70,\n    28, 30, 29,\n    75, 146, 71,\n    29, 31, 32,\n    77, 143, 144,\n    75, 29, 74,\n    144, 145, 146,\n    73, 32, 33,\n    78, 141, 142,\n    77, 32, 76,\n    142, 143, 74,\n    33, 21, 22,\n    80, 141, 76,\n    22, 23, 24,\n    82, 139, 140,\n    80, 22, 79,\n    140, 141, 78,\n    24, 25, 26,\n    85, 137, 82,\n    24, 81, 137,\n    138, 139, 79,\n    14, 15, 86,\n    133, 134, 135,\n    84, 14, 83,\n    135, 85, 14,\n    84, 135, 136,\n    137, 81, 26,\n    15, 16, 17,\n    87, 132, 133,\n    83, 17, 18,\n    89, 132, 86,\n    18, 19, 90,\n    130, 89, 18,\n    88, 130, 131,\n    132, 87, 19,\n    20, 5, 92,\n    128, 129, 130,\n    88, 5, 6,\n    7, 94, 126,\n    127, 128, 92,\n    5, 91, 128,\n    90, 7, 9,\n    95, 125, 126,\n    94, 7, 93,\n    126, 91, 8,\n    10, 97, 124,\n    125, 93, 9,\n    10, 11, 98,\n    101, 121, 122,\n    97, 10, 96,\n    122, 123, 124,\n    95, 96, 11,\n    4, 99, 100,\n    101, 100, 98,\n    4, 102, 103,\n    98, 99, 103,\n    120, 121, 101,\n    98, 100, 121,\n    96, 103, 99,\n    4, 104, 99,\n    102, 104, 106,\n    118, 119, 120,\n    100, 103, 102,\n    4, 105, 106,\n    106, 104, 4,\n    107, 108, 104,\n    105, 108, 114,\n    118, 103, 108,\n    105, 4, 109,\n    110, 111, 105,\n    107, 111, 114,\n    106, 110, 107,\n    4, 42, 52,\n    107, 109, 52,\n    115, 112, 111,\n    108, 107, 110,\n    112, 113, 114,\n    111, 110, 115,\n    117, 116, 113,\n    114, 111, 112,\n    116, 111, 113,\n    116, 118, 106,\n    108, 110, 52,\n    51, 166, 117,\n    112, 113, 112,\n    117, 166, 165,\n    164, 163, 162,\n    161, 160, 159,\n    158, 157, 156,\n    155, 154, 153,\n    152, 151, 150,\n    149, 148, 147,\n    146, 145, 144,\n    143, 142, 141,\n    140, 139, 138,\n    137, 136, 135,\n    134, 133, 132,\n    131, 130, 129,\n    128, 127, 126,\n    125, 124, 123,\n    122, 121, 120,\n    119, 118, 114,\n    112, 115, 166,\n    116, 114, 116,\n    119, 103, 106,\n    118, 116, 120,\n    103, 119, 116,\n    121, 100, 103,\n    120, 116, 122,\n    96, 101, 100,\n    121, 116, 123,\n    97, 96, 122,\n    116, 124, 97,\n    123, 116, 125,\n    95, 97, 124,\n    116, 126, 93,\n    95, 125, 116,\n    127, 91, 94,\n    93, 126, 116,\n    128, 91, 127,\n    116, 129, 90,\n    92, 91, 128,\n    116, 130, 90,\n    129, 116, 131,\n    89, 88, 90,\n    130, 116, 132,\n    89, 131, 116,\n    133, 86, 87,\n    89, 132, 116,\n    134, 83, 86,\n    133, 116, 135,\n    83, 134, 116,\n    136, 85, 84,\n    83, 135, 116,\n    137, 85, 136,\n    116, 138, 82,\n    81, 85, 137,\n    116, 139, 82,\n    138, 116, 140,\n    79, 82, 139,\n    116, 141, 80,\n    79, 140, 116,\n    142, 76, 78,\n    80, 141, 116,\n    143, 77, 76,\n    142, 116, 144,\n    74, 77, 143,\n    116, 145, 75,\n    74, 144, 116,\n    146, 75, 145,\n    116, 147, 71,\n    73, 75, 146,\n    116, 148, 71,\n    147, 116, 149,\n    70, 72, 71,\n    148, 116, 150,\n    70, 149, 116,\n    151, 69, 70,\n    150, 116, 152,\n    68, 67, 69,\n    151, 116, 153,\n    68, 152, 116,\n    154, 64, 66,\n    68, 153, 116,\n    155, 64, 154,\n    116, 156, 63,\n    65, 64, 155,\n    116, 157, 63,\n    156, 116, 158,\n    62, 167, 63,\n    157, 116, 159,\n    60, 62, 158,\n    116, 160, 61,\n    60, 159, 116,\n    161, 61, 160,\n    116, 162, 58,\n    61, 161, 116,\n    163, 57, 59,\n    58, 162, 116,\n    164, 54, 57,\n    163, 116, 165,\n    54, 164, 116,\n    166, 50, 54,\n    165, 116, 117,\n    115, 51, 50,\n    47, 63, 157,\n    62 };\n\n  static const int seed_vx_ids[8] = { 161, 148,\n    135, 122, 42,\n    13, 12, 4 };\n\n  static sm_core_compiler_ConvexPolyhedron cxh;\n  cxh.hullPoints = hull_points;\n  cxh.vxIndex = vx_index;\n  cxh.vxValency = vx_valency;\n  cxh.numHullPoints = 168;\n  cxh.vxAdjacencyGraph = vx_adjacency_graph;\n  cxh.graphSize = 996;\n  cxh.seedVxIds = seed_vx_ids;\n  cxh.scale = 2.337944507598877;\n  (void) rtdv;\n  return &cxh;\n}\n\nconst sm_core_compiler_Cylinder *simulation_b048d748_1_geometry_1(const\n  RuntimeDerivedValuesBundle *rtdv)\n{\n  static const sm_core_compiler_Cylinder cylinder = { 0.045, 0.045 };\n\n  (void) rtdv;\n  return &cylinder;\n}\n\nconst sm_core_compiler_Cylinder *simulation_b048d748_1_geometry_2(const\n  RuntimeDerivedValuesBundle *rtdv)\n{\n  static const sm_core_compiler_Cylinder cylinder = { 0.045, 0.09 };\n\n  (void) rtdv;\n  return &cylinder;\n}\n\nconst sm_core_compiler_Brick *simulation_b048d748_1_geometry_3(const\n  RuntimeDerivedValuesBundle *rtdv)\n{\n  static const sm_core_compiler_Brick brick = { 10.0, 10.0, 0.2 };\n\n  (void) rtdv;\n  return &brick;\n}\n\nvoid simulation_b048d748_1_initializeGeometries(const struct\n  RuntimeDerivedValuesBundleTag *rtdv)\n{\n  simulation_b048d748_1_geometry_0(rtdv);\n  simulation_b048d748_1_geometry_1(rtdv);\n  simulation_b048d748_1_geometry_2(rtdv);\n  simulation_b048d748_1_geometry_3(rtdv);\n}\n"},{"name":"simulation_b048d748_1_geometries.h","type":"header","group":"other","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"// Simscape target specific file.\n//  This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n\n\nconst sm_core_compiler_ConvexPolyhedron *simulation_b048d748_1_geometry_0(const\n  RuntimeDerivedValuesBundle *rtdv);\nconst sm_core_compiler_Cylinder *simulation_b048d748_1_geometry_1(const\n  RuntimeDerivedValuesBundle *rtdv);\nconst sm_core_compiler_Cylinder *simulation_b048d748_1_geometry_2(const\n  RuntimeDerivedValuesBundle *rtdv);\nconst sm_core_compiler_Brick *simulation_b048d748_1_geometry_3(const\n  RuntimeDerivedValuesBundle *rtdv);\nstruct RuntimeDerivedValuesBundleTag;\nvoid simulation_b048d748_1_initializeGeometries(const struct\n  RuntimeDerivedValuesBundleTag *rtdv);\n"},{"name":"simulation_b048d748_1_logging.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include <math.h>\n#include <string.h>\n#include \"pm_std.h\"\n#include \"sm_std.h\"\n#include \"ne_std.h\"\n#include \"ne_dae.h\"\n#include \"sm_ssci_run_time_errors.h\"\n#include \"sm_RuntimeDerivedValuesBundle.h\"\n#include \"simulation_b048d748_1_geometries.h\"\n\nPmfMessageId simulation_b048d748_1_recordLog(const RuntimeDerivedValuesBundle\n  *rtdv, const int *eqnEnableFlags, const double *state, const int *modeVector,\n  const double *input, const double *inputDot, const double *inputDdot, double\n  *logVector, double *errorResult, NeuDiagnosticManager *neDiagMgr)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  boolean_T bb[2];\n  int ii[6];\n  double xx[545];\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) eqnEnableFlags;\n  (void) inputDot;\n  (void) neDiagMgr;\n  xx[0] = 57.29577951308232;\n  xx[1] = 1.0;\n  xx[2] = 2.0;\n  xx[3] = state[5] * state[5];\n  xx[4] = state[6] * state[6];\n  xx[5] = xx[2] * (xx[3] + xx[4]);\n  xx[6] = state[4] * state[5];\n  xx[7] = state[3] * state[6];\n  xx[8] = xx[2] * (xx[6] - xx[7]);\n  xx[9] = state[3] * state[5];\n  xx[10] = state[4] * state[6];\n  xx[11] = xx[2] * (xx[9] + xx[10]);\n  xx[12] = xx[1] - xx[5];\n  xx[13] = xx[8];\n  xx[14] = xx[11];\n  xx[15] = 1.1;\n  xx[16] = 0.5;\n  xx[17] = xx[16] * state[13];\n  xx[18] = cos(xx[17]);\n  xx[19] = xx[16] * state[14];\n  xx[16] = cos(xx[19]);\n  xx[20] = xx[18] * xx[16];\n  xx[21] = xx[20] * xx[20];\n  xx[22] = sin(xx[17]);\n  xx[17] = xx[16] * xx[22];\n  xx[23] = xx[17] * xx[17];\n  xx[24] = xx[2] * (xx[21] + xx[23]) - xx[1];\n  xx[25] = sin(xx[19]);\n  xx[26] = xx[18] * xx[25];\n  xx[18] = xx[26] * xx[17];\n  xx[27] = xx[22] * xx[25];\n  xx[22] = xx[20] * xx[27];\n  xx[28] = xx[18] - xx[22];\n  xx[29] = xx[2] * xx[28];\n  xx[30] = xx[17] * xx[27];\n  xx[31] = xx[20] * xx[26];\n  xx[32] = xx[2] * (xx[30] + xx[31]);\n  xx[33] = xx[2] * (xx[18] + xx[22]);\n  xx[34] = xx[26] * xx[26];\n  xx[35] = xx[2] * (xx[21] + xx[34]) - xx[1];\n  xx[36] = xx[26] * xx[27];\n  xx[37] = xx[20] * xx[17];\n  xx[38] = xx[2] * (xx[36] - xx[37]);\n  xx[39] = xx[2] * (xx[30] - xx[31]);\n  xx[40] = xx[2] * (xx[36] + xx[37]);\n  xx[41] = xx[27] * xx[27];\n  xx[42] = xx[2] * (xx[21] + xx[41]) - xx[1];\n  xx[43] = xx[24];\n  xx[44] = xx[29];\n  xx[45] = xx[32];\n  xx[46] = xx[33];\n  xx[47] = xx[35];\n  xx[48] = xx[38];\n  xx[49] = xx[39];\n  xx[50] = xx[40];\n  xx[51] = xx[42];\n  xx[21] = 0.1;\n  xx[52] = xx[21] * xx[24];\n  xx[53] = xx[21] * xx[33];\n  xx[54] = xx[21] * xx[39];\n  xx[55] = xx[21] * xx[29];\n  xx[56] = xx[21] * xx[35];\n  xx[57] = xx[21] * xx[40];\n  xx[58] = xx[21] * xx[32];\n  xx[59] = xx[21] * xx[38];\n  xx[60] = xx[21] * xx[42];\n  pm_math_Matrix3x3_compose_ra(xx + 43, xx + 52, xx + 61);\n  xx[52] = xx[15] + xx[61];\n  xx[53] = xx[15] + xx[65];\n  xx[70] = xx[52];\n  xx[71] = xx[62];\n  xx[72] = xx[63];\n  xx[73] = xx[64];\n  xx[74] = xx[53];\n  xx[75] = xx[66];\n  xx[76] = xx[67];\n  xx[77] = xx[68];\n  xx[78] = xx[15] + xx[69];\n  pm_math_Matrix3x3_xform_ra(xx + 70, xx + 12, xx + 54);\n  xx[15] = xx[2] * (xx[7] + xx[6]);\n  xx[57] = state[4] * state[4];\n  xx[58] = xx[2] * (xx[4] + xx[57]);\n  xx[59] = state[5] * state[6];\n  xx[60] = state[3] * state[4];\n  xx[79] = xx[2] * (xx[59] - xx[60]);\n  xx[80] = xx[15];\n  xx[81] = xx[1] - xx[58];\n  xx[82] = xx[79];\n  pm_math_Matrix3x3_xform_ra(xx + 70, xx + 80, xx + 83);\n  xx[86] = pm_math_Vector3_dot_ra(xx + 12, xx + 83);\n  xx[87] = xx[2] * (xx[10] - xx[9]);\n  xx[88] = xx[2] * (xx[60] + xx[59]);\n  xx[89] = xx[2] * (xx[57] + xx[3]);\n  xx[90] = xx[87];\n  xx[91] = xx[88];\n  xx[92] = xx[1] - xx[89];\n  pm_math_Matrix3x3_xform_ra(xx + 70, xx + 90, xx + 93);\n  xx[96] = pm_math_Vector3_dot_ra(xx + 12, xx + 93);\n  xx[97] = 0.04499999999999999;\n  xx[98] = xx[97] * xx[26];\n  xx[99] = xx[98] * xx[20];\n  xx[100] = xx[97] * xx[17];\n  xx[101] = xx[2] * (xx[99] + xx[100] * xx[27]);\n  xx[102] = xx[2] * (xx[100] * xx[20] - xx[98] * xx[27]);\n  xx[103] = xx[98] * xx[26];\n  xx[104] = xx[2] * (xx[100] * xx[17] + xx[103]) - xx[97] - xx[1];\n  xx[105] = - xx[101];\n  xx[106] = xx[102];\n  xx[107] = xx[104];\n  pm_math_Matrix3x3_postCross_ra(xx + 61, xx + 105, xx + 108);\n  xx[61] = - (xx[108] + xx[62]);\n  xx[62] = xx[111] + xx[53];\n  xx[53] = - xx[62];\n  xx[63] = - (xx[114] + xx[68]);\n  xx[117] = xx[61];\n  xx[118] = xx[53];\n  xx[119] = xx[63];\n  xx[65] = pm_math_Vector3_dot_ra(xx + 12, xx + 117);\n  xx[66] = xx[52] - xx[109];\n  xx[52] = xx[64] - xx[112];\n  xx[64] = xx[67] - xx[115];\n  xx[67] = xx[66];\n  xx[68] = xx[52];\n  xx[69] = xx[64];\n  xx[100] = pm_math_Vector3_dot_ra(xx + 12, xx + 67);\n  xx[120] = - xx[110];\n  xx[121] = - xx[113];\n  xx[122] = - xx[116];\n  xx[123] = pm_math_Vector3_dot_ra(xx + 12, xx + 120);\n  xx[124] = pm_math_Vector3_dot_ra(xx + 80, xx + 93);\n  xx[125] = pm_math_Vector3_dot_ra(xx + 80, xx + 117);\n  xx[126] = pm_math_Vector3_dot_ra(xx + 80, xx + 67);\n  xx[127] = pm_math_Vector3_dot_ra(xx + 80, xx + 120);\n  xx[128] = pm_math_Vector3_dot_ra(xx + 90, xx + 117);\n  xx[117] = pm_math_Vector3_dot_ra(xx + 90, xx + 67);\n  xx[67] = pm_math_Vector3_dot_ra(xx + 90, xx + 120);\n  xx[68] = 1.181250000000001e-4;\n  xx[69] = 1.0125e-4;\n  xx[129] = xx[68] * xx[24];\n  xx[130] = xx[68] * xx[33];\n  xx[131] = xx[68] * xx[39];\n  xx[132] = xx[68] * xx[29];\n  xx[133] = xx[68] * xx[35];\n  xx[134] = xx[68] * xx[40];\n  xx[135] = xx[69] * xx[32];\n  xx[136] = xx[69] * xx[38];\n  xx[137] = xx[69] * xx[42];\n  pm_math_Matrix3x3_compose_ra(xx + 43, xx + 129, xx + 138);\n  pm_math_Matrix3x3_preCross_ra(xx + 108, xx + 105, xx + 129);\n  xx[24] = xx[1] + xx[138] - xx[129] + xx[111];\n  xx[32] = xx[139] - xx[130] - xx[108];\n  xx[33] = xx[32] - xx[52];\n  xx[35] = xx[140] - xx[131];\n  xx[40] = xx[35] + xx[113];\n  xx[42] = xx[1] + xx[142] - xx[133] - xx[109];\n  xx[116] = xx[143] - xx[134];\n  xx[118] = xx[116] - xx[110];\n  xx[119] = xx[1] + xx[146] - xx[137];\n  xx[147] = pm_math_Vector3_dot_ra(xx + 12, xx + 54);\n  xx[148] = xx[86];\n  xx[149] = xx[96];\n  xx[150] = xx[65];\n  xx[151] = xx[100];\n  xx[152] = xx[123];\n  xx[153] = xx[86];\n  xx[154] = pm_math_Vector3_dot_ra(xx + 80, xx + 83);\n  xx[155] = xx[124];\n  xx[156] = xx[125];\n  xx[157] = xx[126];\n  xx[158] = xx[127];\n  xx[159] = xx[96];\n  xx[160] = xx[124];\n  xx[161] = pm_math_Vector3_dot_ra(xx + 90, xx + 93);\n  xx[162] = xx[128];\n  xx[163] = xx[117];\n  xx[164] = xx[67];\n  xx[165] = xx[65];\n  xx[166] = xx[125];\n  xx[167] = xx[128];\n  xx[168] = xx[24] + xx[62];\n  xx[169] = xx[33];\n  xx[170] = xx[40];\n  xx[171] = xx[100];\n  xx[172] = xx[126];\n  xx[173] = xx[117];\n  xx[174] = xx[33];\n  xx[175] = xx[42] + xx[66];\n  xx[176] = xx[118];\n  xx[177] = xx[123];\n  xx[178] = xx[127];\n  xx[179] = xx[67];\n  xx[180] = xx[40];\n  xx[181] = xx[118];\n  xx[182] = xx[119];\n  ii[0] = factorSymmetricPosDef(xx + 147, 6, xx + 123);\n  if (ii[0] != 0) {\n    return sm_ssci_recordRunTimeError(\n      \"physmod:sm:core:compiler:mechanism:mechanism:degenerateMassFoll\",\n      \"'simulation/Plant/ Rocket Body/Free Movement' has a degenerate mass distribution on its follower side.\",\n      neDiagMgr);\n  }\n\n  xx[33] = 0.0;\n  bb[0] = modeVector[0] == -1;\n  xx[40] = xx[1] - xx[2] * (xx[34] + xx[41]);\n  xx[62] = - state[3];\n  xx[65] = - state[4];\n  xx[67] = - state[5];\n  xx[86] = - state[6];\n  xx[123] = xx[62];\n  xx[124] = xx[65];\n  xx[125] = xx[67];\n  xx[126] = xx[86];\n  xx[96] = - xx[17];\n  xx[100] = - xx[26];\n  xx[117] = - xx[27];\n  xx[183] = - xx[20];\n  xx[184] = xx[96];\n  xx[185] = xx[100];\n  xx[186] = xx[117];\n  pm_math_Quaternion_compose_ra(xx + 123, xx + 183, xx + 187);\n  xx[118] = xx[40] * xx[189];\n  xx[127] = xx[2] * (xx[31] + xx[30]);\n  xx[30] = xx[127] * xx[190];\n  xx[31] = xx[40] * xx[188];\n  xx[128] = xx[30] + xx[31];\n  xx[191] = xx[127] * xx[189];\n  xx[192] = xx[118];\n  xx[193] = - xx[128];\n  xx[194] = xx[191];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 192, xx + 195);\n  xx[192] = xx[2] * (xx[118] * xx[187] + xx[195]) - xx[127];\n  xx[193] = xx[2] * (xx[196] - xx[128] * xx[187]);\n  xx[194] = xx[40] + xx[2] * (xx[191] * xx[187] + xx[197]);\n  xx[118] = state[20] * state[20];\n  xx[128] = state[21] * state[21];\n  xx[191] = xx[2] * (xx[118] + xx[128]) - xx[1];\n  xx[195] = state[21] * state[22];\n  xx[196] = state[20] * state[23];\n  xx[197] = xx[2] * (xx[195] + xx[196]);\n  xx[198] = state[21] * state[23];\n  xx[199] = state[20] * state[22];\n  xx[200] = xx[2] * (xx[198] - xx[199]);\n  xx[201] = xx[191];\n  xx[202] = xx[197];\n  xx[203] = xx[200];\n  xx[204] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 192, xx + 201);\n  xx[192] = xx[2] * (xx[22] + xx[18]);\n  xx[18] = xx[192] * xx[189];\n  xx[22] = xx[38] * xx[190];\n  xx[193] = xx[192] * xx[188];\n  xx[194] = xx[22] + xx[193];\n  xx[205] = xx[38] * xx[189];\n  xx[206] = xx[18];\n  xx[207] = - xx[194];\n  xx[208] = xx[205];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 206, xx + 209);\n  xx[206] = xx[2] * (xx[18] * xx[187] + xx[209]) - xx[38];\n  xx[207] = xx[2] * (xx[210] - xx[194] * xx[187]);\n  xx[208] = xx[192] + xx[2] * (xx[205] * xx[187] + xx[211]);\n  xx[18] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 206, xx + 201);\n  xx[194] = xx[39] * xx[189];\n  xx[205] = xx[1] - xx[2] * (xx[23] + xx[34]);\n  xx[34] = xx[205] * xx[190];\n  xx[206] = xx[39] * xx[188];\n  xx[207] = xx[34] + xx[206];\n  xx[208] = xx[205] * xx[189];\n  xx[209] = xx[194];\n  xx[210] = - xx[207];\n  xx[211] = xx[208];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 209, xx + 212);\n  xx[209] = xx[2] * (xx[194] * xx[187] + xx[212]) - xx[205];\n  xx[210] = xx[2] * (xx[213] - xx[207] * xx[187]);\n  xx[211] = xx[39] + xx[2] * (xx[208] * xx[187] + xx[214]);\n  xx[194] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 209, xx + 201);\n  xx[207] = xx[33];\n  xx[208] = xx[33];\n  xx[209] = xx[33];\n  xx[210] = xx[204];\n  xx[211] = xx[18];\n  xx[212] = xx[194];\n  solveSymmetricPosDef(xx + 147, xx + 207, 6, 1, xx + 213, xx + 219);\n  xx[207] = state[22] * state[22];\n  xx[208] = state[23] * state[23];\n  xx[209] = xx[2] * (xx[207] + xx[208]);\n  xx[210] = xx[1] - xx[209];\n  xx[211] = xx[2] * (xx[195] - xx[196]);\n  xx[212] = xx[2] * (xx[199] + xx[198]);\n  xx[213] = xx[21] * xx[210];\n  xx[214] = xx[21] * xx[211];\n  xx[215] = xx[21] * xx[212];\n  xx[219] = xx[2] * (xx[196] + xx[195]);\n  xx[220] = xx[21] * xx[219];\n  xx[221] = xx[2] * (xx[208] + xx[128]);\n  xx[222] = xx[1] - xx[221];\n  xx[223] = xx[21] * xx[222];\n  xx[224] = state[22] * state[23];\n  xx[225] = state[20] * state[21];\n  xx[226] = xx[2] * (xx[224] - xx[225]);\n  xx[227] = xx[21] * xx[226];\n  xx[228] = xx[220];\n  xx[229] = xx[223];\n  xx[230] = xx[227];\n  xx[231] = pm_math_Vector3_dot_ra(xx + 210, xx + 228);\n  xx[232] = xx[21] * xx[200];\n  xx[233] = xx[2] * (xx[225] + xx[224]);\n  xx[234] = xx[21] * xx[233];\n  xx[235] = xx[2] * (xx[128] + xx[207]);\n  xx[128] = xx[1] - xx[235];\n  xx[236] = xx[21] * xx[128];\n  xx[237] = xx[232];\n  xx[238] = xx[234];\n  xx[239] = xx[236];\n  xx[240] = pm_math_Vector3_dot_ra(xx + 210, xx + 237);\n  xx[241] = xx[219];\n  xx[242] = xx[222];\n  xx[243] = xx[226];\n  xx[244] = pm_math_Vector3_dot_ra(xx + 241, xx + 237);\n  xx[245] = xx[200];\n  xx[246] = xx[233];\n  xx[247] = xx[128];\n  xx[248] = 6.750000000000001e-5;\n  xx[249] = pm_math_Vector3_dot_ra(xx + 210, xx + 213);\n  xx[250] = xx[231];\n  xx[251] = xx[240];\n  xx[252] = xx[33];\n  xx[253] = xx[33];\n  xx[254] = xx[33];\n  xx[255] = xx[231];\n  xx[256] = pm_math_Vector3_dot_ra(xx + 241, xx + 228);\n  xx[257] = xx[244];\n  xx[258] = xx[33];\n  xx[259] = xx[33];\n  xx[260] = xx[33];\n  xx[261] = xx[240];\n  xx[262] = xx[244];\n  xx[263] = pm_math_Vector3_dot_ra(xx + 245, xx + 237);\n  xx[264] = xx[33];\n  xx[265] = xx[33];\n  xx[266] = xx[33];\n  xx[267] = xx[33];\n  xx[268] = xx[33];\n  xx[269] = xx[33];\n  xx[270] = xx[248];\n  xx[271] = xx[33];\n  xx[272] = xx[33];\n  xx[273] = xx[33];\n  xx[274] = xx[33];\n  xx[275] = xx[33];\n  xx[276] = xx[33];\n  xx[277] = xx[248];\n  xx[278] = xx[33];\n  xx[279] = xx[33];\n  xx[280] = xx[33];\n  xx[281] = xx[33];\n  xx[282] = xx[33];\n  xx[283] = xx[33];\n  xx[284] = xx[69];\n  ii[0] = factorSymmetricPosDef(xx + 249, 6, xx + 285);\n  if (ii[0] != 0) {\n    return sm_ssci_recordRunTimeError(\n      \"physmod:sm:core:compiler:mechanism:mechanism:degenerateMassImplicit6Dof\",\n      \"An implicit 6-DOF joint is attached to a degenerate mass distribution.\",\n      neDiagMgr);\n  }\n\n  xx[228] = - xx[212];\n  xx[229] = xx[2] * (xx[225] - xx[224]);\n  xx[230] = xx[235] - xx[1];\n  xx[231] = xx[188] * xx[189];\n  xx[235] = xx[187] * xx[190];\n  xx[237] = xx[2] * (xx[231] - xx[235]);\n  xx[238] = xx[187] * xx[187];\n  xx[239] = xx[189] * xx[189];\n  xx[240] = xx[2] * (xx[238] + xx[239]) - xx[1];\n  xx[244] = xx[189] * xx[190];\n  xx[285] = xx[187] * xx[188];\n  xx[286] = xx[2] * (xx[244] + xx[285]);\n  xx[287] = xx[237];\n  xx[288] = xx[240];\n  xx[289] = xx[286];\n  xx[290] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 228, xx + 287);\n  xx[228] = xx[211];\n  xx[229] = xx[222];\n  xx[230] = xx[233];\n  xx[222] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 228, xx + 287);\n  xx[291] = xx[33];\n  xx[292] = xx[33];\n  xx[293] = xx[33];\n  xx[294] = xx[33];\n  xx[295] = xx[290];\n  xx[296] = xx[222];\n  solveSymmetricPosDef(xx + 249, xx + 291, 6, 1, xx + 297, xx + 303);\n  xx[228] = xx[40] * xx[190];\n  xx[229] = xx[29] * xx[190];\n  xx[230] = xx[29] * xx[189];\n  xx[291] = xx[31] + xx[230];\n  xx[292] = xx[228];\n  xx[293] = xx[229];\n  xx[294] = - xx[291];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 292, xx + 295);\n  xx[292] = xx[29] + xx[2] * (xx[228] * xx[187] + xx[295]);\n  xx[293] = xx[2] * (xx[229] * xx[187] + xx[296]) - xx[40];\n  xx[294] = xx[2] * (xx[297] - xx[291] * xx[187]);\n  xx[31] = xx[2] * (xx[118] + xx[207]) - xx[1];\n  xx[207] = xx[2] * (xx[224] + xx[225]);\n  xx[295] = xx[211];\n  xx[296] = xx[31];\n  xx[297] = xx[207];\n  xx[224] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 292, xx + 295);\n  xx[225] = xx[1] - xx[2] * (xx[41] + xx[23]);\n  xx[23] = xx[192] * xx[190];\n  xx[41] = xx[225] * xx[190];\n  xx[228] = xx[225] * xx[189];\n  xx[229] = xx[193] + xx[228];\n  xx[291] = xx[23];\n  xx[292] = xx[41];\n  xx[293] = - xx[229];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 291, xx + 298);\n  xx[291] = xx[225] + xx[2] * (xx[23] * xx[187] + xx[298]);\n  xx[292] = xx[2] * (xx[41] * xx[187] + xx[299]) - xx[192];\n  xx[293] = xx[2] * (xx[300] - xx[229] * xx[187]);\n  xx[23] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 291, xx + 295);\n  xx[41] = xx[2] * (xx[37] + xx[36]);\n  xx[36] = xx[39] * xx[190];\n  xx[37] = xx[41] * xx[190];\n  xx[193] = xx[41] * xx[189];\n  xx[229] = xx[206] + xx[193];\n  xx[291] = xx[36];\n  xx[292] = xx[37];\n  xx[293] = - xx[229];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 291, xx + 298);\n  xx[291] = xx[41] + xx[2] * (xx[36] * xx[187] + xx[298]);\n  xx[292] = xx[2] * (xx[37] * xx[187] + xx[299]) - xx[39];\n  xx[293] = xx[2] * (xx[300] - xx[229] * xx[187]);\n  xx[36] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 291, xx + 295);\n  xx[303] = xx[33];\n  xx[304] = xx[33];\n  xx[305] = xx[33];\n  xx[306] = xx[224];\n  xx[307] = xx[23];\n  xx[308] = xx[36];\n  solveSymmetricPosDef(xx + 147, xx + 303, 6, 1, xx + 309, xx + 315);\n  xx[291] = xx[212];\n  xx[292] = xx[226];\n  xx[293] = xx[128];\n  xx[37] = xx[188] * xx[190];\n  xx[128] = xx[187] * xx[189];\n  xx[206] = xx[2] * (xx[37] + xx[128]);\n  xx[229] = xx[2] * (xx[244] - xx[285]);\n  xx[294] = xx[190] * xx[190];\n  xx[298] = xx[2] * (xx[238] + xx[294]) - xx[1];\n  xx[303] = xx[206];\n  xx[304] = xx[229];\n  xx[305] = xx[298];\n  xx[299] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 291, xx + 303);\n  xx[291] = xx[209] - xx[1];\n  xx[292] = - xx[219];\n  xx[293] = xx[2] * (xx[199] - xx[198]);\n  xx[209] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 291, xx + 303);\n  xx[306] = xx[33];\n  xx[307] = xx[33];\n  xx[308] = xx[33];\n  xx[309] = xx[299];\n  xx[310] = xx[33];\n  xx[311] = xx[209];\n  solveSymmetricPosDef(xx + 249, xx + 306, 6, 1, xx + 315, xx + 321);\n  xx[291] = xx[312] * xx[204] + xx[313] * xx[18] + xx[314] * xx[194] + xx[319] *\n    xx[290] + xx[320] * xx[222];\n  xx[292] = xx[230] + xx[30];\n  xx[30] = xx[29] * xx[188];\n  xx[230] = xx[127] * xx[188];\n  xx[306] = - xx[292];\n  xx[307] = xx[30];\n  xx[308] = xx[230];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 306, xx + 309);\n  xx[306] = xx[2] * (xx[309] - xx[292] * xx[187]);\n  xx[307] = xx[127] + xx[2] * (xx[30] * xx[187] + xx[310]);\n  xx[308] = xx[2] * (xx[230] * xx[187] + xx[311]) - xx[29];\n  xx[30] = xx[2] * (xx[198] + xx[199]);\n  xx[198] = xx[2] * (xx[118] + xx[208]) - xx[1];\n  xx[309] = xx[30];\n  xx[310] = xx[226];\n  xx[311] = xx[198];\n  xx[118] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 306, xx + 309);\n  xx[199] = xx[228] + xx[22];\n  xx[22] = xx[225] * xx[188];\n  xx[208] = xx[38] * xx[188];\n  xx[306] = - xx[199];\n  xx[307] = xx[22];\n  xx[308] = xx[208];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 306, xx + 321);\n  xx[306] = xx[2] * (xx[321] - xx[199] * xx[187]);\n  xx[307] = xx[38] + xx[2] * (xx[22] * xx[187] + xx[322]);\n  xx[308] = xx[2] * (xx[208] * xx[187] + xx[323]) - xx[225];\n  xx[22] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 306, xx + 309);\n  xx[38] = xx[193] + xx[34];\n  xx[34] = xx[41] * xx[188];\n  xx[193] = xx[205] * xx[188];\n  xx[306] = - xx[38];\n  xx[307] = xx[34];\n  xx[308] = xx[193];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 306, xx + 321);\n  xx[306] = xx[2] * (xx[321] - xx[38] * xx[187]);\n  xx[307] = xx[205] + xx[2] * (xx[34] * xx[187] + xx[322]);\n  xx[308] = xx[2] * (xx[193] * xx[187] + xx[323]) - xx[41];\n  xx[34] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 306, xx + 309);\n  xx[321] = xx[33];\n  xx[322] = xx[33];\n  xx[323] = xx[33];\n  xx[324] = xx[118];\n  xx[325] = xx[22];\n  xx[326] = xx[34];\n  solveSymmetricPosDef(xx + 147, xx + 321, 6, 1, xx + 327, xx + 333);\n  xx[306] = xx[2] * (xx[196] - xx[195]);\n  xx[307] = xx[221] - xx[1];\n  xx[308] = - xx[233];\n  xx[38] = xx[188] * xx[188];\n  xx[193] = xx[2] * (xx[238] + xx[38]) - xx[1];\n  xx[195] = xx[2] * (xx[231] + xx[235]);\n  xx[196] = xx[2] * (xx[37] - xx[128]);\n  xx[321] = xx[193];\n  xx[322] = xx[195];\n  xx[323] = xx[196];\n  xx[199] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 306, xx + 321);\n  xx[306] = xx[210];\n  xx[307] = xx[219];\n  xx[308] = xx[200];\n  xx[205] = bb[0] ? xx[33] : pm_math_Vector3_dot_ra(xx + 306, xx + 321);\n  xx[324] = xx[33];\n  xx[325] = xx[33];\n  xx[326] = xx[33];\n  xx[327] = xx[199];\n  xx[328] = xx[205];\n  xx[329] = xx[33];\n  solveSymmetricPosDef(xx + 249, xx + 324, 6, 1, xx + 333, xx + 339);\n  xx[208] = xx[330] * xx[204] + xx[331] * xx[18] + xx[332] * xx[194] + xx[337] *\n    xx[290] + xx[338] * xx[222];\n  xx[219] = - xx[1];\n  xx[221] = bb[0] ? xx[33] : xx[219];\n  xx[228] = 0.04500000000000001;\n  xx[230] = xx[228] * xx[40];\n  xx[233] = xx[230] * xx[190];\n  xx[238] = xx[228] * xx[29];\n  xx[292] = xx[238] * xx[190];\n  xx[293] = xx[230] * xx[188] + xx[238] * xx[189];\n  xx[306] = - xx[233];\n  xx[307] = - xx[292];\n  xx[308] = xx[293];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 306, xx + 324);\n  xx[300] = xx[2] * (xx[324] - xx[233] * xx[187]) - xx[238];\n  xx[233] = xx[102] * state[5];\n  xx[238] = state[6] * xx[104];\n  xx[306] = xx[233] + xx[238];\n  xx[327] = xx[65];\n  xx[328] = xx[67];\n  xx[329] = xx[86];\n  xx[307] = xx[102] * state[4];\n  xx[308] = state[4] * xx[104];\n  xx[339] = - xx[306];\n  xx[340] = xx[307];\n  xx[341] = xx[308];\n  pm_math_Vector3_cross_ra(xx + 327, xx + 339, xx + 342);\n  xx[339] = bb[0] ? xx[33] : - (xx[300] + xx[2] * (state[3] * xx[306] + xx[342])\n    + xx[2] * (xx[7] - xx[6]));\n  xx[306] = xx[228] * xx[192];\n  xx[192] = xx[306] * xx[190];\n  xx[340] = xx[228] * xx[225];\n  xx[225] = xx[340] * xx[190];\n  xx[341] = xx[306] * xx[188] + xx[340] * xx[189];\n  xx[345] = - xx[192];\n  xx[346] = - xx[225];\n  xx[347] = xx[341];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 345, xx + 348);\n  xx[345] = xx[101] * state[5];\n  xx[346] = xx[101] * state[4];\n  xx[347] = xx[238] - xx[346];\n  xx[238] = state[5] * xx[104];\n  xx[351] = - xx[345];\n  xx[352] = - xx[347];\n  xx[353] = xx[238];\n  pm_math_Vector3_cross_ra(xx + 327, xx + 351, xx + 354);\n  xx[351] = bb[0] ? xx[33] : - (xx[2] * (xx[348] - xx[192] * xx[187]) - xx[340]\n    + xx[104] + xx[2] * (xx[354] + xx[345] * state[3]) - xx[5] + xx[1]);\n  xx[5] = xx[228] * xx[39];\n  xx[39] = xx[5] * xx[190];\n  xx[192] = xx[228] * xx[41];\n  xx[41] = xx[192] * xx[190];\n  xx[340] = xx[5] * xx[188] + xx[192] * xx[189];\n  xx[357] = - xx[39];\n  xx[358] = - xx[41];\n  xx[359] = xx[340];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 357, xx + 360);\n  xx[345] = xx[101] * state[6];\n  xx[352] = xx[102] * state[6];\n  xx[353] = xx[233] - xx[346];\n  xx[357] = - xx[345];\n  xx[358] = xx[352];\n  xx[359] = - xx[353];\n  pm_math_Vector3_cross_ra(xx + 327, xx + 357, xx + 363);\n  xx[233] = bb[0] ? xx[33] : - (xx[2] * (xx[360] - xx[39] * xx[187]) - xx[192] +\n    xx[2] * (xx[363] + xx[345] * state[3]) - xx[102]);\n  xx[366] = xx[221];\n  xx[367] = xx[33];\n  xx[368] = xx[33];\n  xx[369] = xx[339];\n  xx[370] = xx[351];\n  xx[371] = xx[233];\n  solveSymmetricPosDef(xx + 147, xx + 366, 6, 1, xx + 372, xx + 378);\n  xx[39] = bb[0] ? xx[33] : xx[1];\n  xx[192] = 0.0225;\n  xx[327] = xx[192] * state[23];\n  xx[328] = xx[327] * state[20];\n  xx[329] = xx[192] * state[21];\n  xx[345] = bb[0] ? xx[33] : xx[2] * (xx[328] - xx[329] * state[22]);\n  xx[346] = xx[192] * state[22];\n  xx[357] = xx[327] * state[23];\n  xx[358] = bb[0] ? xx[33] : xx[192] - xx[2] * (xx[346] * state[22] + xx[357]);\n  xx[366] = xx[39];\n  xx[367] = xx[33];\n  xx[368] = xx[33];\n  xx[369] = xx[345];\n  xx[370] = xx[358];\n  xx[371] = xx[33];\n  solveSymmetricPosDef(xx + 249, xx + 366, 6, 1, xx + 378, xx + 384);\n  xx[359] = xx[375] * xx[204] + xx[376] * xx[18] + xx[377] * xx[194] + xx[382] *\n    xx[290] + xx[383] * xx[222];\n  xx[366] = xx[2] * (xx[325] - xx[292] * xx[187]);\n  xx[292] = bb[0] ? xx[33] : - (xx[366] + xx[2] * (xx[343] - xx[307] * state[3])\n    + xx[58] - xx[104] + xx[230] - xx[1]);\n  xx[58] = bb[0] ? xx[33] : - (xx[2] * (xx[349] - xx[225] * xx[187]) + xx[306] +\n    xx[2] * (state[3] * xx[347] + xx[355]) + xx[15]);\n  xx[15] = bb[0] ? xx[33] : - (xx[2] * (xx[361] - xx[41] * xx[187]) + xx[5] +\n    xx[2] * (xx[364] - xx[352] * state[3]) - xx[101]);\n  xx[384] = xx[33];\n  xx[385] = xx[221];\n  xx[386] = xx[33];\n  xx[387] = xx[292];\n  xx[388] = xx[58];\n  xx[389] = xx[15];\n  solveSymmetricPosDef(xx + 147, xx + 384, 6, 1, xx + 390, xx + 396);\n  xx[5] = bb[0] ? xx[33] : xx[2] * (xx[357] + xx[329] * state[21]) - xx[192];\n  xx[41] = bb[0] ? xx[33] : xx[2] * (xx[328] + xx[346] * state[21]);\n  xx[384] = xx[33];\n  xx[385] = xx[39];\n  xx[386] = xx[33];\n  xx[387] = xx[5];\n  xx[388] = xx[41];\n  xx[389] = xx[33];\n  solveSymmetricPosDef(xx + 249, xx + 384, 6, 1, xx + 396, xx + 402);\n  xx[104] = xx[393] * xx[204] + xx[394] * xx[18] + xx[395] * xx[194] + xx[400] *\n    xx[290] + xx[401] * xx[222];\n  xx[225] = xx[2] * (xx[326] + xx[293] * xx[187]);\n  xx[293] = bb[0] ? xx[33] : - (xx[225] + xx[102] + xx[2] * (xx[344] - xx[308] *\n    state[3]) - xx[88]);\n  xx[88] = bb[0] ? xx[33] : - (xx[2] * (xx[350] + xx[341] * xx[187]) + xx[2] *\n    (xx[356] - xx[238] * state[3]) + xx[101] + xx[87]);\n  xx[101] = bb[0] ? xx[33] : - (xx[2] * (xx[362] + xx[340] * xx[187]) + xx[2] *\n    (state[3] * xx[353] + xx[365]));\n  xx[352] = xx[33];\n  xx[353] = xx[33];\n  xx[354] = xx[221];\n  xx[355] = xx[293];\n  xx[356] = xx[88];\n  xx[357] = xx[101];\n  solveSymmetricPosDef(xx + 147, xx + 352, 6, 1, xx + 360, xx + 384);\n  xx[102] = bb[0] ? xx[33] : - (xx[2] * (xx[329] * state[20] + xx[327] * state\n    [22]));\n  xx[238] = bb[0] ? xx[33] : xx[2] * (xx[327] * state[21] - xx[346] * state[20]);\n  xx[324] = xx[33];\n  xx[325] = xx[33];\n  xx[326] = xx[39];\n  xx[327] = xx[102];\n  xx[328] = xx[238];\n  xx[329] = xx[33];\n  solveSymmetricPosDef(xx + 249, xx + 324, 6, 1, xx + 352, xx + 384);\n  xx[306] = xx[363] * xx[204] + xx[364] * xx[18] + xx[365] * xx[194] + xx[356] *\n    xx[290] + xx[357] * xx[222];\n  xx[307] = xx[330] * xx[224] + xx[331] * xx[23] + xx[332] * xx[36] + xx[336] *\n    xx[299] + xx[338] * xx[209];\n  xx[308] = xx[375] * xx[224] + xx[376] * xx[23] + xx[377] * xx[36] + xx[381] *\n    xx[299] + xx[383] * xx[209];\n  xx[315] = xx[393] * xx[224] + xx[394] * xx[23] + xx[395] * xx[36] + xx[399] *\n    xx[299] + xx[401] * xx[209];\n  xx[316] = xx[363] * xx[224] + xx[364] * xx[23] + xx[365] * xx[36] + xx[355] *\n    xx[299] + xx[357] * xx[209];\n  xx[317] = xx[375] * xx[118] + xx[376] * xx[22] + xx[377] * xx[34] + xx[381] *\n    xx[199] + xx[382] * xx[205];\n  xx[319] = xx[393] * xx[118] + xx[394] * xx[22] + xx[395] * xx[34] + xx[399] *\n    xx[199] + xx[400] * xx[205];\n  xx[324] = xx[363] * xx[118] + xx[364] * xx[22] + xx[365] * xx[34] + xx[355] *\n    xx[199] + xx[356] * xx[205];\n  xx[325] = xx[390] * xx[221] + xx[393] * xx[339] + xx[394] * xx[351] + xx[395] *\n    xx[233] + xx[396] * xx[39] + xx[399] * xx[345] + xx[400] * xx[358];\n  xx[326] = xx[360] * xx[221] + xx[363] * xx[339] + xx[364] * xx[351] + xx[365] *\n    xx[233] + xx[352] * xx[39] + xx[355] * xx[345] + xx[356] * xx[358];\n  xx[327] = xx[361] * xx[221] + xx[363] * xx[292] + xx[364] * xx[58] + xx[365] *\n    xx[15] + xx[353] * xx[39] + xx[355] * xx[5] + xx[356] * xx[41];\n  xx[401] = xx[216] * xx[204] + xx[217] * xx[18] + xx[218] * xx[194] + xx[301] *\n    xx[290] + xx[302] * xx[222];\n  xx[402] = xx[291];\n  xx[403] = xx[208];\n  xx[404] = xx[359];\n  xx[405] = xx[104];\n  xx[406] = xx[306];\n  xx[407] = xx[291];\n  xx[408] = xx[312] * xx[224] + xx[313] * xx[23] + xx[314] * xx[36] + xx[318] *\n    xx[299] + xx[320] * xx[209];\n  xx[409] = xx[307];\n  xx[410] = xx[308];\n  xx[411] = xx[315];\n  xx[412] = xx[316];\n  xx[413] = xx[208];\n  xx[414] = xx[307];\n  xx[415] = xx[330] * xx[118] + xx[331] * xx[22] + xx[332] * xx[34] + xx[336] *\n    xx[199] + xx[337] * xx[205];\n  xx[416] = xx[317];\n  xx[417] = xx[319];\n  xx[418] = xx[324];\n  xx[419] = xx[359];\n  xx[420] = xx[308];\n  xx[421] = xx[317];\n  xx[422] = xx[372] * xx[221] + xx[375] * xx[339] + xx[376] * xx[351] + xx[377] *\n    xx[233] + xx[378] * xx[39] + xx[381] * xx[345] + xx[382] * xx[358];\n  xx[423] = xx[325];\n  xx[424] = xx[326];\n  xx[425] = xx[104];\n  xx[426] = xx[315];\n  xx[427] = xx[319];\n  xx[428] = xx[325];\n  xx[429] = xx[391] * xx[221] + xx[393] * xx[292] + xx[394] * xx[58] + xx[395] *\n    xx[15] + xx[397] * xx[39] + xx[399] * xx[5] + xx[400] * xx[41];\n  xx[430] = xx[327];\n  xx[431] = xx[306];\n  xx[432] = xx[316];\n  xx[433] = xx[324];\n  xx[434] = xx[326];\n  xx[435] = xx[327];\n  xx[436] = xx[362] * xx[221] + xx[363] * xx[293] + xx[364] * xx[88] + xx[365] *\n    xx[101] + xx[354] * xx[39] + xx[355] * xx[102] + xx[356] * xx[238];\n  ii[0] = bb[0] ? 0 : 1;\n  xx[104] = xx[2] * (xx[10] + xx[9]);\n  xx[9] = state[3] * state[3];\n  xx[10] = xx[2] * (xx[9] + xx[57]) - xx[1];\n  xx[57] = xx[104] * state[10] - xx[10] * state[12];\n  xx[208] = xx[10] * state[11] - xx[8] * state[10];\n  xx[216] = xx[8] * state[12] - xx[104] * state[11];\n  xx[217] = xx[216] * state[11] - xx[57] * state[10];\n  xx[218] = xx[2] * (xx[6] + xx[7]);\n  xx[6] = xx[79] * state[10] - xx[218] * state[12];\n  xx[7] = xx[2] * (xx[9] + xx[3]) - xx[1];\n  xx[3] = xx[218] * state[11] - xx[7] * state[10];\n  xx[291] = xx[7] * state[12] - xx[79] * state[11];\n  xx[301] = xx[291] * state[11] - xx[6] * state[10];\n  xx[302] = xx[2] * (xx[9] + xx[4]) - xx[1];\n  xx[4] = xx[302] * state[10] - xx[87] * state[12];\n  xx[9] = xx[2] * (xx[59] + xx[60]);\n  xx[306] = xx[87] * state[11] - xx[9] * state[10];\n  xx[307] = xx[9] * state[12] - xx[302] * state[11];\n  xx[308] = xx[307] * state[11] - xx[4] * state[10];\n  xx[312] = xx[57] * state[12] - xx[208] * state[11];\n  xx[313] = xx[208] * state[10] - xx[216] * state[12];\n  xx[314] = xx[217];\n  xx[315] = xx[6] * state[12] - xx[3] * state[11];\n  xx[316] = xx[3] * state[10] - xx[291] * state[12];\n  xx[317] = xx[301];\n  xx[318] = xx[4] * state[12] - xx[306] * state[11];\n  xx[319] = xx[306] * state[10] - xx[307] * state[12];\n  xx[320] = xx[308];\n  pm_math_Matrix3x3_compose_ra(xx + 312, xx + 43, xx + 324);\n  xx[367] = xx[10];\n  xx[368] = xx[8];\n  xx[369] = xx[104];\n  xx[370] = xx[218];\n  xx[371] = xx[7];\n  xx[372] = xx[79];\n  xx[373] = xx[87];\n  xx[374] = xx[9];\n  xx[375] = xx[302];\n  xx[3] = xx[127] * state[15];\n  xx[4] = xx[3] * xx[3];\n  xx[6] = xx[2] * xx[28] * state[15] + state[16];\n  xx[7] = xx[6] * xx[6];\n  xx[8] = xx[40] * state[15];\n  xx[9] = xx[8] * xx[6];\n  xx[333] = xx[8];\n  xx[334] = xx[6];\n  xx[335] = xx[3];\n  xx[336] = xx[40];\n  xx[337] = xx[29];\n  xx[338] = xx[127];\n  pm_math_Vector3_cross_ra(xx + 333, xx + 336, xx + 340);\n  xx[10] = state[15] * xx[342];\n  xx[28] = xx[3] * xx[8];\n  xx[57] = state[15] * xx[341];\n  xx[79] = xx[8] * xx[8];\n  xx[87] = xx[3] * xx[6];\n  xx[104] = state[15] * xx[340];\n  xx[376] = - (xx[4] + xx[7]);\n  xx[377] = xx[9] + xx[10];\n  xx[378] = xx[28] - xx[57];\n  xx[379] = xx[9] - xx[10];\n  xx[380] = - (xx[4] + xx[79]);\n  xx[381] = xx[87] + xx[104];\n  xx[382] = xx[28] + xx[57];\n  xx[383] = xx[87] - xx[104];\n  xx[384] = - (xx[7] + xx[79]);\n  pm_math_Matrix3x3_compose_ra(xx + 43, xx + 376, xx + 385);\n  pm_math_Matrix3x3_compose_ra(xx + 367, xx + 385, xx + 43);\n  xx[367] = xx[193];\n  xx[368] = xx[237];\n  xx[369] = xx[206];\n  xx[370] = xx[195];\n  xx[371] = xx[240];\n  xx[372] = xx[229];\n  xx[373] = xx[196];\n  xx[374] = xx[286];\n  xx[375] = xx[298];\n  xx[336] = state[10];\n  xx[337] = state[11];\n  xx[338] = state[12];\n  pm_math_Quaternion_inverseXform_ra(xx + 183, xx + 336, xx + 340);\n  pm_math_Matrix3x3_postCross_ra(xx + 367, xx + 340, xx + 376);\n  pm_math_Matrix3x3_postCross_ra(xx + 376, xx + 333, xx + 367);\n  xx[333] = xx[325] + xx[44] + xx[2] * xx[368];\n  xx[334] = xx[328] + xx[47] + xx[2] * xx[371];\n  xx[335] = xx[331] + xx[50] + xx[2] * xx[374];\n  xx[4] = xx[30] * state[27] - xx[191] * state[29];\n  xx[7] = xx[191] * state[28] - xx[211] * state[27];\n  xx[9] = xx[226] * state[27] - xx[197] * state[29];\n  xx[10] = xx[197] * state[28] - xx[31] * state[27];\n  xx[28] = xx[198] * state[27] - xx[200] * state[29];\n  xx[57] = xx[200] * state[28] - xx[207] * state[27];\n  xx[346] = xx[4] * state[29] - xx[7] * state[28];\n  xx[347] = xx[9] * state[29] - xx[10] * state[28];\n  xx[348] = xx[28] * state[29] - xx[57] * state[28];\n  xx[79] = - state[21];\n  xx[87] = - state[22];\n  xx[104] = - state[23];\n  xx[352] = xx[79];\n  xx[353] = xx[87];\n  xx[354] = xx[104];\n  xx[127] = state[22] * state[28];\n  xx[191] = state[23] * state[29];\n  xx[193] = xx[127] + xx[191];\n  xx[195] = state[21] * state[28];\n  xx[197] = state[21] * state[29];\n  xx[355] = xx[193];\n  xx[356] = - xx[195];\n  xx[357] = - xx[197];\n  pm_math_Vector3_cross_ra(xx + 352, xx + 355, xx + 359);\n  xx[355] = xx[2] * (xx[359] - state[20] * xx[193]);\n  xx[356] = state[29] + xx[2] * (xx[195] * state[20] + xx[360]);\n  xx[357] = xx[2] * (xx[197] * state[20] + xx[361]) - state[28];\n  xx[193] = xx[340] + xx[8];\n  xx[195] = xx[193] * xx[189];\n  xx[197] = xx[342] + xx[3];\n  xx[3] = xx[197] * xx[190];\n  xx[200] = xx[193] * xx[188];\n  xx[206] = xx[3] + xx[200];\n  xx[208] = xx[197] * xx[189];\n  xx[359] = xx[195];\n  xx[360] = - xx[206];\n  xx[361] = xx[208];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 359, xx + 362);\n  xx[359] = xx[2] * (xx[195] * xx[187] + xx[362]) - xx[197];\n  xx[360] = xx[2] * (xx[363] - xx[206] * xx[187]);\n  xx[361] = xx[193] + xx[2] * (xx[208] * xx[187] + xx[364]);\n  xx[195] = xx[326] + xx[45] + xx[2] * xx[369];\n  xx[206] = xx[329] + xx[48] + xx[2] * xx[372];\n  xx[208] = xx[332] + xx[51] + xx[2] * xx[375];\n  xx[362] = xx[195];\n  xx[363] = xx[206];\n  xx[364] = xx[208];\n  xx[216] = xx[211] * state[29] - xx[30] * state[28];\n  xx[30] = xx[31] * state[29] - xx[226] * state[28];\n  xx[31] = xx[207] * state[29] - xx[198] * state[28];\n  xx[376] = xx[7] * state[27] - xx[216] * state[29];\n  xx[377] = xx[10] * state[27] - xx[30] * state[29];\n  xx[378] = xx[57] * state[27] - xx[31] * state[29];\n  xx[7] = state[22] * state[27];\n  xx[10] = state[21] * state[27];\n  xx[57] = xx[191] + xx[10];\n  xx[191] = state[22] * state[29];\n  xx[379] = - xx[7];\n  xx[380] = xx[57];\n  xx[381] = - xx[191];\n  pm_math_Vector3_cross_ra(xx + 352, xx + 379, xx + 382);\n  xx[379] = xx[2] * (xx[7] * state[20] + xx[382]) - state[29];\n  xx[380] = xx[2] * (xx[383] - state[20] * xx[57]);\n  xx[381] = state[27] + xx[2] * (xx[191] * state[20] + xx[384]);\n  xx[7] = xx[341] + xx[6];\n  xx[57] = xx[193] * xx[190];\n  xx[191] = xx[7] * xx[190];\n  xx[198] = xx[7] * xx[189];\n  xx[207] = xx[200] + xx[198];\n  xx[382] = xx[57];\n  xx[383] = xx[191];\n  xx[384] = - xx[207];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 382, xx + 394);\n  xx[382] = xx[7] + xx[2] * (xx[57] * xx[187] + xx[394]);\n  xx[383] = xx[2] * (xx[191] * xx[187] + xx[395]) - xx[193];\n  xx[384] = xx[2] * (xx[396] - xx[207] * xx[187]);\n  xx[394] = xx[324] + xx[43] + xx[2] * xx[367];\n  xx[395] = xx[327] + xx[46] + xx[2] * xx[370];\n  xx[396] = xx[330] + xx[49] + xx[2] * xx[373];\n  xx[43] = xx[216] * state[28] - xx[4] * state[27];\n  xx[4] = xx[30] * state[28] - xx[9] * state[27];\n  xx[9] = xx[31] * state[28] - xx[28] * state[27];\n  xx[44] = xx[43];\n  xx[45] = xx[4];\n  xx[46] = xx[9];\n  xx[28] = state[23] * state[27];\n  xx[30] = state[23] * state[28];\n  xx[31] = xx[10] + xx[127];\n  xx[47] = - xx[28];\n  xx[48] = - xx[30];\n  xx[49] = xx[31];\n  pm_math_Vector3_cross_ra(xx + 352, xx + 47, xx + 324);\n  xx[47] = state[28] + xx[2] * (xx[28] * state[20] + xx[324]);\n  xx[48] = xx[2] * (xx[30] * state[20] + xx[325]) - state[27];\n  xx[49] = xx[2] * (xx[326] - state[20] * xx[31]);\n  xx[10] = xx[198] + xx[3];\n  xx[3] = xx[7] * xx[188];\n  xx[28] = xx[197] * xx[188];\n  xx[324] = - xx[10];\n  xx[325] = xx[3];\n  xx[326] = xx[28];\n  pm_math_Vector3_cross_ra(xx + 188, xx + 324, xx + 327);\n  xx[324] = xx[2] * (xx[327] - xx[10] * xx[187]);\n  xx[325] = xx[197] + xx[2] * (xx[3] * xx[187] + xx[328]);\n  xx[326] = xx[2] * (xx[28] * xx[187] + xx[329]) - xx[7];\n  pm_math_Matrix3x3_xform_ra(xx + 312, xx + 105, xx + 327);\n  xx[312] = - (xx[97] * xx[387]);\n  xx[313] = - (xx[97] * xx[390]);\n  xx[314] = - (xx[97] * xx[393]);\n  pm_math_Quaternion_xform_ra(xx + 123, xx + 312, xx + 315);\n  xx[312] = xx[96];\n  xx[313] = xx[100];\n  xx[314] = xx[117];\n  xx[3] = xx[97] * xx[8];\n  xx[7] = xx[3] * xx[27];\n  xx[8] = xx[97] * xx[6];\n  xx[6] = xx[8] * xx[27];\n  xx[10] = xx[3] * xx[17] + xx[8] * xx[26];\n  xx[318] = xx[7];\n  xx[319] = xx[6];\n  xx[320] = - xx[10];\n  pm_math_Vector3_cross_ra(xx + 312, xx + 318, xx + 330);\n  xx[318] = xx[2] * (xx[330] - xx[7] * xx[20]) - xx[8];\n  xx[319] = xx[2] * (xx[331] - xx[6] * xx[20]) + xx[3];\n  xx[320] = xx[2] * (xx[332] + xx[20] * xx[10]);\n  pm_math_Vector3_cross_ra(xx + 336, xx + 318, xx + 6);\n  pm_math_Quaternion_xform_ra(xx + 123, xx + 6, xx + 318);\n  xx[367] = pm_math_Vector3_dot_ra(xx + 333, xx + 201) + pm_math_Vector3_dot_ra\n    (xx + 346, xx + 287) + pm_math_Vector3_dot_ra(xx + 355, xx + 359) * xx[2];\n  xx[368] = pm_math_Vector3_dot_ra(xx + 362, xx + 295) + pm_math_Vector3_dot_ra\n    (xx + 376, xx + 303) + pm_math_Vector3_dot_ra(xx + 379, xx + 382) * xx[2];\n  xx[369] = pm_math_Vector3_dot_ra(xx + 394, xx + 309) + pm_math_Vector3_dot_ra\n    (xx + 44, xx + 321) + pm_math_Vector3_dot_ra(xx + 47, xx + 324) * xx[2];\n  xx[370] = xx[192] * xx[43] - (xx[327] + xx[217] + xx[315] + xx[2] * xx[318] -\n    xx[228] * xx[195]);\n  xx[371] = xx[192] * xx[4] - (xx[328] + xx[301] + xx[316] + xx[2] * xx[319] -\n    xx[228] * xx[206]);\n  xx[372] = xx[192] * xx[9] - (xx[329] + xx[308] + xx[317] + xx[2] * xx[320] -\n    xx[228] * xx[208]);\n  zeroMajor(1, 6, ii + 0, xx + 367);\n  pm_math_Vector3_cross_ra(xx + 336, xx + 105, xx + 6);\n  pm_math_Vector3_cross_ra(xx + 336, xx + 6, xx + 43);\n  pm_math_Quaternion_inverseXform_ra(xx + 183, xx + 43, xx + 46);\n  xx[3] = xx[2] * xx[25] * xx[25];\n  xx[4] = (xx[1] - xx[3]) * state[15];\n  xx[9] = xx[97] * xx[4];\n  xx[10] = xx[2] * xx[16] * xx[25];\n  xx[16] = xx[10] * state[15];\n  xx[25] = xx[342] + xx[16];\n  xx[28] = xx[342] + xx[25];\n  xx[301] = xx[1];\n  xx[302] = xx[33];\n  xx[303] = xx[33];\n  xx[304] = xx[33];\n  xx[305] = xx[33];\n  xx[306] = xx[33];\n  xx[307] = xx[219];\n  pm_math_Quaternion_xform_ra(xx + 123, xx + 105, xx + 43);\n  xx[30] = state[0] + xx[11];\n  xx[31] = 6.938893903907228e-18;\n  xx[49] = xx[31] * xx[189];\n  xx[50] = xx[31] * xx[188];\n  xx[51] = xx[2] * (xx[60] - xx[59]);\n  xx[57] = state[1] - xx[51];\n  xx[59] = state[2] - xx[89] + xx[1];\n  xx[315] = - xx[189];\n  xx[316] = - xx[190];\n  xx[317] = xx[187];\n  xx[318] = xx[188];\n  xx[319] = xx[43] + xx[30] - xx[2] * (xx[49] * xx[187] + xx[50] * xx[190]);\n  xx[320] = xx[2] * (xx[50] * xx[187] - xx[49] * xx[190]) + xx[44] + xx[57];\n  xx[321] = xx[2] * (xx[50] * xx[188] + xx[49] * xx[189]) - xx[31] + xx[45] +\n    xx[59];\n  bb[1] = sm_core_compiler_computeProximityInfoBrickCylinder(\n    simulation_b048d748_1_geometry_3(NULL), simulation_b048d748_1_geometry_2\n    (NULL), (pm_math_Transform3 *)(xx + 301), (pm_math_Transform3 *)(xx + 315),\n    xx + 43, (pm_math_Vector3 *)(xx + 191), (pm_math_Vector3 *)(xx + 200),\n    (pm_math_Vector3 *)(xx + 206), (pm_math_Vector3 *)(xx + 216));\n  xx[322] = xx[33];\n  xx[323] = xx[33];\n  xx[324] = xx[1];\n  xx[325] = xx[33];\n  xx[326] = xx[33];\n  xx[327] = xx[33];\n  xx[328] = - xx[31];\n  xx[31] = xx[340] + xx[4];\n  xx[44] = xx[341] + state[16];\n  xx[286] = state[7];\n  xx[287] = state[8];\n  xx[288] = state[9];\n  pm_math_Quaternion_inverseXform_ra(xx + 123, xx + 286, xx + 329);\n  xx[45] = xx[329] + state[11];\n  xx[49] = xx[330] - state[10];\n  xx[286] = xx[6] + xx[45];\n  xx[287] = xx[7] + xx[49];\n  xx[288] = xx[8] + xx[331];\n  pm_math_Quaternion_inverseXform_ra(xx + 183, xx + 286, xx + 6);\n  xx[50] = xx[97] * state[16];\n  xx[352] = xx[31];\n  xx[353] = xx[44];\n  xx[354] = xx[25];\n  xx[355] = xx[6] - xx[50];\n  xx[356] = xx[7] + xx[9];\n  xx[357] = xx[8];\n  xx[6] = 1000.0;\n  xx[7] = 1.0e-4;\n  xx[8] = 0.3;\n  xx[60] = 0.2119573811760597;\n  xx[96] = 9.126024771145405e-4;\n  sm_core_compiler_computeSpatialContactWrenches(\n    0, 1, bb[1], xx + 43, (const pm_math_Vector3 *)(xx + 191), (const\n    pm_math_Vector3 *)(xx + 200), (const pm_math_Vector3 *)(xx + 206), (const\n    pm_math_Vector3 *)(xx + 216),\n    (const pm_math_Transform3 *)(xx + 301), (const pm_math_Transform3 *)(xx +\n    322), (const pm_math_Transform3 *)(xx + 301), (const pm_math_Transform3 *)\n    (xx + 315), NULL, (const pm_math_SpatialVector *)(xx + 352),\n    0, 1, 1.0e6, xx[6], xx[7], xx[8], xx[60], xx[96], NULL, NULL,\n    NULL, (pm_math_SpatialVector *)(xx + 359));\n  xx[43] = state[15] * state[16];\n  xx[100] = xx[10] * xx[43];\n  xx[10] = - xx[19];\n  xx[19] = sin(xx[10]);\n  xx[117] = xx[1] - xx[2] * xx[19] * xx[19];\n  xx[191] = xx[21] * (xx[46] - xx[9] * xx[28] - xx[97] * inputDdot[1]) - xx[362];\n  xx[192] = xx[21] * (xx[47] - xx[50] * xx[28] - xx[97] * xx[100] + xx[97] * xx\n                      [117] * inputDdot[0]) - xx[363];\n  xx[193] = xx[21] * (xx[48] + xx[9] * (xx[340] + xx[31]) + xx[50] * (xx[341] +\n    xx[44])) - (xx[364] + input[4]);\n  pm_math_Quaternion_xform_ra(xx + 183, xx + 191, xx + 46);\n  xx[315] = xx[62];\n  xx[316] = xx[65];\n  xx[317] = xx[67];\n  xx[318] = xx[86];\n  xx[319] = xx[30] - xx[11];\n  xx[320] = xx[51] + xx[57];\n  xx[321] = xx[89] - xx[1] + xx[59];\n  bb[1] = sm_core_compiler_computeProximityInfoCxpolyBrick(\n    simulation_b048d748_1_geometry_0(NULL), simulation_b048d748_1_geometry_3\n    (NULL), (pm_math_Transform3 *)(xx + 315), (pm_math_Transform3 *)(xx + 301),\n    xx + 9, (pm_math_Vector3 *)(xx + 191), (pm_math_Vector3 *)(xx + 200),\n    (pm_math_Vector3 *)(xx + 206), (pm_math_Vector3 *)(xx + 216));\n  xx[322] = state[10];\n  xx[323] = state[11];\n  xx[324] = state[12];\n  xx[325] = xx[45];\n  xx[326] = xx[49];\n  xx[327] = xx[331];\n  sm_core_compiler_computeSpatialContactWrenches(\n    0, 1, bb[1], xx + 9, (const pm_math_Vector3 *)(xx + 200), (const\n    pm_math_Vector3 *)(xx + 191), (const pm_math_Vector3 *)(xx + 216), (const\n    pm_math_Vector3 *)(xx + 206),\n    (const pm_math_Transform3 *)(xx + 301), (const pm_math_Transform3 *)(xx +\n    301), (const pm_math_Transform3 *)(xx + 301), (const pm_math_Transform3 *)\n    (xx + 315), NULL, (const pm_math_SpatialVector *)(xx + 322),\n    0, 1, 1300.0, xx[6], xx[7], 0.4, 0.3166621126427172, 9.173266606314467e-4,\n    NULL, NULL,\n    NULL, (pm_math_SpatialVector *)(xx + 352));\n  xx[191] = xx[45];\n  xx[192] = xx[49];\n  xx[193] = xx[331];\n  pm_math_Vector3_cross_ra(xx + 336, xx + 191, xx + 49);\n  xx[191] = - xx[329];\n  xx[192] = - xx[330];\n  xx[193] = - xx[331];\n  pm_math_Vector3_cross_ra(xx + 336, xx + 191, xx + 200);\n  xx[191] = xx[49] + xx[200];\n  xx[192] = xx[50] + xx[201];\n  xx[193] = xx[51] + xx[202];\n  pm_math_Matrix3x3_xform_ra(xx + 70, xx + 191, xx + 49);\n  xx[9] = xx[46] - xx[355] + xx[49];\n  xx[11] = xx[47] - xx[356] + xx[50];\n  xx[70] = xx[9];\n  xx[71] = xx[11];\n  xx[72] = xx[48] - xx[357] + xx[51];\n  xx[28] = pm_math_Vector3_dot_ra(xx + 12, xx + 70);\n  xx[30] = pm_math_Vector3_dot_ra(xx + 80, xx + 70);\n  xx[45] = pm_math_Vector3_dot_ra(xx + 90, xx + 70);\n  pm_math_Vector3_cross_ra(xx + 336, xx + 336, xx + 49);\n  xx[70] = xx[31];\n  xx[71] = xx[44];\n  xx[72] = xx[25];\n  xx[73] = xx[68] * xx[31];\n  xx[74] = xx[68] * xx[44];\n  xx[75] = xx[69] * xx[25];\n  pm_math_Vector3_cross_ra(xx + 70, xx + 73, xx + 76);\n  xx[70] = xx[4];\n  xx[71] = state[16];\n  xx[72] = xx[16];\n  pm_math_Vector3_cross_ra(xx + 340, xx + 70, xx + 73);\n  xx[70] = xx[76] - xx[359] + xx[68] * (xx[73] - xx[100] + xx[117] * inputDdot[0]);\n  xx[71] = xx[77] - xx[360] + xx[68] * (xx[74] + inputDdot[1]);\n  xx[72] = xx[78] - xx[361] + xx[69] * (xx[75] - xx[43] * (xx[3] - xx[1]) - xx[2]\n    * cos(xx[10]) * xx[19] * inputDdot[0]);\n  pm_math_Quaternion_xform_ra(xx + 183, xx + 70, xx + 73);\n  pm_math_Vector3_cross_ra(xx + 105, xx + 46, xx + 70);\n  xx[315] = - xx[108];\n  xx[316] = - xx[111];\n  xx[317] = - xx[114];\n  xx[318] = - xx[109];\n  xx[319] = - xx[112];\n  xx[320] = - xx[115];\n  xx[321] = xx[120];\n  xx[322] = xx[121];\n  xx[323] = xx[122];\n  pm_math_Matrix3x3_xform_ra(xx + 315, xx + 191, xx + 46);\n  xx[3] = xx[49] - xx[352] + xx[73] + xx[70] + xx[46];\n  xx[4] = xx[50] - xx[353] + xx[74] + xx[71] + xx[47] + xx[9];\n  xx[9] = xx[51] - xx[354] + xx[75] + xx[72] + xx[48];\n  xx[46] = - xx[28];\n  xx[47] = - xx[30];\n  xx[48] = - xx[45];\n  xx[49] = xx[11] - xx[3];\n  xx[50] = - xx[4];\n  xx[51] = - xx[9];\n  solveSymmetricPosDef(xx + 147, xx + 46, 6, 1, xx + 70, xx + 324);\n  pm_math_Matrix3x3_xform_ra(xx + 315, xx + 12, xx + 46);\n  pm_math_Matrix3x3_xform_ra(xx + 315, xx + 80, xx + 12);\n  pm_math_Matrix3x3_xform_ra(xx + 315, xx + 90, xx + 49);\n  xx[437] = xx[46];\n  xx[438] = xx[12];\n  xx[439] = xx[49];\n  xx[440] = xx[24];\n  xx[441] = xx[32];\n  xx[442] = xx[35];\n  xx[443] = xx[47];\n  xx[444] = xx[13];\n  xx[445] = xx[50];\n  xx[446] = xx[141] - xx[132] + xx[112];\n  xx[447] = xx[42];\n  xx[448] = xx[116];\n  xx[449] = xx[48];\n  xx[450] = xx[14];\n  xx[451] = xx[51];\n  xx[452] = xx[144] - xx[135] + xx[113];\n  xx[453] = xx[145] - xx[136] - xx[110];\n  xx[454] = xx[119];\n  xx[455] = xx[54];\n  xx[456] = xx[83];\n  xx[457] = xx[93];\n  xx[458] = xx[61];\n  xx[459] = xx[66];\n  xx[460] = xx[120];\n  xx[461] = xx[55];\n  xx[462] = xx[84];\n  xx[463] = xx[94];\n  xx[464] = xx[53];\n  xx[465] = xx[52];\n  xx[466] = xx[121];\n  xx[467] = xx[56];\n  xx[468] = xx[85];\n  xx[469] = xx[95];\n  xx[470] = xx[63];\n  xx[471] = xx[64];\n  xx[472] = xx[122];\n  solveSymmetricPosDef(xx + 147, xx + 437, 6, 6, xx + 473, xx + 46);\n  xx[12] = xx[494];\n  xx[13] = xx[500];\n  xx[14] = xx[506];\n  xx[10] = 9.806649999999999;\n  xx[16] = xx[10] * state[4];\n  xx[19] = xx[10] * state[5];\n  xx[42] = xx[2] * (xx[16] * state[6] - xx[19] * state[3]);\n  xx[43] = xx[2] * (xx[16] * state[3] + xx[19] * state[6]);\n  xx[44] = xx[10] - xx[2] * (xx[16] * state[4] + xx[19] * state[5]);\n  xx[16] = pm_math_Vector3_dot_ra(xx + 12, xx + 42);\n  xx[12] = xx[73] - xx[16];\n  xx[46] = xx[495];\n  xx[47] = xx[501];\n  xx[48] = xx[507];\n  xx[13] = pm_math_Vector3_dot_ra(xx + 46, xx + 42);\n  xx[14] = xx[74] - xx[13];\n  xx[46] = xx[496];\n  xx[47] = xx[502];\n  xx[48] = xx[508];\n  xx[19] = pm_math_Vector3_dot_ra(xx + 46, xx + 42);\n  xx[24] = xx[75] - xx[19];\n  xx[46] = state[27];\n  xx[47] = state[28];\n  xx[48] = state[29];\n  xx[25] = - state[20];\n  xx[49] = xx[25];\n  xx[50] = xx[79];\n  xx[51] = xx[87];\n  xx[52] = xx[104];\n  xx[53] = state[24];\n  xx[54] = state[25];\n  xx[55] = state[26];\n  pm_math_Quaternion_inverseXform_ra(xx + 49, xx + 53, xx + 61);\n  pm_math_Vector3_cross_ra(xx + 46, xx + 61, xx + 49);\n  xx[52] = - xx[61];\n  xx[53] = - xx[62];\n  xx[54] = - xx[63];\n  pm_math_Vector3_cross_ra(xx + 46, xx + 52, xx + 55);\n  xx[31] = 3.469446951953614e-18;\n  xx[32] = xx[31] * state[22];\n  xx[35] = xx[31] * state[21];\n  xx[80] = state[22];\n  xx[81] = state[23];\n  xx[82] = xx[25];\n  xx[83] = xx[79];\n  xx[84] = state[17] - xx[2] * (xx[32] * state[20] + xx[35] * state[23]);\n  xx[85] = xx[2] * (xx[35] * state[20] - xx[32] * state[23]) + state[18];\n  xx[86] = xx[2] * (xx[35] * state[21] + xx[32] * state[22]) - xx[31] + state[19];\n  bb[1] = sm_core_compiler_computeProximityInfoBrickCylinder(\n    simulation_b048d748_1_geometry_3(NULL), simulation_b048d748_1_geometry_1\n    (NULL), (pm_math_Transform3 *)(xx + 301), (pm_math_Transform3 *)(xx + 80),\n    xx + 25, (pm_math_Vector3 *)(xx + 52), (pm_math_Vector3 *)(xx + 64),\n    (pm_math_Vector3 *)(xx + 76), (pm_math_Vector3 *)(xx + 89));\n  xx[104] = xx[33];\n  xx[105] = xx[33];\n  xx[106] = xx[1];\n  xx[107] = xx[33];\n  xx[108] = xx[33];\n  xx[109] = xx[33];\n  xx[110] = - xx[31];\n  xx[111] = state[27];\n  xx[112] = state[28];\n  xx[113] = state[29];\n  xx[114] = xx[61];\n  xx[115] = xx[62];\n  xx[116] = xx[63];\n  sm_core_compiler_computeSpatialContactWrenches(\n    0, 1, bb[1], xx + 25, (const pm_math_Vector3 *)(xx + 52), (const\n    pm_math_Vector3 *)(xx + 64), (const pm_math_Vector3 *)(xx + 76), (const\n    pm_math_Vector3 *)(xx + 89),\n    (const pm_math_Transform3 *)(xx + 301), (const pm_math_Transform3 *)(xx +\n    104), (const pm_math_Transform3 *)(xx + 301), (const pm_math_Transform3 *)\n    (xx + 80), NULL, (const pm_math_SpatialVector *)(xx + 111),\n    0, 1, xx[6], 100.0, xx[7], xx[8], xx[60], xx[96], NULL, NULL,\n    NULL, (pm_math_SpatialVector *)(xx + 129));\n  xx[6] = xx[21] * (xx[49] + xx[55]) - xx[132];\n  xx[7] = xx[21] * (xx[50] + xx[56]) - xx[133];\n  xx[8] = xx[21] * (xx[51] + xx[57]) - (input[3] + xx[134]);\n  xx[49] = xx[248] * state[27];\n  xx[50] = xx[248] * state[28];\n  xx[51] = xx[69] * state[29];\n  pm_math_Vector3_cross_ra(xx + 46, xx + 49, xx + 52);\n  xx[46] = - pm_math_Vector3_dot_ra(xx + 210, xx + 6);\n  xx[47] = - pm_math_Vector3_dot_ra(xx + 241, xx + 6);\n  xx[48] = - pm_math_Vector3_dot_ra(xx + 245, xx + 6);\n  xx[49] = xx[129] - xx[52];\n  xx[50] = xx[130] - xx[53];\n  xx[51] = xx[131] - xx[54];\n  solveSymmetricPosDef(xx + 249, xx + 46, 6, 1, xx + 52, xx + 59);\n  xx[437] = xx[33];\n  xx[438] = xx[33];\n  xx[439] = xx[33];\n  xx[440] = xx[248];\n  xx[441] = xx[33];\n  xx[442] = xx[33];\n  xx[443] = xx[33];\n  xx[444] = xx[33];\n  xx[445] = xx[33];\n  xx[446] = xx[33];\n  xx[447] = xx[248];\n  xx[448] = xx[33];\n  xx[449] = xx[33];\n  xx[450] = xx[33];\n  xx[451] = xx[33];\n  xx[452] = xx[33];\n  xx[453] = xx[33];\n  xx[454] = xx[69];\n  xx[455] = xx[213];\n  xx[456] = xx[220];\n  xx[457] = xx[232];\n  xx[458] = xx[33];\n  xx[459] = xx[33];\n  xx[460] = xx[33];\n  xx[461] = xx[214];\n  xx[462] = xx[223];\n  xx[463] = xx[234];\n  xx[464] = xx[33];\n  xx[465] = xx[33];\n  xx[466] = xx[33];\n  xx[467] = xx[215];\n  xx[468] = xx[227];\n  xx[469] = xx[236];\n  xx[470] = xx[33];\n  xx[471] = xx[33];\n  xx[472] = xx[33];\n  solveSymmetricPosDef(xx + 249, xx + 437, 6, 6, xx + 509, xx + 46);\n  xx[6] = xx[531];\n  xx[7] = xx[537];\n  xx[8] = xx[543];\n  xx[21] = xx[10] * state[21];\n  xx[25] = xx[10] * state[22];\n  xx[46] = xx[2] * (xx[21] * state[23] - xx[25] * state[20]);\n  xx[47] = xx[2] * (xx[21] * state[20] + xx[25] * state[23]);\n  xx[48] = xx[10] - xx[2] * (xx[21] * state[21] + xx[25] * state[22]);\n  xx[10] = xx[56] - pm_math_Vector3_dot_ra(xx + 6, xx + 46);\n  xx[6] = xx[532];\n  xx[7] = xx[538];\n  xx[8] = xx[544];\n  xx[21] = xx[57] - pm_math_Vector3_dot_ra(xx + 6, xx + 46);\n  xx[6] = xx[1] - xx[2] * (xx[239] + xx[294]);\n  xx[7] = xx[2] * (xx[235] + xx[231]);\n  xx[8] = xx[196];\n  xx[49] = xx[530];\n  xx[50] = xx[536];\n  xx[51] = xx[542];\n  xx[25] = xx[55] - pm_math_Vector3_dot_ra(xx + 49, xx + 46);\n  xx[49] = - (xx[2] * (xx[128] + xx[37]));\n  xx[50] = xx[2] * (xx[285] - xx[244]);\n  xx[51] = xx[2] * (xx[38] + xx[239]) - xx[1];\n  xx[59] = xx[491];\n  xx[60] = xx[497];\n  xx[61] = xx[503];\n  xx[1] = pm_math_Vector3_dot_ra(xx + 59, xx + 42);\n  xx[31] = xx[97] * xx[40];\n  xx[32] = xx[31] * xx[27];\n  xx[35] = xx[97] * xx[29];\n  xx[29] = xx[35] * xx[27];\n  xx[37] = xx[31] * xx[17] + xx[35] * xx[26];\n  xx[59] = xx[32];\n  xx[60] = xx[29];\n  xx[61] = - xx[37];\n  pm_math_Vector3_cross_ra(xx + 312, xx + 59, xx + 62);\n  xx[59] = xx[2] * (xx[62] - xx[32] * xx[20]) - xx[35];\n  xx[60] = xx[2] * (xx[63] - xx[29] * xx[20]) + xx[31];\n  xx[61] = xx[2] * (xx[64] + xx[20] * xx[37]);\n  pm_math_Quaternion_xform_ra(xx + 123, xx + 59, xx + 62);\n  xx[26] = xx[97] * xx[27];\n  xx[59] = xx[2] * (xx[103] + xx[26] * xx[27]) - xx[97];\n  xx[60] = - (xx[2] * (xx[26] * xx[20] + xx[98] * xx[17]));\n  xx[61] = xx[2] * (xx[99] - xx[26] * xx[17]);\n  pm_math_Quaternion_xform_ra(xx + 123, xx + 59, xx + 65);\n  xx[17] = xx[228] * xx[189];\n  xx[20] = xx[228] * xx[190];\n  xx[59] = xx[527];\n  xx[60] = xx[533];\n  xx[61] = xx[539];\n  xx[76] = xx[492];\n  xx[77] = xx[498];\n  xx[78] = xx[504];\n  xx[26] = pm_math_Vector3_dot_ra(xx + 76, xx + 42);\n  xx[76] = xx[528];\n  xx[77] = xx[534];\n  xx[78] = xx[540];\n  xx[73] = xx[493];\n  xx[74] = xx[499];\n  xx[75] = xx[505];\n  xx[27] = pm_math_Vector3_dot_ra(xx + 73, xx + 42);\n  xx[42] = xx[529];\n  xx[43] = xx[535];\n  xx[44] = xx[541];\n  xx[79] = - (xx[367] + xx[12] * xx[204] + xx[14] * xx[18] + xx[24] * xx[194] +\n              inputDdot[0] * xx[204] + xx[10] * xx[290] + xx[21] * xx[222]);\n  xx[80] = - (xx[368] + xx[12] * xx[224] + xx[14] * xx[23] + xx[24] * xx[36] +\n              inputDdot[0] * xx[224] + inputDdot[1] * (bb[0] ? xx[33] :\n    pm_math_Vector3_dot_ra(xx + 6, xx + 295)) + xx[25] * xx[299] + xx[21] * xx\n              [209]);\n  xx[81] = - (xx[369] + xx[12] * xx[118] + xx[14] * xx[22] + xx[24] * xx[34] +\n              inputDdot[0] * xx[118] + inputDdot[1] * (bb[0] ? xx[33] :\n    pm_math_Vector3_dot_ra(xx + 49, xx + 309)) + xx[25] * xx[199] + xx[10] * xx\n              [205]);\n  xx[82] = - (xx[370] + (xx[70] - xx[1]) * xx[221] + xx[12] * xx[339] + xx[14] *\n              xx[351] + xx[24] * xx[233] + inputDdot[0] * (bb[0] ? xx[33] :\n    - (xx[300] + xx[62])) + inputDdot[1] * (bb[0] ? xx[33] : - (xx[65] + xx[2] *\n    (xx[17] * xx[189] + xx[20] * xx[190]) - xx[228])) + (xx[52] -\n    pm_math_Vector3_dot_ra(xx + 59, xx + 46)) * xx[39] + xx[25] * xx[345] + xx\n              [10] * xx[358]);\n  xx[83] = - (xx[371] + (xx[71] - xx[26]) * xx[221] + xx[12] * xx[292] + xx[14] *\n              xx[58] + xx[24] * xx[15] + inputDdot[0] * (bb[0] ? xx[33] : - (xx\n    [366] + xx[230] + xx[63])) + inputDdot[1] * (bb[0] ? xx[33] : - (xx[66] -\n    xx[2] * (xx[20] * xx[187] + xx[17] * xx[188]))) + (xx[53] -\n    pm_math_Vector3_dot_ra(xx + 76, xx + 46)) * xx[39] + xx[25] * xx[5] + xx[10]\n              * xx[41]);\n  xx[84] = - (xx[372] + (xx[72] - xx[27]) * xx[221] + xx[12] * xx[293] + xx[14] *\n              xx[88] + xx[24] * xx[101] + inputDdot[0] * (bb[0] ? xx[33] :\n    - (xx[225] + xx[64])) + inputDdot[1] * (bb[0] ? xx[33] : - (xx[2] * (xx[17] *\n    xx[187] - xx[20] * xx[188]) + xx[67])) + (xx[54] - pm_math_Vector3_dot_ra(xx\n    + 42, xx + 46)) * xx[39] + xx[25] * xx[102] + xx[10] * xx[238]);\n  memcpy(xx + 234, xx + 401, 36 * sizeof(double));\n  factorAndSolveSymmetric(xx + 234, 6, xx + 46, ii + 0, xx + 79, xx + 37, xx +\n    294);\n  xx[46] = xx[40] * xx[221] - xx[28];\n  xx[47] = xx[41] * xx[221] - xx[30];\n  xx[48] = xx[42] * xx[221] - xx[45];\n  xx[49] = xx[37] * xx[204] + xx[38] * xx[224] + xx[39] * xx[118] + xx[40] * xx\n    [339] + xx[41] * xx[292] + xx[42] * xx[293] - (xx[3] - xx[11]);\n  xx[50] = xx[37] * xx[18] + xx[38] * xx[23] + xx[39] * xx[22] + xx[40] * xx[351]\n    + xx[41] * xx[58] + xx[42] * xx[88] - xx[4];\n  xx[51] = xx[37] * xx[194] + xx[38] * xx[36] + xx[39] * xx[34] + xx[40] * xx\n    [233] + xx[41] * xx[15] + xx[42] * xx[101] - xx[9];\n  solveSymmetricPosDef(xx + 147, xx + 46, 6, 1, xx + 2, xx + 20);\n  logVector[0] = state[0];\n  logVector[1] = state[1];\n  logVector[2] = state[2];\n  logVector[3] = state[3];\n  logVector[4] = state[4];\n  logVector[5] = state[5];\n  logVector[6] = state[6];\n  logVector[7] = state[7];\n  logVector[8] = state[8];\n  logVector[9] = state[9];\n  logVector[10] = xx[0] * state[10];\n  logVector[11] = xx[0] * state[11];\n  logVector[12] = xx[0] * state[12];\n  logVector[13] = xx[0] * state[13];\n  logVector[14] = xx[0] * state[14];\n  logVector[15] = xx[0] * state[15];\n  logVector[16] = xx[0] * state[16];\n  logVector[17] = xx[2] - xx[1];\n  logVector[18] = xx[3] - xx[26];\n  logVector[19] = xx[4] - xx[27];\n  logVector[20] = xx[0] * (xx[5] - xx[16]);\n  logVector[21] = xx[0] * (xx[6] - xx[13]);\n  logVector[22] = xx[0] * (xx[7] - xx[19]);\n  logVector[23] = xx[0] * inputDdot[0];\n  logVector[24] = xx[0] * inputDdot[1];\n  errorResult[0] = xx[33];\n  return NULL;\n}\n"},{"name":"simulation_b048d748_1_mode_zero_crossings.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include <math.h>\n#include <string.h>\n#include \"pm_std.h\"\n#include \"sm_std.h\"\n#include \"ne_std.h\"\n#include \"ne_dae.h\"\n#include \"sm_ssci_run_time_errors.h\"\n#include \"sm_RuntimeDerivedValuesBundle.h\"\n#include \"simulation_b048d748_1_geometries.h\"\n\nconst NeZCData simulation_b048d748_1_ZCData[1] = {\n  { \"simulation/Plant/ TVC Physics/Staging Joint\", 0, 0,\n    \"Plant.TVC_Physics.Staging_Joint\", \"\", 2 }\n};\n\nPmfMessageId simulation_b048d748_1_computeAsmModeVector(const double *input,\n  const double *inputDot, const double *inputDdot, int *modeVector, double\n  *errorResult, NeuDiagnosticManager *neDiagMgr)\n{\n  boolean_T bb[1];\n  int ii[1];\n  double xx[1];\n  (void) inputDot;\n  (void) inputDdot;\n  (void) neDiagMgr;\n  bb[0] = input[2] == - 1.0;\n  ii[0] = bb[0] ? -1 : 0;\n  xx[0] = 0.0;\n  if (!(input[2] == xx[0] || bb[0])) {\n    return sm_ssci_recordRunTimeError(\n      \"physmod:sm:core:compiler:constraint:cutJoint:invalidModeInput\",\n      \"The mode signal input to 'simulation/Plant/ TVC Physics/Staging Joint' is invalid. It must be either 0 or -1.\",\n      neDiagMgr);\n  }\n\n  modeVector[0] = ii[0];\n  errorResult[0] = xx[0];\n  return NULL;\n}\n\nPmfMessageId simulation_b048d748_1_computeSimModeVector(const double *input,\n  const double *inputDot, const double *inputDdot, int *modeVector, double\n  *errorResult, NeuDiagnosticManager *neDiagMgr)\n{\n  boolean_T bb[1];\n  int ii[1];\n  double xx[1];\n  (void) inputDot;\n  (void) inputDdot;\n  (void) neDiagMgr;\n  bb[0] = input[2] == - 1.0;\n  ii[0] = bb[0] ? -1 : 0;\n  xx[0] = 0.0;\n  if (!(input[2] == xx[0] || bb[0])) {\n    return sm_ssci_recordRunTimeError(\n      \"physmod:sm:core:compiler:constraint:cutJoint:invalidModeInput\",\n      \"The mode signal input to 'simulation/Plant/ TVC Physics/Staging Joint' is invalid. It must be either 0 or -1.\",\n      neDiagMgr);\n  }\n\n  modeVector[0] = ii[0];\n  errorResult[0] = xx[0];\n  return NULL;\n}\n\nPmfMessageId simulation_b048d748_1_computeZeroCrossings(const\n  RuntimeDerivedValuesBundle *rtdv, const double *solverStateVector, const\n  double *input, const double *inputDot, const double *inputDdot, const double\n  *discreteStateVector, double *zeroCrossingsVector, double *errorResult,\n  NeuDiagnosticManager *neDiagMgr)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  boolean_T bb[1];\n  double xx[3];\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) solverStateVector;\n  (void) inputDot;\n  (void) inputDdot;\n  (void) discreteStateVector;\n  (void) neDiagMgr;\n  xx[0] = 1.0;\n  xx[1] = - xx[0];\n  bb[0] = input[2] == xx[1];\n  xx[2] = bb[0] ? xx[1] : xx[0];\n  xx[0] = 0.0;\n  if (!(input[2] == xx[0] || bb[0])) {\n    return sm_ssci_recordRunTimeError(\n      \"physmod:sm:core:compiler:constraint:cutJoint:invalidModeInput\",\n      \"The mode signal input to 'simulation/Plant/ TVC Physics/Staging Joint' is invalid. It must be either 0 or -1.\",\n      neDiagMgr);\n  }\n\n  zeroCrossingsVector[0] = xx[2];\n  errorResult[0] = xx[0];\n  return NULL;\n}\n"},{"name":"simulation_b048d748_1_setParameters.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include <math.h>\n#include <string.h>\n#include \"pm_std.h\"\n#include \"sm_std.h\"\n#include \"ne_std.h\"\n#include \"ne_dae.h\"\n#include \"sm_ssci_run_time_errors.h\"\n#include \"sm_RuntimeDerivedValuesBundle.h\"\n\nvoid simulation_b048d748_1_computeRuntimeParameters(real_T *in, real_T *out)\n{\n  (void) in;\n  (void) out;\n}\n\nvoid simulation_b048d748_1_computeAsmRuntimeDerivedValuesDoubles(const double\n  *rtp, double *rtdvd)\n{\n  (void) rtp;\n  (void) rtdvd;\n}\n\nvoid simulation_b048d748_1_computeAsmRuntimeDerivedValuesInts(const double *rtp,\n  int *rtdvi)\n{\n  (void) rtp;\n  (void) rtdvi;\n}\n\nvoid simulation_b048d748_1_computeAsmRuntimeDerivedValues(const double *rtp,\n  RuntimeDerivedValuesBundle *rtdv)\n{\n  simulation_b048d748_1_computeAsmRuntimeDerivedValuesDoubles(rtp,\n    rtdv->mDoubles.mValues);\n  simulation_b048d748_1_computeAsmRuntimeDerivedValuesInts(rtp,\n    rtdv->mInts.mValues);\n}\n\nvoid simulation_b048d748_1_computeSimRuntimeDerivedValuesDoubles(const double\n  *rtp, double *rtdvd)\n{\n  (void) rtp;\n  (void) rtdvd;\n}\n\nvoid simulation_b048d748_1_computeSimRuntimeDerivedValuesInts(const double *rtp,\n  int *rtdvi)\n{\n  (void) rtp;\n  (void) rtdvi;\n}\n\nvoid simulation_b048d748_1_computeSimRuntimeDerivedValues(const double *rtp,\n  RuntimeDerivedValuesBundle *rtdv)\n{\n  simulation_b048d748_1_computeSimRuntimeDerivedValuesDoubles(rtp,\n    rtdv->mDoubles.mValues);\n  simulation_b048d748_1_computeSimRuntimeDerivedValuesInts(rtp,\n    rtdv->mInts.mValues);\n}\n"},{"name":"simulation_b048d748_1_sim_delegate.c","type":"source","group":"legacy","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n */\n\n#include <math.h>\n#include <string.h>\n#include \"pm_std.h\"\n#include \"sm_std.h\"\n#include \"ne_std.h\"\n#include \"ne_dae.h\"\n#include \"sm_ssci_run_time_errors.h\"\n#include \"sm_RuntimeDerivedValuesBundle.h\"\n\nvoid simulation_b048d748_1_resetSimStateVector(const void *mech, double *state)\n{\n  double xx[2];\n  (void) mech;\n  xx[0] = 0.0;\n  xx[1] = 1.0;\n  state[0] = xx[0];\n  state[1] = xx[0];\n  state[2] = xx[0];\n  state[3] = xx[1];\n  state[4] = xx[0];\n  state[5] = xx[0];\n  state[6] = xx[0];\n  state[7] = xx[0];\n  state[8] = xx[0];\n  state[9] = xx[0];\n  state[10] = xx[0];\n  state[11] = xx[0];\n  state[12] = xx[0];\n  state[13] = xx[0];\n  state[14] = xx[0];\n  state[15] = xx[0];\n  state[16] = xx[0];\n  state[17] = xx[0];\n  state[18] = xx[0];\n  state[19] = xx[0];\n  state[20] = xx[1];\n  state[21] = xx[0];\n  state[22] = xx[0];\n  state[23] = xx[0];\n  state[24] = xx[0];\n  state[25] = xx[0];\n  state[26] = xx[0];\n  state[27] = xx[0];\n  state[28] = xx[0];\n  state[29] = xx[0];\n}\n\nstatic void perturbSimJointPrimitiveState_0_0(double mag, double *state)\n{\n  state[0] = state[0] + mag;\n}\n\nstatic void perturbSimJointPrimitiveState_0_0v(double mag, double *state)\n{\n  state[0] = state[0] + mag;\n  state[7] = state[7] - 0.875 * mag;\n}\n\nstatic void perturbSimJointPrimitiveState_0_1(double mag, double *state)\n{\n  state[1] = state[1] + mag;\n}\n\nstatic void perturbSimJointPrimitiveState_0_1v(double mag, double *state)\n{\n  state[1] = state[1] + mag;\n  state[8] = state[8] - 0.875 * mag;\n}\n\nstatic void perturbSimJointPrimitiveState_0_2(double mag, double *state)\n{\n  state[2] = state[2] + mag;\n}\n\nstatic void perturbSimJointPrimitiveState_0_2v(double mag, double *state)\n{\n  state[2] = state[2] + mag;\n  state[9] = state[9] - 0.875 * mag;\n}\n\nstatic void perturbSimJointPrimitiveState_0_3(double mag, double *state)\n{\n  double xx[15];\n  xx[0] = 1.0;\n  xx[1] = fabs(mag);\n  xx[2] = xx[0] / (xx[1] - floor(xx[1]) + 1.0e-9);\n  xx[1] = sin(xx[2]);\n  xx[3] = 0.0;\n  xx[4] = cos(xx[2]);\n  xx[5] = sin(2.0 * xx[2]);\n  xx[2] = 0.5 * mag;\n  xx[6] = sqrt(xx[1] * xx[1] + xx[4] * xx[4] + xx[5] * xx[5]);\n  xx[7] = xx[6] == 0.0 ? 0.0 : xx[1] / xx[6];\n  xx[8] = sin(xx[2]);\n  xx[9] = xx[6] == 0.0 ? 0.0 : xx[4] / xx[6];\n  xx[10] = xx[6] == 0.0 ? 0.0 : xx[5] / xx[6];\n  xx[11] = xx[1] == xx[3] && xx[4] == xx[3] && xx[5] == xx[3] ? xx[0] : cos(xx[2]);\n  xx[12] = xx[7] * xx[8];\n  xx[13] = xx[9] * xx[8];\n  xx[14] = xx[10] * xx[8];\n  xx[0] = state[3];\n  xx[1] = state[4];\n  xx[2] = state[5];\n  xx[3] = state[6];\n  pm_math_Quaternion_compose_ra(xx + 11, xx + 0, xx + 4);\n  state[3] = xx[4];\n  state[4] = xx[5];\n  state[5] = xx[6];\n  state[6] = xx[7];\n}\n\nstatic void perturbSimJointPrimitiveState_0_3v(double mag, double *state)\n{\n  double xx[15];\n  xx[0] = 1.0;\n  xx[1] = fabs(mag);\n  xx[2] = xx[0] / (xx[1] - floor(xx[1]) + 1.0e-9);\n  xx[1] = sin(xx[2]);\n  xx[3] = 0.0;\n  xx[4] = cos(xx[2]);\n  xx[5] = sin(2.0 * xx[2]);\n  xx[2] = 0.5 * mag;\n  xx[6] = sqrt(xx[1] * xx[1] + xx[4] * xx[4] + xx[5] * xx[5]);\n  xx[7] = xx[6] == 0.0 ? 0.0 : xx[1] / xx[6];\n  xx[8] = sin(xx[2]);\n  xx[9] = xx[6] == 0.0 ? 0.0 : xx[4] / xx[6];\n  xx[10] = xx[6] == 0.0 ? 0.0 : xx[5] / xx[6];\n  xx[11] = xx[1] == xx[3] && xx[4] == xx[3] && xx[5] == xx[3] ? xx[0] : cos(xx[2]);\n  xx[12] = xx[7] * xx[8];\n  xx[13] = xx[9] * xx[8];\n  xx[14] = xx[10] * xx[8];\n  xx[3] = state[3];\n  xx[4] = state[4];\n  xx[5] = state[5];\n  xx[6] = state[6];\n  pm_math_Quaternion_compose_ra(xx + 11, xx + 3, xx + 7);\n  state[3] = xx[7];\n  state[4] = xx[8];\n  state[5] = xx[9];\n  state[6] = xx[10];\n  state[10] = state[10] + 1.2 * mag;\n  state[11] = state[11] - xx[2];\n  state[12] = state[12] + 0.9 * mag;\n}\n\nstatic void perturbSimJointPrimitiveState_1_0(double mag, double *state)\n{\n  state[13] = state[13] + mag;\n}\n\nstatic void perturbSimJointPrimitiveState_1_0v(double mag, double *state)\n{\n  state[13] = state[13] + mag;\n  state[15] = state[15] - 0.875 * mag;\n}\n\nstatic void perturbSimJointPrimitiveState_1_1(double mag, double *state)\n{\n  state[14] = state[14] + mag;\n}\n\nstatic void perturbSimJointPrimitiveState_1_1v(double mag, double *state)\n{\n  state[14] = state[14] + mag;\n  state[16] = state[16] - 0.875 * mag;\n}\n\nstatic void perturbSimJointPrimitiveState_2_0(double mag, double *state)\n{\n  state[17] = state[17] + mag;\n}\n\nstatic void perturbSimJointPrimitiveState_2_0v(double mag, double *state)\n{\n  state[17] = state[17] + mag;\n  state[24] = state[24] - 0.875 * mag;\n}\n\nstatic void perturbSimJointPrimitiveState_2_1(double mag, double *state)\n{\n  state[18] = state[18] + mag;\n}\n\nstatic void perturbSimJointPrimitiveState_2_1v(double mag, double *state)\n{\n  state[18] = state[18] + mag;\n  state[25] = state[25] - 0.875 * mag;\n}\n\nstatic void perturbSimJointPrimitiveState_2_2(double mag, double *state)\n{\n  state[19] = state[19] + mag;\n}\n\nstatic void perturbSimJointPrimitiveState_2_2v(double mag, double *state)\n{\n  state[19] = state[19] + mag;\n  state[26] = state[26] - 0.875 * mag;\n}\n\nstatic void perturbSimJointPrimitiveState_2_3(double mag, double *state)\n{\n  double xx[15];\n  xx[0] = 1.0;\n  xx[1] = fabs(mag);\n  xx[2] = xx[0] / (xx[1] - floor(xx[1]) + 1.0e-9);\n  xx[1] = sin(xx[2]);\n  xx[3] = 0.0;\n  xx[4] = cos(xx[2]);\n  xx[5] = sin(2.0 * xx[2]);\n  xx[2] = 0.5 * mag;\n  xx[6] = sqrt(xx[1] * xx[1] + xx[4] * xx[4] + xx[5] * xx[5]);\n  xx[7] = xx[6] == 0.0 ? 0.0 : xx[1] / xx[6];\n  xx[8] = sin(xx[2]);\n  xx[9] = xx[6] == 0.0 ? 0.0 : xx[4] / xx[6];\n  xx[10] = xx[6] == 0.0 ? 0.0 : xx[5] / xx[6];\n  xx[11] = xx[1] == xx[3] && xx[4] == xx[3] && xx[5] == xx[3] ? xx[0] : cos(xx[2]);\n  xx[12] = xx[7] * xx[8];\n  xx[13] = xx[9] * xx[8];\n  xx[14] = xx[10] * xx[8];\n  xx[0] = state[20];\n  xx[1] = state[21];\n  xx[2] = state[22];\n  xx[3] = state[23];\n  pm_math_Quaternion_compose_ra(xx + 11, xx + 0, xx + 4);\n  state[20] = xx[4];\n  state[21] = xx[5];\n  state[22] = xx[6];\n  state[23] = xx[7];\n}\n\nstatic void perturbSimJointPrimitiveState_2_3v(double mag, double *state)\n{\n  double xx[15];\n  xx[0] = 1.0;\n  xx[1] = fabs(mag);\n  xx[2] = xx[0] / (xx[1] - floor(xx[1]) + 1.0e-9);\n  xx[1] = sin(xx[2]);\n  xx[3] = 0.0;\n  xx[4] = cos(xx[2]);\n  xx[5] = sin(2.0 * xx[2]);\n  xx[2] = 0.5 * mag;\n  xx[6] = sqrt(xx[1] * xx[1] + xx[4] * xx[4] + xx[5] * xx[5]);\n  xx[7] = xx[6] == 0.0 ? 0.0 : xx[1] / xx[6];\n  xx[8] = sin(xx[2]);\n  xx[9] = xx[6] == 0.0 ? 0.0 : xx[4] / xx[6];\n  xx[10] = xx[6] == 0.0 ? 0.0 : xx[5] / xx[6];\n  xx[11] = xx[1] == xx[3] && xx[4] == xx[3] && xx[5] == xx[3] ? xx[0] : cos(xx[2]);\n  xx[12] = xx[7] * xx[8];\n  xx[13] = xx[9] * xx[8];\n  xx[14] = xx[10] * xx[8];\n  xx[3] = state[20];\n  xx[4] = state[21];\n  xx[5] = state[22];\n  xx[6] = state[23];\n  pm_math_Quaternion_compose_ra(xx + 11, xx + 3, xx + 7);\n  state[20] = xx[7];\n  state[21] = xx[8];\n  state[22] = xx[9];\n  state[23] = xx[10];\n  state[27] = state[27] + 1.2 * mag;\n  state[28] = state[28] - xx[2];\n  state[29] = state[29] + 0.9 * mag;\n}\n\nvoid simulation_b048d748_1_perturbSimJointPrimitiveState(const void *mech,\n  size_t stageIdx, size_t primIdx, double mag, boolean_T doPerturbVelocity,\n  double *state)\n{\n  (void) mech;\n  (void) stageIdx;\n  (void) primIdx;\n  (void) mag;\n  (void) doPerturbVelocity;\n  (void) state;\n  switch ((stageIdx * 6 + primIdx) * 2 + (doPerturbVelocity ? 1 : 0))\n  {\n   case 0:\n    perturbSimJointPrimitiveState_0_0(mag, state);\n    break;\n\n   case 1:\n    perturbSimJointPrimitiveState_0_0v(mag, state);\n    break;\n\n   case 2:\n    perturbSimJointPrimitiveState_0_1(mag, state);\n    break;\n\n   case 3:\n    perturbSimJointPrimitiveState_0_1v(mag, state);\n    break;\n\n   case 4:\n    perturbSimJointPrimitiveState_0_2(mag, state);\n    break;\n\n   case 5:\n    perturbSimJointPrimitiveState_0_2v(mag, state);\n    break;\n\n   case 6:\n    perturbSimJointPrimitiveState_0_3(mag, state);\n    break;\n\n   case 7:\n    perturbSimJointPrimitiveState_0_3v(mag, state);\n    break;\n\n   case 12:\n    perturbSimJointPrimitiveState_1_0(mag, state);\n    break;\n\n   case 13:\n    perturbSimJointPrimitiveState_1_0v(mag, state);\n    break;\n\n   case 14:\n    perturbSimJointPrimitiveState_1_1(mag, state);\n    break;\n\n   case 15:\n    perturbSimJointPrimitiveState_1_1v(mag, state);\n    break;\n\n   case 24:\n    perturbSimJointPrimitiveState_2_0(mag, state);\n    break;\n\n   case 25:\n    perturbSimJointPrimitiveState_2_0v(mag, state);\n    break;\n\n   case 26:\n    perturbSimJointPrimitiveState_2_1(mag, state);\n    break;\n\n   case 27:\n    perturbSimJointPrimitiveState_2_1v(mag, state);\n    break;\n\n   case 28:\n    perturbSimJointPrimitiveState_2_2(mag, state);\n    break;\n\n   case 29:\n    perturbSimJointPrimitiveState_2_2v(mag, state);\n    break;\n\n   case 30:\n    perturbSimJointPrimitiveState_2_3(mag, state);\n    break;\n\n   case 31:\n    perturbSimJointPrimitiveState_2_3v(mag, state);\n    break;\n  }\n}\n\nvoid simulation_b048d748_1_perturbFlexibleBodyState(const void *mech, size_t\n  stageIdx, double mag, boolean_T doPerturbVelocity, double *state)\n{\n  (void) mech;\n  (void) stageIdx;\n  (void) mag;\n  (void) doPerturbVelocity;\n  (void) state;\n  switch (stageIdx * 2 + (doPerturbVelocity ? 1 : 0))\n  {\n  }\n}\n\nvoid simulation_b048d748_1_constructStateVector(const void *mech, const double\n  *solverState, const double *u, const double *uDot, double *discreteState,\n  double *fullState)\n{\n  (void) mech;\n  (void) discreteState;\n  fullState[0] = solverState[0];\n  fullState[1] = solverState[1];\n  fullState[2] = solverState[2];\n  fullState[3] = solverState[3];\n  fullState[4] = solverState[4];\n  fullState[5] = solverState[5];\n  fullState[6] = solverState[6];\n  fullState[7] = solverState[7];\n  fullState[8] = solverState[8];\n  fullState[9] = solverState[9];\n  fullState[10] = solverState[10];\n  fullState[11] = solverState[11];\n  fullState[12] = solverState[12];\n  fullState[13] = u[0];\n  fullState[14] = u[1];\n  fullState[15] = uDot[0];\n  fullState[16] = uDot[1];\n  fullState[17] = solverState[13];\n  fullState[18] = solverState[14];\n  fullState[19] = solverState[15];\n  fullState[20] = solverState[16];\n  fullState[21] = solverState[17];\n  fullState[22] = solverState[18];\n  fullState[23] = solverState[19];\n  fullState[24] = solverState[20];\n  fullState[25] = solverState[21];\n  fullState[26] = solverState[22];\n  fullState[27] = solverState[23];\n  fullState[28] = solverState[24];\n  fullState[29] = solverState[25];\n}\n\nvoid simulation_b048d748_1_extractSolverStateVector(const void *mech, const\n  double *fullState, double *solverState)\n{\n  (void) mech;\n  solverState[0] = fullState[0];\n  solverState[1] = fullState[1];\n  solverState[2] = fullState[2];\n  solverState[3] = fullState[3];\n  solverState[4] = fullState[4];\n  solverState[5] = fullState[5];\n  solverState[6] = fullState[6];\n  solverState[7] = fullState[7];\n  solverState[8] = fullState[8];\n  solverState[9] = fullState[9];\n  solverState[10] = fullState[10];\n  solverState[11] = fullState[11];\n  solverState[12] = fullState[12];\n  solverState[13] = fullState[17];\n  solverState[14] = fullState[18];\n  solverState[15] = fullState[19];\n  solverState[16] = fullState[20];\n  solverState[17] = fullState[21];\n  solverState[18] = fullState[22];\n  solverState[19] = fullState[23];\n  solverState[20] = fullState[24];\n  solverState[21] = fullState[25];\n  solverState[22] = fullState[26];\n  solverState[23] = fullState[27];\n  solverState[24] = fullState[28];\n  solverState[25] = fullState[29];\n}\n\nboolean_T simulation_b048d748_1_isPositionViolation(const void *mech, const\n  RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags, const double\n  *state, const int *modeVector)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  int ii[1];\n  double xx[44];\n  (void) mech;\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) eqnEnableFlags;\n  ii[0] = modeVector[0] == -1 ? 0 : 1;\n  xx[0] = 2.0;\n  xx[1] = state[20] * state[20];\n  xx[2] = 1.0;\n  xx[3] = state[21] * state[22];\n  xx[4] = state[20] * state[23];\n  xx[5] = state[21] * state[23];\n  xx[6] = state[20] * state[22];\n  xx[7] = xx[0] * (xx[1] + state[21] * state[21]) - xx[2];\n  xx[8] = xx[0] * (xx[3] + xx[4]);\n  xx[9] = xx[0] * (xx[5] - xx[6]);\n  xx[10] = - state[3];\n  xx[11] = - state[4];\n  xx[12] = - state[5];\n  xx[13] = - state[6];\n  xx[14] = 0.5;\n  xx[15] = xx[14] * state[13];\n  xx[16] = cos(xx[15]);\n  xx[17] = xx[14] * state[14];\n  xx[14] = cos(xx[17]);\n  xx[18] = xx[16] * xx[14];\n  xx[19] = sin(xx[15]);\n  xx[15] = xx[14] * xx[19];\n  xx[14] = sin(xx[17]);\n  xx[17] = xx[16] * xx[14];\n  xx[16] = xx[19] * xx[14];\n  xx[19] = - xx[18];\n  xx[20] = - xx[15];\n  xx[21] = - xx[17];\n  xx[22] = - xx[16];\n  pm_math_Quaternion_compose_ra(xx + 10, xx + 19, xx + 23);\n  xx[14] = xx[24] * xx[25];\n  xx[19] = xx[23] * xx[26];\n  xx[20] = xx[23] * xx[23];\n  xx[21] = xx[25] * xx[26];\n  xx[22] = xx[23] * xx[24];\n  xx[27] = xx[0] * (xx[14] - xx[19]);\n  xx[28] = xx[0] * (xx[20] + xx[25] * xx[25]) - xx[2];\n  xx[29] = xx[0] * (xx[21] + xx[22]);\n  xx[30] = state[22] * state[23];\n  xx[31] = state[20] * state[21];\n  xx[32] = xx[0] * (xx[3] - xx[4]);\n  xx[33] = xx[0] * (xx[1] + state[22] * state[22]) - xx[2];\n  xx[34] = xx[0] * (xx[30] + xx[31]);\n  xx[3] = xx[24] * xx[26];\n  xx[4] = xx[23] * xx[25];\n  xx[35] = xx[0] * (xx[3] + xx[4]);\n  xx[36] = xx[0] * (xx[21] - xx[22]);\n  xx[37] = xx[0] * (xx[20] + xx[26] * xx[26]) - xx[2];\n  xx[38] = xx[0] * (xx[5] + xx[6]);\n  xx[39] = xx[0] * (xx[30] - xx[31]);\n  xx[40] = xx[0] * (xx[1] + state[23] * state[23]) - xx[2];\n  xx[41] = xx[0] * (xx[20] + xx[24] * xx[24]) - xx[2];\n  xx[42] = xx[0] * (xx[14] + xx[19]);\n  xx[43] = xx[0] * (xx[3] - xx[4]);\n  xx[1] = 0.0225;\n  xx[2] = xx[1] * state[22];\n  xx[3] = xx[1] * state[21];\n  xx[1] = 0.04499999999999999;\n  xx[4] = xx[1] * xx[17];\n  xx[5] = xx[1] * xx[15];\n  xx[19] = - (xx[0] * (xx[4] * xx[18] + xx[5] * xx[16]));\n  xx[20] = xx[0] * (xx[5] * xx[18] - xx[4] * xx[16]);\n  xx[21] = xx[0] * (xx[5] * xx[15] + xx[4] * xx[17]) - 1.045;\n  pm_math_Quaternion_xform_ra(xx + 10, xx + 19, xx + 4);\n  xx[1] = 0.04500000000000001;\n  xx[10] = xx[1] * xx[25];\n  xx[11] = xx[1] * xx[24];\n  xx[12] = pm_math_Vector3_dot_ra(xx + 7, xx + 27);\n  xx[13] = pm_math_Vector3_dot_ra(xx + 32, xx + 35);\n  xx[14] = pm_math_Vector3_dot_ra(xx + 38, xx + 41);\n  xx[15] = xx[0] * (xx[2] * state[20] + xx[3] * state[23]) + state[17] - (xx[4]\n    + state[0] + xx[0] * (state[3] * state[5] + state[4] * state[6]) - xx[0] *\n    (xx[10] * xx[23] + xx[11] * xx[26]));\n  xx[16] = xx[0] * (xx[2] * state[23] - xx[3] * state[20]) + state[18] - (xx[0] *\n    (xx[11] * xx[23] - xx[10] * xx[26]) + xx[5] + state[1] - xx[0] * (state[3] *\n    state[4] - state[5] * state[6]));\n  xx[17] = state[19] - xx[0] * (xx[3] * state[21] + xx[2] * state[22]) - (xx[6]\n    + state[2] - xx[0] * (state[4] * state[4] + state[5] * state[5]) + xx[0] *\n    (xx[11] * xx[24] + xx[10] * xx[25])) - 0.9325;\n  zeroMajor(1, 6, ii + 0, xx + 12);\n  xx[0] = fabs(xx[12]);\n  xx[1] = fabs(xx[13]);\n  xx[2] = fabs(xx[14]);\n  xx[3] = fabs(xx[15]);\n  xx[4] = fabs(xx[16]);\n  xx[5] = fabs(xx[17]);\n  ii[0] = 0;\n\n  {\n    int ll;\n    for (ll = 1; ll < 6; ++ll)\n      if (xx[ll] > xx[ii[0]])\n        ii[0] = ll;\n  }\n\n  ii[0] -= 0;\n  xx[6] = xx[0 + (ii[0])];\n  return xx[6] > 1.0e-9;\n}\n\nboolean_T simulation_b048d748_1_isVelocityViolation(const void *mech, const\n  RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags, const double\n  *state, const int *modeVector)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  int ii[1];\n  double xx[91];\n  (void) mech;\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) eqnEnableFlags;\n  ii[0] = modeVector[0] == -1 ? 0 : 1;\n  xx[0] = 2.0;\n  xx[1] = - state[21];\n  xx[2] = - state[22];\n  xx[3] = - state[23];\n  xx[4] = state[22] * state[28];\n  xx[5] = state[23] * state[29];\n  xx[6] = xx[4] + xx[5];\n  xx[7] = state[21] * state[28];\n  xx[8] = state[21] * state[29];\n  xx[9] = xx[6];\n  xx[10] = - xx[7];\n  xx[11] = - xx[8];\n  pm_math_Vector3_cross_ra(xx + 1, xx + 9, xx + 12);\n  xx[9] = xx[0] * (xx[12] - state[20] * xx[6]);\n  xx[10] = state[29] + xx[0] * (xx[7] * state[20] + xx[13]);\n  xx[11] = xx[0] * (xx[8] * state[20] + xx[14]) - state[28];\n  xx[6] = - state[4];\n  xx[7] = - state[5];\n  xx[8] = - state[6];\n  xx[12] = - state[3];\n  xx[13] = xx[6];\n  xx[14] = xx[7];\n  xx[15] = xx[8];\n  xx[16] = 0.5;\n  xx[17] = xx[16] * state[13];\n  xx[18] = cos(xx[17]);\n  xx[19] = xx[16] * state[14];\n  xx[16] = cos(xx[19]);\n  xx[20] = xx[18] * xx[16];\n  xx[21] = sin(xx[17]);\n  xx[17] = xx[16] * xx[21];\n  xx[16] = - xx[17];\n  xx[22] = sin(xx[19]);\n  xx[19] = xx[18] * xx[22];\n  xx[18] = - xx[19];\n  xx[23] = xx[21] * xx[22];\n  xx[21] = - xx[23];\n  xx[24] = - xx[20];\n  xx[25] = xx[16];\n  xx[26] = xx[18];\n  xx[27] = xx[21];\n  pm_math_Quaternion_compose_ra(xx + 12, xx + 24, xx + 28);\n  xx[22] = xx[29] * xx[30];\n  xx[32] = xx[28] * xx[31];\n  xx[33] = xx[28] * xx[28];\n  xx[34] = 1.0;\n  xx[35] = xx[30] * xx[31];\n  xx[36] = xx[28] * xx[29];\n  xx[37] = xx[0] * (xx[22] - xx[32]);\n  xx[38] = xx[0] * (xx[33] + xx[30] * xx[30]) - xx[34];\n  xx[39] = xx[0] * (xx[35] + xx[36]);\n  xx[40] = state[10];\n  xx[41] = state[11];\n  xx[42] = state[12];\n  pm_math_Quaternion_inverseXform_ra(xx + 24, xx + 40, xx + 43);\n  xx[24] = (xx[34] - xx[0] * (xx[19] * xx[19] + xx[23] * xx[23])) * state[15];\n  xx[25] = xx[43] + xx[24];\n  xx[26] = xx[25] * xx[30];\n  xx[27] = xx[45] + xx[0] * state[15] * (xx[20] * xx[19] + xx[17] * xx[23]);\n  xx[46] = xx[27] * xx[31];\n  xx[47] = xx[25] * xx[29];\n  xx[48] = xx[46] + xx[47];\n  xx[49] = xx[27] * xx[30];\n  xx[50] = xx[26];\n  xx[51] = - xx[48];\n  xx[52] = xx[49];\n  pm_math_Vector3_cross_ra(xx + 29, xx + 50, xx + 53);\n  xx[50] = xx[0] * (xx[26] * xx[28] + xx[53]) - xx[27];\n  xx[51] = xx[0] * (xx[54] - xx[48] * xx[28]);\n  xx[52] = xx[25] + xx[0] * (xx[49] * xx[28] + xx[55]);\n  xx[26] = state[20] * state[20];\n  xx[48] = state[21] * state[22];\n  xx[49] = state[20] * state[23];\n  xx[53] = state[21] * state[23];\n  xx[54] = state[20] * state[22];\n  xx[55] = xx[0] * (xx[26] + state[21] * state[21]) - xx[34];\n  xx[56] = xx[0] * (xx[48] + xx[49]);\n  xx[57] = xx[0] * (xx[53] - xx[54]);\n  xx[58] = state[22] * state[27];\n  xx[59] = state[21] * state[27];\n  xx[60] = xx[5] + xx[59];\n  xx[5] = state[22] * state[29];\n  xx[61] = - xx[58];\n  xx[62] = xx[60];\n  xx[63] = - xx[5];\n  pm_math_Vector3_cross_ra(xx + 1, xx + 61, xx + 64);\n  xx[61] = xx[0] * (xx[58] * state[20] + xx[64]) - state[29];\n  xx[62] = xx[0] * (xx[65] - state[20] * xx[60]);\n  xx[63] = state[27] + xx[0] * (xx[5] * state[20] + xx[66]);\n  xx[5] = xx[29] * xx[31];\n  xx[58] = xx[28] * xx[30];\n  xx[64] = xx[0] * (xx[5] + xx[58]);\n  xx[65] = xx[0] * (xx[35] - xx[36]);\n  xx[66] = xx[0] * (xx[33] + xx[31] * xx[31]) - xx[34];\n  xx[35] = xx[0] * (xx[19] * xx[17] - xx[20] * xx[23]) * state[15] + state[16];\n  xx[36] = xx[44] + xx[35];\n  xx[43] = xx[25] * xx[31];\n  xx[44] = xx[36] * xx[31];\n  xx[45] = xx[36] * xx[30];\n  xx[60] = xx[47] + xx[45];\n  xx[67] = xx[43];\n  xx[68] = xx[44];\n  xx[69] = - xx[60];\n  pm_math_Vector3_cross_ra(xx + 29, xx + 67, xx + 70);\n  xx[67] = xx[36] + xx[0] * (xx[43] * xx[28] + xx[70]);\n  xx[68] = xx[0] * (xx[44] * xx[28] + xx[71]) - xx[25];\n  xx[69] = xx[0] * (xx[72] - xx[60] * xx[28]);\n  xx[43] = state[22] * state[23];\n  xx[44] = state[20] * state[21];\n  xx[70] = xx[0] * (xx[48] - xx[49]);\n  xx[71] = xx[0] * (xx[26] + state[22] * state[22]) - xx[34];\n  xx[72] = xx[0] * (xx[43] + xx[44]);\n  xx[47] = state[23] * state[27];\n  xx[48] = state[23] * state[28];\n  xx[49] = xx[59] + xx[4];\n  xx[73] = - xx[47];\n  xx[74] = - xx[48];\n  xx[75] = xx[49];\n  pm_math_Vector3_cross_ra(xx + 1, xx + 73, xx + 76);\n  xx[73] = state[28] + xx[0] * (xx[47] * state[20] + xx[76]);\n  xx[74] = xx[0] * (xx[48] * state[20] + xx[77]) - state[27];\n  xx[75] = xx[0] * (xx[78] - state[20] * xx[49]);\n  xx[47] = xx[0] * (xx[33] + xx[29] * xx[29]) - xx[34];\n  xx[48] = xx[0] * (xx[22] + xx[32]);\n  xx[49] = xx[0] * (xx[5] - xx[58]);\n  xx[4] = xx[45] + xx[46];\n  xx[5] = xx[36] * xx[29];\n  xx[22] = xx[27] * xx[29];\n  xx[58] = - xx[4];\n  xx[59] = xx[5];\n  xx[60] = xx[22];\n  pm_math_Vector3_cross_ra(xx + 29, xx + 58, xx + 76);\n  xx[58] = xx[0] * (xx[76] - xx[4] * xx[28]);\n  xx[59] = xx[27] + xx[0] * (xx[5] * xx[28] + xx[77]);\n  xx[60] = xx[0] * (xx[22] * xx[28] + xx[78]) - xx[36];\n  xx[76] = xx[0] * (xx[53] + xx[54]);\n  xx[77] = xx[0] * (xx[43] - xx[44]);\n  xx[78] = xx[0] * (xx[26] + state[23] * state[23]) - xx[34];\n  xx[4] = 0.0225;\n  xx[5] = xx[4] * state[28];\n  xx[22] = xx[4] * state[27];\n  xx[4] = xx[22] * state[23];\n  xx[26] = xx[5] * state[23];\n  xx[27] = xx[22] * state[21] + xx[5] * state[22];\n  xx[32] = - xx[4];\n  xx[33] = - xx[26];\n  xx[34] = xx[27];\n  pm_math_Vector3_cross_ra(xx + 1, xx + 32, xx + 43);\n  xx[1] = 0.04500000000000001;\n  xx[2] = xx[1] * xx[25];\n  xx[3] = xx[2] * xx[31];\n  xx[25] = xx[1] * xx[36];\n  xx[1] = xx[25] * xx[31];\n  xx[32] = xx[2] * xx[29] + xx[25] * xx[30];\n  xx[79] = - xx[3];\n  xx[80] = - xx[1];\n  xx[81] = xx[32];\n  pm_math_Vector3_cross_ra(xx + 29, xx + 79, xx + 82);\n  xx[29] = state[6] * state[10];\n  xx[30] = state[6] * state[11];\n  xx[31] = state[4] * state[10] + state[5] * state[11];\n  xx[79] = - xx[29];\n  xx[80] = - xx[30];\n  xx[81] = xx[31];\n  pm_math_Vector3_cross_ra(xx + 6, xx + 79, xx + 85);\n  xx[6] = xx[16];\n  xx[7] = xx[18];\n  xx[8] = xx[21];\n  xx[16] = 0.04499999999999999;\n  xx[18] = xx[16] * xx[24];\n  xx[21] = xx[18] * xx[23];\n  xx[24] = xx[16] * xx[35];\n  xx[33] = xx[24] * xx[23];\n  xx[34] = xx[18] * xx[17] + xx[24] * xx[19];\n  xx[79] = xx[21];\n  xx[80] = xx[33];\n  xx[81] = - xx[34];\n  pm_math_Vector3_cross_ra(xx + 6, xx + 79, xx + 88);\n  xx[6] = xx[16] * xx[19];\n  xx[7] = xx[16] * xx[17];\n  xx[79] = - (xx[0] * (xx[6] * xx[20] + xx[7] * xx[23]));\n  xx[80] = xx[0] * (xx[7] * xx[20] - xx[6] * xx[23]);\n  xx[81] = xx[0] * (xx[7] * xx[17] + xx[6] * xx[19]) - 1.045;\n  pm_math_Vector3_cross_ra(xx + 40, xx + 79, xx + 6);\n  xx[40] = xx[0] * (xx[88] - xx[21] * xx[20]) - xx[24] + xx[6];\n  xx[41] = xx[0] * (xx[89] - xx[33] * xx[20]) + xx[18] + xx[7];\n  xx[42] = xx[0] * (xx[90] + xx[20] * xx[34]) + xx[8];\n  pm_math_Quaternion_xform_ra(xx + 12, xx + 40, xx + 6);\n  xx[12] = pm_math_Vector3_dot_ra(xx + 9, xx + 37) + pm_math_Vector3_dot_ra(xx +\n    50, xx + 55);\n  xx[13] = pm_math_Vector3_dot_ra(xx + 61, xx + 64) + pm_math_Vector3_dot_ra(xx\n    + 67, xx + 70);\n  xx[14] = pm_math_Vector3_dot_ra(xx + 73, xx + 47) + pm_math_Vector3_dot_ra(xx\n    + 58, xx + 76);\n  xx[15] = xx[5] + xx[0] * (xx[4] * state[20] + xx[43]) + state[24] - (xx[0] *\n    (xx[82] - xx[3] * xx[28]) - xx[25] + state[11] + xx[0] * (xx[29] * state[3]\n    + xx[85]) + state[7] + xx[6]);\n  xx[16] = xx[0] * (xx[26] * state[20] + xx[44]) - xx[22] + state[25] - (xx[0] *\n    (xx[83] - xx[1] * xx[28]) + xx[2] + xx[0] * (xx[30] * state[3] + xx[86]) -\n    state[10] + state[8] + xx[7]);\n  xx[17] = xx[0] * (xx[45] - state[20] * xx[27]) + state[26] - (xx[0] * (xx[84]\n    + xx[32] * xx[28]) + xx[0] * (xx[87] - state[3] * xx[31]) + state[9] + xx[8]);\n  zeroMajor(1, 6, ii + 0, xx + 12);\n  xx[0] = fabs(xx[12]);\n  xx[1] = fabs(xx[13]);\n  xx[2] = fabs(xx[14]);\n  xx[3] = fabs(xx[15]);\n  xx[4] = fabs(xx[16]);\n  xx[5] = fabs(xx[17]);\n  ii[0] = 0;\n\n  {\n    int ll;\n    for (ll = 1; ll < 6; ++ll)\n      if (xx[ll] > xx[ii[0]])\n        ii[0] = ll;\n  }\n\n  ii[0] -= 0;\n  xx[6] = xx[0 + (ii[0])];\n  return xx[6] > 1.0e-9;\n}\n\nPmfMessageId simulation_b048d748_1_projectStateSim(const void *mech, const\n  RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags, const int\n  *modeVector, double *state, void *neDiagMgr0)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  NeuDiagnosticManager *neDiagMgr = (NeuDiagnosticManager *) neDiagMgr0;\n  boolean_T bb[1];\n  int ii[7];\n  double xx[328];\n  (void) mech;\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) eqnEnableFlags;\n  (void) neDiagMgr;\n  xx[0] = 0.0;\n  bb[0] = modeVector[0] == -1;\n  xx[1] = 2.0;\n  xx[2] = 1.0;\n  xx[3] = 0.5;\n  xx[4] = xx[3] * state[13];\n  xx[5] = cos(xx[4]);\n  xx[6] = xx[3] * state[14];\n  xx[7] = sin(xx[6]);\n  xx[8] = xx[5] * xx[7];\n  xx[9] = xx[8] * xx[8];\n  xx[10] = sin(xx[4]);\n  xx[4] = xx[10] * xx[7];\n  xx[7] = xx[4] * xx[4];\n  xx[11] = xx[2] - xx[1] * (xx[9] + xx[7]);\n  xx[12] = sqrt(state[3] * state[3] + state[4] * state[4] + state[5] * state[5]\n                + state[6] * state[6]);\n  xx[13] = state[3] / xx[12];\n  xx[14] = state[4] / xx[12];\n  xx[15] = - xx[14];\n  xx[16] = state[5] / xx[12];\n  xx[17] = - xx[16];\n  xx[18] = state[6] / xx[12];\n  xx[12] = - xx[18];\n  xx[19] = - xx[13];\n  xx[20] = xx[15];\n  xx[21] = xx[17];\n  xx[22] = xx[12];\n  xx[23] = cos(xx[6]);\n  xx[6] = xx[5] * xx[23];\n  xx[5] = xx[23] * xx[10];\n  xx[23] = - xx[6];\n  xx[24] = - xx[5];\n  xx[25] = - xx[8];\n  xx[26] = - xx[4];\n  pm_math_Quaternion_compose_ra(xx + 19, xx + 23, xx + 27);\n  xx[10] = xx[11] * xx[29];\n  xx[31] = xx[6] * xx[8];\n  xx[32] = xx[5] * xx[4];\n  xx[33] = xx[1] * (xx[31] + xx[32]);\n  xx[34] = xx[33] * xx[30];\n  xx[35] = xx[11] * xx[28];\n  xx[36] = xx[34] + xx[35];\n  xx[37] = xx[33] * xx[29];\n  xx[38] = xx[10];\n  xx[39] = - xx[36];\n  xx[40] = xx[37];\n  pm_math_Vector3_cross_ra(xx + 28, xx + 38, xx + 41);\n  xx[38] = xx[1] * (xx[10] * xx[27] + xx[41]) - xx[33];\n  xx[39] = xx[1] * (xx[42] - xx[36] * xx[27]);\n  xx[40] = xx[11] + xx[1] * (xx[37] * xx[27] + xx[43]);\n  xx[10] = sqrt(state[20] * state[20] + state[21] * state[21] + state[22] *\n                state[22] + state[23] * state[23]);\n  xx[36] = state[20] / xx[10];\n  xx[37] = xx[36] * xx[36];\n  xx[41] = state[21] / xx[10];\n  xx[42] = xx[41] * xx[41];\n  xx[43] = state[22] / xx[10];\n  xx[44] = xx[41] * xx[43];\n  xx[45] = state[23] / xx[10];\n  xx[10] = xx[36] * xx[45];\n  xx[46] = xx[41] * xx[45];\n  xx[47] = xx[36] * xx[43];\n  xx[48] = xx[1] * (xx[46] - xx[47]);\n  xx[49] = xx[1] * (xx[37] + xx[42]) - xx[2];\n  xx[50] = xx[1] * (xx[44] + xx[10]);\n  xx[51] = xx[48];\n  xx[52] = xx[6] * xx[4];\n  xx[53] = xx[8] * xx[5];\n  xx[54] = xx[1] * (xx[52] + xx[53]);\n  xx[55] = xx[54] * xx[29];\n  xx[56] = xx[8] * xx[4];\n  xx[57] = xx[6] * xx[5];\n  xx[58] = xx[1] * (xx[56] - xx[57]);\n  xx[59] = xx[58] * xx[30];\n  xx[60] = xx[54] * xx[28];\n  xx[61] = xx[59] + xx[60];\n  xx[62] = xx[58] * xx[29];\n  xx[63] = xx[55];\n  xx[64] = - xx[61];\n  xx[65] = xx[62];\n  pm_math_Vector3_cross_ra(xx + 28, xx + 63, xx + 66);\n  xx[63] = xx[1] * (xx[55] * xx[27] + xx[66]) - xx[58];\n  xx[64] = xx[1] * (xx[67] - xx[61] * xx[27]);\n  xx[65] = xx[54] + xx[1] * (xx[62] * xx[27] + xx[68]);\n  xx[55] = xx[1] * (xx[32] - xx[31]);\n  xx[31] = xx[55] * xx[29];\n  xx[32] = xx[5] * xx[5];\n  xx[61] = xx[2] - xx[1] * (xx[32] + xx[9]);\n  xx[9] = xx[61] * xx[30];\n  xx[62] = xx[55] * xx[28];\n  xx[66] = xx[9] + xx[62];\n  xx[67] = xx[61] * xx[29];\n  xx[68] = xx[31];\n  xx[69] = - xx[66];\n  xx[70] = xx[67];\n  pm_math_Vector3_cross_ra(xx + 28, xx + 68, xx + 71);\n  xx[68] = xx[1] * (xx[31] * xx[27] + xx[71]) - xx[61];\n  xx[69] = xx[1] * (xx[72] - xx[66] * xx[27]);\n  xx[70] = xx[55] + xx[1] * (xx[67] * xx[27] + xx[73]);\n  xx[31] = xx[1] * (xx[47] + xx[46]);\n  xx[66] = xx[36] * xx[41];\n  xx[67] = xx[43] * xx[45];\n  xx[71] = xx[43] * xx[43];\n  xx[72] = xx[1] * (xx[42] + xx[71]);\n  xx[73] = - xx[31];\n  xx[74] = xx[1] * (xx[66] - xx[67]);\n  xx[75] = xx[72] - xx[2];\n  xx[76] = xx[28] * xx[29];\n  xx[77] = xx[27] * xx[30];\n  xx[78] = xx[27] * xx[27];\n  xx[79] = xx[29] * xx[30];\n  xx[80] = xx[27] * xx[28];\n  xx[81] = xx[1] * (xx[76] - xx[77]);\n  xx[82] = xx[1] * (xx[78] + xx[29] * xx[29]) - xx[2];\n  xx[83] = xx[1] * (xx[79] + xx[80]);\n  xx[84] = xx[1] * (xx[44] - xx[10]);\n  xx[85] = xx[45] * xx[45];\n  xx[86] = xx[1] * (xx[85] + xx[42]);\n  xx[42] = xx[1] * (xx[66] + xx[67]);\n  xx[87] = xx[84];\n  xx[88] = xx[2] - xx[86];\n  xx[89] = xx[42];\n  xx[90] = xx[1] * (xx[53] - xx[52]);\n  xx[52] = xx[11] * xx[30];\n  xx[53] = xx[90] * xx[30];\n  xx[91] = xx[90] * xx[29];\n  xx[92] = xx[35] + xx[91];\n  xx[93] = xx[52];\n  xx[94] = xx[53];\n  xx[95] = - xx[92];\n  pm_math_Vector3_cross_ra(xx + 28, xx + 93, xx + 96);\n  xx[93] = xx[90] + xx[1] * (xx[52] * xx[27] + xx[96]);\n  xx[94] = xx[1] * (xx[53] * xx[27] + xx[97]) - xx[11];\n  xx[95] = xx[1] * (xx[98] - xx[92] * xx[27]);\n  xx[96] = xx[84];\n  xx[97] = xx[1] * (xx[37] + xx[71]) - xx[2];\n  xx[98] = xx[1] * (xx[67] + xx[66]);\n  xx[35] = xx[2] - xx[1] * (xx[7] + xx[32]);\n  xx[7] = xx[54] * xx[30];\n  xx[32] = xx[35] * xx[30];\n  xx[52] = xx[35] * xx[29];\n  xx[53] = xx[60] + xx[52];\n  xx[99] = xx[7];\n  xx[100] = xx[32];\n  xx[101] = - xx[53];\n  pm_math_Vector3_cross_ra(xx + 28, xx + 99, xx + 102);\n  xx[99] = xx[35] + xx[1] * (xx[7] * xx[27] + xx[102]);\n  xx[100] = xx[1] * (xx[32] * xx[27] + xx[103]) - xx[54];\n  xx[101] = xx[1] * (xx[104] - xx[53] * xx[27]);\n  xx[7] = xx[1] * (xx[57] + xx[56]);\n  xx[32] = xx[55] * xx[30];\n  xx[53] = xx[7] * xx[30];\n  xx[56] = xx[7] * xx[29];\n  xx[57] = xx[62] + xx[56];\n  xx[102] = xx[32];\n  xx[103] = xx[53];\n  xx[104] = - xx[57];\n  pm_math_Vector3_cross_ra(xx + 28, xx + 102, xx + 105);\n  xx[102] = xx[7] + xx[1] * (xx[32] * xx[27] + xx[105]);\n  xx[103] = xx[1] * (xx[53] * xx[27] + xx[106]) - xx[55];\n  xx[104] = xx[1] * (xx[107] - xx[57] * xx[27]);\n  xx[32] = xx[1] * (xx[67] - xx[66]);\n  xx[105] = xx[31];\n  xx[106] = xx[32];\n  xx[107] = xx[2] - xx[72];\n  xx[31] = xx[28] * xx[30];\n  xx[53] = xx[27] * xx[29];\n  xx[108] = xx[1] * (xx[31] + xx[53]);\n  xx[109] = xx[1] * (xx[79] - xx[80]);\n  xx[110] = xx[1] * (xx[78] + xx[30] * xx[30]) - xx[2];\n  xx[57] = xx[1] * (xx[71] + xx[85]);\n  xx[60] = xx[1] * (xx[10] + xx[44]);\n  xx[111] = xx[57] - xx[2];\n  xx[112] = - xx[60];\n  xx[113] = xx[1] * (xx[47] - xx[46]);\n  xx[62] = xx[91] + xx[34];\n  xx[34] = xx[90] * xx[28];\n  xx[66] = xx[33] * xx[28];\n  xx[114] = - xx[62];\n  xx[115] = xx[34];\n  xx[116] = xx[66];\n  pm_math_Vector3_cross_ra(xx + 28, xx + 114, xx + 117);\n  xx[114] = xx[1] * (xx[117] - xx[62] * xx[27]);\n  xx[115] = xx[33] + xx[1] * (xx[34] * xx[27] + xx[118]);\n  xx[116] = xx[1] * (xx[66] * xx[27] + xx[119]) - xx[90];\n  xx[117] = xx[1] * (xx[46] + xx[47]);\n  xx[118] = xx[32];\n  xx[119] = xx[1] * (xx[37] + xx[85]) - xx[2];\n  xx[32] = xx[52] + xx[59];\n  xx[34] = xx[35] * xx[28];\n  xx[37] = xx[58] * xx[28];\n  xx[120] = - xx[32];\n  xx[121] = xx[34];\n  xx[122] = xx[37];\n  pm_math_Vector3_cross_ra(xx + 28, xx + 120, xx + 123);\n  xx[120] = xx[1] * (xx[123] - xx[32] * xx[27]);\n  xx[121] = xx[58] + xx[1] * (xx[34] * xx[27] + xx[124]);\n  xx[122] = xx[1] * (xx[37] * xx[27] + xx[125]) - xx[35];\n  xx[32] = xx[56] + xx[9];\n  xx[9] = xx[7] * xx[28];\n  xx[34] = xx[61] * xx[28];\n  xx[123] = - xx[32];\n  xx[124] = xx[9];\n  xx[125] = xx[34];\n  pm_math_Vector3_cross_ra(xx + 28, xx + 123, xx + 126);\n  xx[123] = xx[1] * (xx[126] - xx[32] * xx[27]);\n  xx[124] = xx[61] + xx[1] * (xx[9] * xx[27] + xx[127]);\n  xx[125] = xx[1] * (xx[34] * xx[27] + xx[128]) - xx[7];\n  xx[126] = xx[1] * (xx[10] - xx[44]);\n  xx[127] = xx[86] - xx[2];\n  xx[128] = - xx[42];\n  xx[84] = xx[1] * (xx[78] + xx[28] * xx[28]) - xx[2];\n  xx[85] = xx[1] * (xx[76] + xx[77]);\n  xx[86] = xx[1] * (xx[31] - xx[53]);\n  xx[76] = xx[2] - xx[57];\n  xx[77] = xx[60];\n  xx[78] = xx[48];\n  xx[9] = bb[0] ? xx[0] : - xx[2];\n  xx[10] = 0.04500000000000001;\n  xx[31] = xx[10] * xx[11];\n  xx[32] = xx[31] * xx[30];\n  xx[34] = xx[10] * xx[90];\n  xx[37] = xx[34] * xx[30];\n  xx[42] = xx[31] * xx[28] + xx[34] * xx[29];\n  xx[46] = - xx[32];\n  xx[47] = - xx[37];\n  xx[48] = xx[42];\n  pm_math_Vector3_cross_ra(xx + 28, xx + 46, xx + 129);\n  xx[44] = 0.04499999999999999;\n  xx[46] = xx[44] * xx[5];\n  xx[47] = xx[44] * xx[8];\n  xx[48] = xx[1] * (xx[46] * xx[6] - xx[47] * xx[4]);\n  xx[52] = xx[48] * xx[16];\n  xx[53] = xx[1] * (xx[46] * xx[5] + xx[47] * xx[8]);\n  xx[5] = xx[53] - xx[44] - xx[2];\n  xx[8] = xx[5] * xx[18];\n  xx[56] = xx[52] + xx[8];\n  xx[132] = xx[15];\n  xx[133] = xx[17];\n  xx[134] = xx[12];\n  xx[12] = xx[48] * xx[14];\n  xx[15] = xx[5] * xx[14];\n  xx[135] = - xx[56];\n  xx[136] = xx[12];\n  xx[137] = xx[15];\n  pm_math_Vector3_cross_ra(xx + 132, xx + 135, xx + 138);\n  xx[17] = xx[13] * xx[18];\n  xx[57] = xx[14] * xx[16];\n  xx[59] = xx[10] * xx[54];\n  xx[60] = xx[59] * xx[30];\n  xx[62] = xx[10] * xx[35];\n  xx[66] = xx[62] * xx[30];\n  xx[67] = xx[59] * xx[28] + xx[62] * xx[29];\n  xx[135] = - xx[60];\n  xx[136] = - xx[66];\n  xx[137] = xx[67];\n  pm_math_Vector3_cross_ra(xx + 28, xx + 135, xx + 141);\n  xx[71] = xx[1] * (xx[47] * xx[6] + xx[46] * xx[4]);\n  xx[4] = xx[71] * xx[16];\n  xx[6] = xx[71] * xx[14];\n  xx[46] = xx[8] - xx[6];\n  xx[8] = xx[5] * xx[16];\n  xx[135] = - xx[4];\n  xx[136] = - xx[46];\n  xx[137] = xx[8];\n  pm_math_Vector3_cross_ra(xx + 132, xx + 135, xx + 144);\n  xx[47] = xx[16] * xx[16];\n  xx[72] = xx[18] * xx[18];\n  xx[79] = xx[10] * xx[55];\n  xx[80] = xx[79] * xx[30];\n  xx[91] = xx[10] * xx[7];\n  xx[92] = xx[91] * xx[30];\n  xx[135] = xx[79] * xx[28] + xx[91] * xx[29];\n  xx[147] = - xx[80];\n  xx[148] = - xx[92];\n  xx[149] = xx[135];\n  pm_math_Vector3_cross_ra(xx + 28, xx + 147, xx + 150);\n  xx[136] = xx[71] * xx[18];\n  xx[137] = xx[48] * xx[18];\n  xx[147] = xx[52] - xx[6];\n  xx[153] = - xx[136];\n  xx[154] = xx[137];\n  xx[155] = - xx[147];\n  pm_math_Vector3_cross_ra(xx + 132, xx + 153, xx + 156);\n  xx[6] = bb[0] ? xx[0] : xx[2];\n  xx[52] = 0.0225;\n  xx[132] = xx[52] * xx[45];\n  xx[133] = xx[132] * xx[36];\n  xx[134] = xx[52] * xx[41];\n  xx[148] = xx[52] * xx[43];\n  xx[149] = xx[148] * xx[43];\n  xx[153] = xx[132] * xx[45];\n  xx[154] = xx[14] * xx[14];\n  xx[155] = xx[134] * xx[41];\n  xx[159] = xx[13] * xx[14];\n  xx[160] = xx[16] * xx[18];\n  xx[161] = xx[14] * xx[18];\n  xx[162] = xx[13] * xx[16];\n  xx[163] = xx[134] * xx[36];\n  xx[164] = xx[148] * xx[36];\n  xx[165] = xx[0];\n  xx[166] = xx[0];\n  xx[167] = xx[0];\n  xx[168] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 38, xx + 49);\n  xx[169] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 63, xx + 49);\n  xx[170] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 68, xx + 49);\n  xx[171] = xx[0];\n  xx[172] = xx[0];\n  xx[173] = xx[0];\n  xx[174] = xx[0];\n  xx[175] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 73, xx + 81);\n  xx[176] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 87, xx + 81);\n  xx[177] = xx[0];\n  xx[178] = xx[0];\n  xx[179] = xx[0];\n  xx[180] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 93, xx + 96);\n  xx[181] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 99, xx + 96);\n  xx[182] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 102, xx + 96);\n  xx[183] = xx[0];\n  xx[184] = xx[0];\n  xx[185] = xx[0];\n  xx[186] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 105, xx + 108);\n  xx[187] = xx[0];\n  xx[188] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 111, xx + 108);\n  xx[189] = xx[0];\n  xx[190] = xx[0];\n  xx[191] = xx[0];\n  xx[192] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 114, xx + 117);\n  xx[193] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 120, xx + 117);\n  xx[194] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 123, xx + 117);\n  xx[195] = xx[0];\n  xx[196] = xx[0];\n  xx[197] = xx[0];\n  xx[198] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 126, xx + 84);\n  xx[199] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 76, xx + 84);\n  xx[200] = xx[0];\n  xx[201] = xx[9];\n  xx[202] = xx[0];\n  xx[203] = xx[0];\n  xx[204] = bb[0] ? xx[0] : - (xx[1] * (xx[129] - xx[32] * xx[27]) - xx[34] +\n    xx[1] * (xx[56] * xx[13] + xx[138]) + xx[1] * (xx[17] - xx[57]));\n  xx[205] = bb[0] ? xx[0] : - (xx[1] * (xx[141] - xx[60] * xx[27]) - xx[62] +\n    xx[5] + xx[1] * (xx[144] + xx[4] * xx[13]) - xx[1] * (xx[47] + xx[72]) + xx\n    [2]);\n  xx[206] = bb[0] ? xx[0] : - (xx[1] * (xx[150] - xx[80] * xx[27]) - xx[91] +\n    xx[1] * (xx[156] + xx[136] * xx[13]) - xx[48]);\n  xx[207] = xx[6];\n  xx[208] = xx[0];\n  xx[209] = xx[0];\n  xx[210] = bb[0] ? xx[0] : xx[1] * (xx[133] - xx[134] * xx[43]);\n  xx[211] = bb[0] ? xx[0] : xx[52] - xx[1] * (xx[149] + xx[153]);\n  xx[212] = xx[0];\n  xx[213] = xx[0];\n  xx[214] = xx[9];\n  xx[215] = xx[0];\n  xx[216] = bb[0] ? xx[0] : - (xx[1] * (xx[130] - xx[37] * xx[27]) + xx[1] *\n    (xx[139] - xx[12] * xx[13]) + xx[1] * (xx[72] + xx[154]) - xx[5] + xx[31] -\n    xx[2]);\n  xx[217] = bb[0] ? xx[0] : - (xx[1] * (xx[142] - xx[66] * xx[27]) + xx[59] +\n    xx[1] * (xx[46] * xx[13] + xx[145]) + xx[1] * (xx[17] + xx[57]));\n  xx[218] = bb[0] ? xx[0] : - (xx[1] * (xx[151] - xx[92] * xx[27]) + xx[79] +\n    xx[1] * (xx[157] - xx[137] * xx[13]) - xx[71]);\n  xx[219] = xx[0];\n  xx[220] = xx[6];\n  xx[221] = xx[0];\n  xx[222] = bb[0] ? xx[0] : xx[1] * (xx[153] + xx[155]) - xx[52];\n  xx[223] = bb[0] ? xx[0] : xx[1] * (xx[133] + xx[148] * xx[41]);\n  xx[224] = xx[0];\n  xx[225] = xx[0];\n  xx[226] = xx[0];\n  xx[227] = xx[9];\n  xx[228] = bb[0] ? xx[0] : - (xx[1] * (xx[131] + xx[42] * xx[27]) + xx[48] +\n    xx[1] * (xx[140] - xx[15] * xx[13]) - xx[1] * (xx[159] + xx[160]));\n  xx[229] = bb[0] ? xx[0] : - (xx[1] * (xx[143] + xx[67] * xx[27]) + xx[1] *\n    (xx[146] - xx[8] * xx[13]) + xx[71] + xx[1] * (xx[161] - xx[162]));\n  xx[230] = bb[0] ? xx[0] : - (xx[1] * (xx[152] + xx[135] * xx[27]) + xx[1] *\n    (xx[147] * xx[13] + xx[158]));\n  xx[231] = xx[0];\n  xx[232] = xx[0];\n  xx[233] = xx[6];\n  xx[234] = bb[0] ? xx[0] : - (xx[1] * (xx[163] + xx[132] * xx[43]));\n  xx[235] = bb[0] ? xx[0] : xx[1] * (xx[132] * xx[41] - xx[164]);\n  xx[236] = xx[0];\n  ii[0] = bb[0] ? 0 : 1;\n  xx[4] = - xx[71];\n  xx[37] = xx[4];\n  xx[38] = xx[48];\n  xx[39] = xx[5];\n  pm_math_Quaternion_xform_ra(xx + 19, xx + 37, xx + 63);\n  xx[8] = xx[10] * xx[29];\n  xx[12] = xx[10] * xx[28];\n  xx[15] = 0.9325;\n  xx[72] = pm_math_Vector3_dot_ra(xx + 49, xx + 81);\n  xx[73] = pm_math_Vector3_dot_ra(xx + 96, xx + 108);\n  xx[74] = pm_math_Vector3_dot_ra(xx + 117, xx + 84);\n  xx[75] = xx[1] * (xx[164] + xx[134] * xx[45]) + state[17] - (xx[63] + state[0]\n    + xx[1] * (xx[162] + xx[161]) - xx[1] * (xx[8] * xx[27] + xx[12] * xx[30]));\n  xx[76] = xx[1] * (xx[148] * xx[45] - xx[163]) + state[18] - (xx[1] * (xx[12] *\n    xx[27] - xx[8] * xx[30]) + xx[64] + state[1] - xx[1] * (xx[159] - xx[160]));\n  xx[77] = state[19] - xx[1] * (xx[155] + xx[149]) - (xx[65] + state[2] - xx[1] *\n    (xx[154] + xx[47]) + xx[1] * (xx[12] * xx[28] + xx[8] * xx[29])) - xx[15];\n  zeroMajor(1, 6, ii + 0, xx + 72);\n  xx[63] = - xx[72];\n  xx[64] = - xx[73];\n  xx[65] = - xx[74];\n  xx[66] = - xx[75];\n  xx[67] = - xx[76];\n  xx[68] = - xx[77];\n  xx[8] = 1.0e-8;\n  memcpy(xx + 237, xx + 165, 72 * sizeof(double));\n  factorAndSolveWide(6, 12, xx + 237, xx + 72, xx + 80, ii + 1, xx + 63, xx[8],\n                     xx + 92);\n  xx[12] = state[0] + xx[92];\n  xx[19] = xx[13];\n  xx[20] = xx[14];\n  xx[21] = xx[16];\n  xx[22] = xx[18];\n  pm_math_Quaternion_compDeriv_ra(xx + 19, xx + 95, xx + 27);\n  xx[17] = xx[13] + xx[27];\n  xx[13] = xx[14] + xx[28];\n  xx[14] = xx[16] + xx[29];\n  xx[16] = xx[18] + xx[30];\n  xx[18] = 1.0e-64;\n  xx[19] = sqrt(xx[17] * xx[17] + xx[13] * xx[13] + xx[14] * xx[14] + xx[16] *\n                xx[16]);\n  if (xx[18] > xx[19])\n    xx[19] = xx[18];\n  xx[20] = xx[17] / xx[19];\n  xx[17] = xx[13] / xx[19];\n  xx[13] = - xx[17];\n  xx[21] = xx[14] / xx[19];\n  xx[14] = - xx[21];\n  xx[22] = xx[16] / xx[19];\n  xx[16] = - xx[22];\n  xx[27] = - xx[20];\n  xx[28] = xx[13];\n  xx[29] = xx[14];\n  xx[30] = xx[16];\n  pm_math_Quaternion_compose_ra(xx + 27, xx + 23, xx + 63);\n  xx[19] = xx[11] * xx[65];\n  xx[32] = xx[33] * xx[66];\n  xx[40] = xx[11] * xx[64];\n  xx[42] = xx[32] + xx[40];\n  xx[46] = xx[33] * xx[65];\n  xx[49] = xx[19];\n  xx[50] = - xx[42];\n  xx[51] = xx[46];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 49, xx + 67);\n  xx[49] = xx[1] * (xx[19] * xx[63] + xx[67]) - xx[33];\n  xx[50] = xx[1] * (xx[68] - xx[42] * xx[63]);\n  xx[51] = xx[11] + xx[1] * (xx[46] * xx[63] + xx[69]);\n  xx[67] = xx[36];\n  xx[68] = xx[41];\n  xx[69] = xx[43];\n  xx[70] = xx[45];\n  pm_math_Quaternion_compDeriv_ra(xx + 67, xx + 101, xx + 72);\n  xx[19] = xx[36] + xx[72];\n  xx[36] = xx[41] + xx[73];\n  xx[41] = xx[43] + xx[74];\n  xx[42] = xx[45] + xx[75];\n  xx[43] = sqrt(xx[19] * xx[19] + xx[36] * xx[36] + xx[41] * xx[41] + xx[42] *\n                xx[42]);\n  if (xx[18] > xx[43])\n    xx[43] = xx[18];\n  xx[45] = xx[19] / xx[43];\n  xx[19] = xx[45] * xx[45];\n  xx[46] = xx[36] / xx[43];\n  xx[36] = xx[46] * xx[46];\n  xx[47] = xx[41] / xx[43];\n  xx[41] = xx[46] * xx[47];\n  xx[56] = xx[42] / xx[43];\n  xx[42] = xx[45] * xx[56];\n  xx[43] = xx[46] * xx[56];\n  xx[57] = xx[45] * xx[47];\n  xx[60] = xx[1] * (xx[43] - xx[57]);\n  xx[67] = xx[1] * (xx[19] + xx[36]) - xx[2];\n  xx[68] = xx[1] * (xx[41] + xx[42]);\n  xx[69] = xx[60];\n  xx[70] = xx[54] * xx[65];\n  xx[72] = xx[58] * xx[66];\n  xx[73] = xx[54] * xx[64];\n  xx[74] = xx[72] + xx[73];\n  xx[75] = xx[58] * xx[65];\n  xx[76] = xx[70];\n  xx[77] = - xx[74];\n  xx[78] = xx[75];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 76, xx + 80);\n  xx[76] = xx[1] * (xx[70] * xx[63] + xx[80]) - xx[58];\n  xx[77] = xx[1] * (xx[81] - xx[74] * xx[63]);\n  xx[78] = xx[54] + xx[1] * (xx[75] * xx[63] + xx[82]);\n  xx[70] = xx[55] * xx[65];\n  xx[74] = xx[61] * xx[66];\n  xx[75] = xx[55] * xx[64];\n  xx[80] = xx[74] + xx[75];\n  xx[81] = xx[61] * xx[65];\n  xx[82] = xx[70];\n  xx[83] = - xx[80];\n  xx[84] = xx[81];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 82, xx + 85);\n  xx[82] = xx[1] * (xx[70] * xx[63] + xx[85]) - xx[61];\n  xx[83] = xx[1] * (xx[86] - xx[80] * xx[63]);\n  xx[84] = xx[55] + xx[1] * (xx[81] * xx[63] + xx[87]);\n  xx[70] = xx[1] * (xx[57] + xx[43]);\n  xx[80] = xx[45] * xx[46];\n  xx[81] = xx[47] * xx[56];\n  xx[85] = xx[47] * xx[47];\n  xx[86] = xx[1] * (xx[36] + xx[85]);\n  xx[87] = - xx[70];\n  xx[88] = xx[1] * (xx[80] - xx[81]);\n  xx[89] = xx[86] - xx[2];\n  xx[104] = xx[64] * xx[65];\n  xx[105] = xx[63] * xx[66];\n  xx[106] = xx[63] * xx[63];\n  xx[107] = xx[65] * xx[66];\n  xx[108] = xx[63] * xx[64];\n  xx[109] = xx[1] * (xx[104] - xx[105]);\n  xx[110] = xx[1] * (xx[106] + xx[65] * xx[65]) - xx[2];\n  xx[111] = xx[1] * (xx[107] + xx[108]);\n  xx[112] = xx[1] * (xx[41] - xx[42]);\n  xx[113] = xx[56] * xx[56];\n  xx[114] = xx[1] * (xx[113] + xx[36]);\n  xx[36] = xx[1] * (xx[80] + xx[81]);\n  xx[115] = xx[112];\n  xx[116] = xx[2] - xx[114];\n  xx[117] = xx[36];\n  xx[118] = xx[11] * xx[66];\n  xx[119] = xx[90] * xx[66];\n  xx[120] = xx[90] * xx[65];\n  xx[121] = xx[40] + xx[120];\n  xx[122] = xx[118];\n  xx[123] = xx[119];\n  xx[124] = - xx[121];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 122, xx + 125);\n  xx[122] = xx[90] + xx[1] * (xx[118] * xx[63] + xx[125]);\n  xx[123] = xx[1] * (xx[119] * xx[63] + xx[126]) - xx[11];\n  xx[124] = xx[1] * (xx[127] - xx[121] * xx[63]);\n  xx[125] = xx[112];\n  xx[126] = xx[1] * (xx[19] + xx[85]) - xx[2];\n  xx[127] = xx[1] * (xx[81] + xx[80]);\n  xx[11] = xx[54] * xx[66];\n  xx[40] = xx[35] * xx[66];\n  xx[112] = xx[35] * xx[65];\n  xx[118] = xx[73] + xx[112];\n  xx[128] = xx[11];\n  xx[129] = xx[40];\n  xx[130] = - xx[118];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 128, xx + 131);\n  xx[128] = xx[35] + xx[1] * (xx[11] * xx[63] + xx[131]);\n  xx[129] = xx[1] * (xx[40] * xx[63] + xx[132]) - xx[54];\n  xx[130] = xx[1] * (xx[133] - xx[118] * xx[63]);\n  xx[11] = xx[55] * xx[66];\n  xx[40] = xx[7] * xx[66];\n  xx[54] = xx[7] * xx[65];\n  xx[73] = xx[75] + xx[54];\n  xx[131] = xx[11];\n  xx[132] = xx[40];\n  xx[133] = - xx[73];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 131, xx + 134);\n  xx[131] = xx[7] + xx[1] * (xx[11] * xx[63] + xx[134]);\n  xx[132] = xx[1] * (xx[40] * xx[63] + xx[135]) - xx[55];\n  xx[133] = xx[1] * (xx[136] - xx[73] * xx[63]);\n  xx[11] = xx[1] * (xx[81] - xx[80]);\n  xx[134] = xx[70];\n  xx[135] = xx[11];\n  xx[136] = xx[2] - xx[86];\n  xx[40] = xx[64] * xx[66];\n  xx[55] = xx[63] * xx[65];\n  xx[137] = xx[1] * (xx[40] + xx[55]);\n  xx[138] = xx[1] * (xx[107] - xx[108]);\n  xx[139] = xx[1] * (xx[106] + xx[66] * xx[66]) - xx[2];\n  xx[70] = xx[1] * (xx[85] + xx[113]);\n  xx[73] = xx[1] * (xx[42] + xx[41]);\n  xx[140] = xx[70] - xx[2];\n  xx[141] = - xx[73];\n  xx[142] = xx[1] * (xx[57] - xx[43]);\n  xx[75] = xx[120] + xx[32];\n  xx[32] = xx[90] * xx[64];\n  xx[80] = xx[33] * xx[64];\n  xx[118] = - xx[75];\n  xx[119] = xx[32];\n  xx[120] = xx[80];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 118, xx + 143);\n  xx[118] = xx[1] * (xx[143] - xx[75] * xx[63]);\n  xx[119] = xx[33] + xx[1] * (xx[32] * xx[63] + xx[144]);\n  xx[120] = xx[1] * (xx[80] * xx[63] + xx[145]) - xx[90];\n  xx[143] = xx[1] * (xx[43] + xx[57]);\n  xx[144] = xx[11];\n  xx[145] = xx[1] * (xx[19] + xx[113]) - xx[2];\n  xx[11] = xx[112] + xx[72];\n  xx[19] = xx[35] * xx[64];\n  xx[32] = xx[58] * xx[64];\n  xx[146] = - xx[11];\n  xx[147] = xx[19];\n  xx[148] = xx[32];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 146, xx + 149);\n  xx[146] = xx[1] * (xx[149] - xx[11] * xx[63]);\n  xx[147] = xx[58] + xx[1] * (xx[19] * xx[63] + xx[150]);\n  xx[148] = xx[1] * (xx[32] * xx[63] + xx[151]) - xx[35];\n  xx[11] = xx[54] + xx[74];\n  xx[19] = xx[7] * xx[64];\n  xx[32] = xx[61] * xx[64];\n  xx[149] = - xx[11];\n  xx[150] = xx[19];\n  xx[151] = xx[32];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 149, xx + 152);\n  xx[149] = xx[1] * (xx[152] - xx[11] * xx[63]);\n  xx[150] = xx[61] + xx[1] * (xx[19] * xx[63] + xx[153]);\n  xx[151] = xx[1] * (xx[32] * xx[63] + xx[154]) - xx[7];\n  xx[152] = xx[1] * (xx[42] - xx[41]);\n  xx[153] = xx[114] - xx[2];\n  xx[154] = - xx[36];\n  xx[41] = xx[1] * (xx[106] + xx[64] * xx[64]) - xx[2];\n  xx[42] = xx[1] * (xx[104] + xx[105]);\n  xx[43] = xx[1] * (xx[40] - xx[55]);\n  xx[104] = xx[2] - xx[70];\n  xx[105] = xx[73];\n  xx[106] = xx[60];\n  xx[7] = xx[31] * xx[66];\n  xx[11] = xx[34] * xx[66];\n  xx[19] = xx[31] * xx[64] + xx[34] * xx[65];\n  xx[72] = - xx[7];\n  xx[73] = - xx[11];\n  xx[74] = xx[19];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 72, xx + 112);\n  xx[32] = xx[48] * xx[21];\n  xx[33] = xx[5] * xx[22];\n  xx[35] = xx[32] + xx[33];\n  xx[72] = xx[13];\n  xx[73] = xx[14];\n  xx[74] = xx[16];\n  xx[13] = xx[48] * xx[17];\n  xx[14] = xx[5] * xx[17];\n  xx[155] = - xx[35];\n  xx[156] = xx[13];\n  xx[157] = xx[14];\n  pm_math_Vector3_cross_ra(xx + 72, xx + 155, xx + 158);\n  xx[16] = xx[20] * xx[22];\n  xx[36] = xx[17] * xx[21];\n  xx[40] = xx[59] * xx[66];\n  xx[54] = xx[62] * xx[66];\n  xx[55] = xx[59] * xx[64] + xx[62] * xx[65];\n  xx[155] = - xx[40];\n  xx[156] = - xx[54];\n  xx[157] = xx[55];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 155, xx + 161);\n  xx[57] = xx[71] * xx[21];\n  xx[58] = xx[71] * xx[17];\n  xx[60] = xx[33] - xx[58];\n  xx[33] = xx[5] * xx[21];\n  xx[155] = - xx[57];\n  xx[156] = - xx[60];\n  xx[157] = xx[33];\n  pm_math_Vector3_cross_ra(xx + 72, xx + 155, xx + 164);\n  xx[61] = xx[21] * xx[21];\n  xx[70] = xx[22] * xx[22];\n  xx[75] = xx[79] * xx[66];\n  xx[80] = xx[91] * xx[66];\n  xx[81] = xx[79] * xx[64] + xx[91] * xx[65];\n  xx[155] = - xx[75];\n  xx[156] = - xx[80];\n  xx[157] = xx[81];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 155, xx + 167);\n  xx[85] = xx[71] * xx[22];\n  xx[86] = xx[48] * xx[22];\n  xx[90] = xx[32] - xx[58];\n  xx[155] = - xx[85];\n  xx[156] = xx[86];\n  xx[157] = - xx[90];\n  pm_math_Vector3_cross_ra(xx + 72, xx + 155, xx + 170);\n  xx[32] = xx[52] * xx[56];\n  xx[58] = xx[32] * xx[45];\n  xx[72] = xx[52] * xx[46];\n  xx[73] = xx[52] * xx[47];\n  xx[74] = xx[73] * xx[47];\n  xx[107] = xx[32] * xx[56];\n  xx[108] = xx[17] * xx[17];\n  xx[121] = xx[72] * xx[46];\n  xx[155] = xx[20] * xx[17];\n  xx[156] = xx[21] * xx[22];\n  xx[157] = xx[17] * xx[22];\n  xx[173] = xx[20] * xx[21];\n  xx[174] = xx[72] * xx[45];\n  xx[175] = xx[73] * xx[45];\n  xx[176] = xx[0];\n  xx[177] = xx[0];\n  xx[178] = xx[0];\n  xx[179] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 49, xx + 67);\n  xx[180] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 76, xx + 67);\n  xx[181] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 82, xx + 67);\n  xx[182] = xx[0];\n  xx[183] = xx[0];\n  xx[184] = xx[0];\n  xx[185] = xx[0];\n  xx[186] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 87, xx + 109);\n  xx[187] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 115, xx + 109);\n  xx[188] = xx[0];\n  xx[189] = xx[0];\n  xx[190] = xx[0];\n  xx[191] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 122, xx + 125);\n  xx[192] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 128, xx + 125);\n  xx[193] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 131, xx + 125);\n  xx[194] = xx[0];\n  xx[195] = xx[0];\n  xx[196] = xx[0];\n  xx[197] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 134, xx + 137);\n  xx[198] = xx[0];\n  xx[199] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 140, xx + 137);\n  xx[200] = xx[0];\n  xx[201] = xx[0];\n  xx[202] = xx[0];\n  xx[203] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 118, xx + 143);\n  xx[204] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 146, xx + 143);\n  xx[205] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 149, xx + 143);\n  xx[206] = xx[0];\n  xx[207] = xx[0];\n  xx[208] = xx[0];\n  xx[209] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 152, xx + 41);\n  xx[210] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 104, xx + 41);\n  xx[211] = xx[0];\n  xx[212] = xx[9];\n  xx[213] = xx[0];\n  xx[214] = xx[0];\n  xx[215] = bb[0] ? xx[0] : - (xx[1] * (xx[112] - xx[7] * xx[63]) - xx[34] + xx\n    [1] * (xx[35] * xx[20] + xx[158]) + xx[1] * (xx[16] - xx[36]));\n  xx[216] = bb[0] ? xx[0] : - (xx[1] * (xx[161] - xx[40] * xx[63]) - xx[62] +\n    xx[5] + xx[1] * (xx[164] + xx[57] * xx[20]) - xx[1] * (xx[61] + xx[70]) +\n    xx[2]);\n  xx[217] = bb[0] ? xx[0] : - (xx[1] * (xx[167] - xx[75] * xx[63]) - xx[91] +\n    xx[1] * (xx[170] + xx[85] * xx[20]) - xx[48]);\n  xx[218] = xx[6];\n  xx[219] = xx[0];\n  xx[220] = xx[0];\n  xx[221] = bb[0] ? xx[0] : xx[1] * (xx[58] - xx[72] * xx[47]);\n  xx[222] = bb[0] ? xx[0] : xx[52] - xx[1] * (xx[74] + xx[107]);\n  xx[223] = xx[0];\n  xx[224] = xx[0];\n  xx[225] = xx[9];\n  xx[226] = xx[0];\n  xx[227] = bb[0] ? xx[0] : - (xx[1] * (xx[113] - xx[11] * xx[63]) + xx[1] *\n    (xx[159] - xx[13] * xx[20]) + xx[1] * (xx[70] + xx[108]) - xx[5] + xx[31] -\n    xx[2]);\n  xx[228] = bb[0] ? xx[0] : - (xx[1] * (xx[162] - xx[54] * xx[63]) + xx[59] +\n    xx[1] * (xx[60] * xx[20] + xx[165]) + xx[1] * (xx[16] + xx[36]));\n  xx[229] = bb[0] ? xx[0] : - (xx[1] * (xx[168] - xx[80] * xx[63]) + xx[79] +\n    xx[1] * (xx[171] - xx[86] * xx[20]) - xx[71]);\n  xx[230] = xx[0];\n  xx[231] = xx[6];\n  xx[232] = xx[0];\n  xx[233] = bb[0] ? xx[0] : xx[1] * (xx[107] + xx[121]) - xx[52];\n  xx[234] = bb[0] ? xx[0] : xx[1] * (xx[58] + xx[73] * xx[46]);\n  xx[235] = xx[0];\n  xx[236] = xx[0];\n  xx[237] = xx[0];\n  xx[238] = xx[9];\n  xx[239] = bb[0] ? xx[0] : - (xx[1] * (xx[114] + xx[19] * xx[63]) + xx[48] +\n    xx[1] * (xx[160] - xx[14] * xx[20]) - xx[1] * (xx[155] + xx[156]));\n  xx[240] = bb[0] ? xx[0] : - (xx[1] * (xx[163] + xx[55] * xx[63]) + xx[1] *\n    (xx[166] - xx[33] * xx[20]) + xx[71] + xx[1] * (xx[157] - xx[173]));\n  xx[241] = bb[0] ? xx[0] : - (xx[1] * (xx[169] + xx[81] * xx[63]) + xx[1] *\n    (xx[90] * xx[20] + xx[172]));\n  xx[242] = xx[0];\n  xx[243] = xx[0];\n  xx[244] = xx[6];\n  xx[245] = bb[0] ? xx[0] : - (xx[1] * (xx[174] + xx[32] * xx[47]));\n  xx[246] = bb[0] ? xx[0] : xx[1] * (xx[32] * xx[46] - xx[175]);\n  xx[247] = xx[0];\n  xx[5] = state[17] + xx[98];\n  pm_math_Quaternion_xform_ra(xx + 27, xx + 37, xx + 31);\n  xx[7] = xx[10] * xx[65];\n  xx[11] = xx[10] * xx[64];\n  xx[13] = state[18] + xx[99];\n  xx[14] = state[1] + xx[93];\n  xx[16] = state[19] + xx[100];\n  xx[19] = state[2] + xx[94];\n  xx[34] = pm_math_Vector3_dot_ra(xx + 67, xx + 109);\n  xx[35] = pm_math_Vector3_dot_ra(xx + 125, xx + 137);\n  xx[36] = pm_math_Vector3_dot_ra(xx + 143, xx + 41);\n  xx[37] = xx[1] * (xx[175] + xx[72] * xx[56]) + xx[5] - (xx[31] + xx[12] + xx[1]\n    * (xx[173] + xx[157]) - xx[1] * (xx[7] * xx[63] + xx[11] * xx[66]));\n  xx[38] = xx[1] * (xx[73] * xx[56] - xx[174]) + xx[13] - (xx[1] * (xx[11] * xx\n    [63] - xx[7] * xx[66]) + xx[32] + xx[14] - xx[1] * (xx[155] - xx[156]));\n  xx[39] = xx[52] - xx[1] * (xx[121] + xx[74]) + xx[16] - (xx[33] + xx[19] -\n    (xx[1] * (xx[108] + xx[61]) - xx[2]) + xx[1] * (xx[11] * xx[64] + xx[7] *\n    xx[65])) + xx[10];\n  zeroMajor(1, 6, ii + 0, xx + 34);\n  xx[27] = - xx[34];\n  xx[28] = - xx[35];\n  xx[29] = - xx[36];\n  xx[30] = - xx[37];\n  xx[31] = - xx[38];\n  xx[32] = - xx[39];\n  memcpy(xx + 69, xx + 176, 72 * sizeof(double));\n  factorAndSolveWide(6, 12, xx + 69, xx + 33, xx + 141, ii + 1, xx + 27, xx[8],\n                     xx + 57);\n  xx[7] = xx[12] + xx[57];\n  xx[11] = xx[14] + xx[58];\n  xx[12] = xx[19] + xx[59];\n  xx[27] = xx[20];\n  xx[28] = xx[17];\n  xx[29] = xx[21];\n  xx[30] = xx[22];\n  pm_math_Quaternion_compDeriv_ra(xx + 27, xx + 60, xx + 31);\n  xx[14] = xx[20] + xx[31];\n  xx[19] = xx[17] + xx[32];\n  xx[17] = xx[21] + xx[33];\n  xx[20] = xx[22] + xx[34];\n  xx[21] = sqrt(xx[14] * xx[14] + xx[19] * xx[19] + xx[17] * xx[17] + xx[20] *\n                xx[20]);\n  if (xx[18] > xx[21])\n    xx[21] = xx[18];\n  xx[22] = xx[14] / xx[21];\n  xx[14] = xx[19] / xx[21];\n  xx[19] = xx[17] / xx[21];\n  xx[17] = xx[20] / xx[21];\n  xx[20] = xx[5] + xx[63];\n  xx[5] = xx[13] + xx[64];\n  xx[13] = xx[16] + xx[65];\n  xx[27] = xx[45];\n  xx[28] = xx[46];\n  xx[29] = xx[47];\n  xx[30] = xx[56];\n  pm_math_Quaternion_compDeriv_ra(xx + 27, xx + 66, xx + 31);\n  xx[16] = xx[45] + xx[31];\n  xx[21] = xx[46] + xx[32];\n  xx[27] = xx[47] + xx[33];\n  xx[28] = xx[56] + xx[34];\n  xx[29] = sqrt(xx[16] * xx[16] + xx[21] * xx[21] + xx[27] * xx[27] + xx[28] *\n                xx[28]);\n  if (xx[18] > xx[29])\n    xx[29] = xx[18];\n  xx[18] = xx[16] / xx[29];\n  xx[16] = xx[21] / xx[29];\n  xx[21] = xx[27] / xx[29];\n  xx[27] = xx[28] / xx[29];\n  xx[54] = xx[7];\n  xx[55] = xx[11];\n  xx[56] = xx[12];\n  xx[57] = xx[22];\n  xx[58] = xx[14];\n  xx[59] = xx[19];\n  xx[60] = xx[17];\n  xx[61] = state[7];\n  xx[62] = state[8];\n  xx[63] = state[9];\n  xx[64] = state[10];\n  xx[65] = state[11];\n  xx[66] = state[12];\n  xx[67] = state[13];\n  xx[68] = state[14];\n  xx[69] = state[15];\n  xx[70] = state[16];\n  xx[71] = xx[20];\n  xx[72] = xx[5];\n  xx[73] = xx[13];\n  xx[74] = xx[18];\n  xx[75] = xx[16];\n  xx[76] = xx[21];\n  xx[77] = xx[27];\n  xx[78] = state[24];\n  xx[79] = state[25];\n  xx[80] = state[26];\n  xx[81] = state[27];\n  xx[82] = state[28];\n  xx[83] = state[29];\n  xx[28] = xx[18] * xx[18];\n  xx[29] = xx[16] * xx[21];\n  xx[30] = xx[18] * xx[27];\n  xx[31] = xx[16] * xx[27];\n  xx[32] = xx[18] * xx[21];\n  xx[33] = xx[1] * (xx[28] + xx[16] * xx[16]) - xx[2];\n  xx[34] = xx[1] * (xx[29] + xx[30]);\n  xx[35] = xx[1] * (xx[31] - xx[32]);\n  xx[36] = - xx[22];\n  xx[37] = - xx[14];\n  xx[38] = - xx[19];\n  xx[39] = - xx[17];\n  pm_math_Quaternion_compose_ra(xx + 36, xx + 23, xx + 40);\n  xx[23] = xx[41] * xx[42];\n  xx[24] = xx[40] * xx[43];\n  xx[25] = xx[40] * xx[40];\n  xx[26] = xx[42] * xx[43];\n  xx[45] = xx[40] * xx[41];\n  xx[49] = xx[1] * (xx[23] - xx[24]);\n  xx[50] = xx[1] * (xx[25] + xx[42] * xx[42]) - xx[2];\n  xx[51] = xx[1] * (xx[26] + xx[45]);\n  xx[46] = xx[21] * xx[27];\n  xx[47] = xx[18] * xx[16];\n  xx[84] = xx[1] * (xx[29] - xx[30]);\n  xx[85] = xx[1] * (xx[28] + xx[21] * xx[21]) - xx[2];\n  xx[86] = xx[1] * (xx[46] + xx[47]);\n  xx[29] = xx[41] * xx[43];\n  xx[30] = xx[40] * xx[42];\n  xx[87] = xx[1] * (xx[29] + xx[30]);\n  xx[88] = xx[1] * (xx[26] - xx[45]);\n  xx[89] = xx[1] * (xx[25] + xx[43] * xx[43]) - xx[2];\n  xx[90] = xx[1] * (xx[31] + xx[32]);\n  xx[91] = xx[1] * (xx[46] - xx[47]);\n  xx[92] = xx[1] * (xx[28] + xx[27] * xx[27]) - xx[2];\n  xx[45] = xx[1] * (xx[25] + xx[41] * xx[41]) - xx[2];\n  xx[46] = xx[1] * (xx[23] + xx[24]);\n  xx[47] = xx[1] * (xx[29] - xx[30]);\n  xx[23] = xx[52] * xx[21];\n  xx[24] = xx[52] * xx[16];\n  xx[25] = 1.045;\n  xx[28] = xx[4];\n  xx[29] = xx[48];\n  xx[30] = xx[53] - xx[25];\n  pm_math_Quaternion_xform_ra(xx + 36, xx + 28, xx + 93);\n  xx[4] = xx[10] * xx[42];\n  xx[26] = xx[10] * xx[41];\n  xx[96] = pm_math_Vector3_dot_ra(xx + 33, xx + 49);\n  xx[97] = pm_math_Vector3_dot_ra(xx + 84, xx + 87);\n  xx[98] = pm_math_Vector3_dot_ra(xx + 90, xx + 45);\n  xx[99] = xx[1] * (xx[23] * xx[18] + xx[24] * xx[27]) + xx[20] - (xx[93] + xx[7]\n    + xx[1] * (xx[22] * xx[19] + xx[14] * xx[17]) - xx[1] * (xx[4] * xx[40] +\n    xx[26] * xx[43]));\n  xx[100] = xx[1] * (xx[23] * xx[27] - xx[24] * xx[18]) + xx[5] - (xx[1] * (xx\n    [26] * xx[40] - xx[4] * xx[43]) + xx[94] + xx[11] - xx[1] * (xx[22] * xx[14]\n    - xx[19] * xx[17]));\n  xx[101] = xx[13] - xx[1] * (xx[24] * xx[16] + xx[23] * xx[21]) - (xx[95] + xx\n    [12] - xx[1] * (xx[14] * xx[14] + xx[19] * xx[19]) + xx[1] * (xx[26] * xx[41]\n    + xx[4] * xx[42])) - xx[15];\n  zeroMajor(1, 6, ii + 0, xx + 96);\n  xx[11] = fabs(xx[96]);\n  xx[12] = fabs(xx[97]);\n  xx[13] = fabs(xx[98]);\n  xx[14] = fabs(xx[99]);\n  xx[15] = fabs(xx[100]);\n  xx[16] = fabs(xx[101]);\n  ii[1] = 11;\n\n  {\n    int ll;\n    for (ll = 12; ll < 17; ++ll)\n      if (xx[ll] > xx[ii[1]])\n        ii[1] = ll;\n  }\n\n  ii[1] -= 11;\n  xx[4] = xx[11 + (ii[1])];\n  xx[5] = 1.0e-9;\n  if (xx[4] > xx[5]) {\n    switch (ii[1])\n    {\n     case 0:\n     case 1:\n     case 2:\n     case 3:\n     case 4:\n     case 5:\n      {\n        return sm_ssci_recordRunTimeError(\n          \"physmod:sm:core:compiler:mechanism:mechanism:constraintViolation\",\n          \"'simulation/Plant/ TVC Physics/Staging Joint' kinematic constraints cannot be maintained. Check solver type and consistency tolerance in the Simscape Solver Configuration block. Check Simulink solver type and tolerances in Model Configuration Parameters. A kinematic singularity might be the source of this problem.\",\n          neDiagMgr);\n      }\n    }\n  }\n\n  xx[4] = xx[3] * xx[67];\n  xx[7] = cos(xx[4]);\n  xx[11] = xx[3] * xx[68];\n  xx[3] = sin(xx[11]);\n  xx[12] = xx[7] * xx[3];\n  xx[13] = xx[12] * xx[12];\n  xx[14] = sin(xx[4]);\n  xx[4] = xx[14] * xx[3];\n  xx[3] = xx[4] * xx[4];\n  xx[15] = xx[2] - xx[1] * (xx[13] + xx[3]);\n  xx[16] = - xx[58];\n  xx[17] = - xx[59];\n  xx[18] = - xx[60];\n  xx[19] = - xx[57];\n  xx[20] = xx[16];\n  xx[21] = xx[17];\n  xx[22] = xx[18];\n  xx[23] = cos(xx[11]);\n  xx[11] = xx[7] * xx[23];\n  xx[7] = xx[23] * xx[14];\n  xx[14] = - xx[7];\n  xx[23] = - xx[12];\n  xx[24] = - xx[4];\n  xx[26] = - xx[11];\n  xx[27] = xx[14];\n  xx[28] = xx[23];\n  xx[29] = xx[24];\n  pm_math_Quaternion_compose_ra(xx + 19, xx + 26, xx + 30);\n  xx[34] = xx[15] * xx[32];\n  xx[35] = xx[11] * xx[12];\n  xx[36] = xx[7] * xx[4];\n  xx[37] = xx[35] + xx[36];\n  xx[38] = xx[1] * xx[37];\n  xx[39] = xx[38] * xx[33];\n  xx[40] = xx[15] * xx[31];\n  xx[41] = xx[39] + xx[40];\n  xx[42] = xx[38] * xx[32];\n  xx[45] = xx[34];\n  xx[46] = - xx[41];\n  xx[47] = xx[42];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 45, xx + 48);\n  xx[45] = xx[1] * (xx[34] * xx[30] + xx[48]) - xx[38];\n  xx[46] = xx[1] * (xx[49] - xx[41] * xx[30]);\n  xx[47] = xx[15] + xx[1] * (xx[42] * xx[30] + xx[50]);\n  xx[34] = xx[74] * xx[74];\n  xx[41] = xx[75] * xx[75];\n  xx[42] = xx[75] * xx[76];\n  xx[43] = xx[74] * xx[77];\n  xx[48] = xx[75] * xx[77];\n  xx[49] = xx[74] * xx[76];\n  xx[50] = xx[1] * (xx[48] - xx[49]);\n  xx[84] = xx[1] * (xx[34] + xx[41]) - xx[2];\n  xx[85] = xx[1] * (xx[42] + xx[43]);\n  xx[86] = xx[50];\n  xx[51] = xx[11] * xx[4];\n  xx[53] = xx[12] * xx[7];\n  xx[87] = xx[1] * (xx[51] + xx[53]);\n  xx[88] = xx[87] * xx[32];\n  xx[89] = xx[12] * xx[4];\n  xx[90] = xx[11] * xx[7];\n  xx[91] = xx[1] * (xx[89] - xx[90]);\n  xx[92] = xx[91] * xx[33];\n  xx[93] = xx[87] * xx[31];\n  xx[94] = xx[92] + xx[93];\n  xx[95] = xx[91] * xx[32];\n  xx[96] = xx[88];\n  xx[97] = - xx[94];\n  xx[98] = xx[95];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 96, xx + 99);\n  xx[96] = xx[1] * (xx[88] * xx[30] + xx[99]) - xx[91];\n  xx[97] = xx[1] * (xx[100] - xx[94] * xx[30]);\n  xx[98] = xx[87] + xx[1] * (xx[95] * xx[30] + xx[101]);\n  xx[88] = xx[1] * (xx[36] - xx[35]);\n  xx[35] = xx[88] * xx[32];\n  xx[36] = xx[7] * xx[7];\n  xx[94] = xx[2] - xx[1] * (xx[36] + xx[13]);\n  xx[13] = xx[94] * xx[33];\n  xx[95] = xx[88] * xx[31];\n  xx[99] = xx[13] + xx[95];\n  xx[100] = xx[94] * xx[32];\n  xx[101] = xx[35];\n  xx[102] = - xx[99];\n  xx[103] = xx[100];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 101, xx + 104);\n  xx[101] = xx[1] * (xx[35] * xx[30] + xx[104]) - xx[94];\n  xx[102] = xx[1] * (xx[105] - xx[99] * xx[30]);\n  xx[103] = xx[88] + xx[1] * (xx[100] * xx[30] + xx[106]);\n  xx[35] = xx[1] * (xx[49] + xx[48]);\n  xx[99] = xx[74] * xx[75];\n  xx[100] = xx[76] * xx[77];\n  xx[104] = xx[76] * xx[76];\n  xx[105] = xx[1] * (xx[41] + xx[104]);\n  xx[106] = - xx[35];\n  xx[107] = xx[1] * (xx[99] - xx[100]);\n  xx[108] = xx[105] - xx[2];\n  xx[109] = xx[31] * xx[32];\n  xx[110] = xx[30] * xx[33];\n  xx[111] = xx[30] * xx[30];\n  xx[112] = xx[32] * xx[33];\n  xx[113] = xx[30] * xx[31];\n  xx[114] = xx[1] * (xx[109] - xx[110]);\n  xx[115] = xx[1] * (xx[111] + xx[32] * xx[32]) - xx[2];\n  xx[116] = xx[1] * (xx[112] + xx[113]);\n  xx[117] = xx[1] * (xx[42] - xx[43]);\n  xx[118] = xx[77] * xx[77];\n  xx[119] = xx[1] * (xx[118] + xx[41]);\n  xx[41] = xx[1] * (xx[99] + xx[100]);\n  xx[120] = xx[117];\n  xx[121] = xx[2] - xx[119];\n  xx[122] = xx[41];\n  xx[123] = xx[53] - xx[51];\n  xx[51] = xx[1] * xx[123];\n  xx[53] = xx[15] * xx[33];\n  xx[124] = xx[51] * xx[33];\n  xx[125] = xx[51] * xx[32];\n  xx[126] = xx[40] + xx[125];\n  xx[127] = xx[53];\n  xx[128] = xx[124];\n  xx[129] = - xx[126];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 127, xx + 130);\n  xx[127] = xx[51] + xx[1] * (xx[53] * xx[30] + xx[130]);\n  xx[128] = xx[1] * (xx[124] * xx[30] + xx[131]) - xx[15];\n  xx[129] = xx[1] * (xx[132] - xx[126] * xx[30]);\n  xx[130] = xx[117];\n  xx[131] = xx[1] * (xx[34] + xx[104]) - xx[2];\n  xx[132] = xx[1] * (xx[100] + xx[99]);\n  xx[40] = xx[2] - xx[1] * (xx[3] + xx[36]);\n  xx[3] = xx[87] * xx[33];\n  xx[36] = xx[40] * xx[33];\n  xx[53] = xx[40] * xx[32];\n  xx[117] = xx[93] + xx[53];\n  xx[133] = xx[3];\n  xx[134] = xx[36];\n  xx[135] = - xx[117];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 133, xx + 136);\n  xx[133] = xx[40] + xx[1] * (xx[3] * xx[30] + xx[136]);\n  xx[134] = xx[1] * (xx[36] * xx[30] + xx[137]) - xx[87];\n  xx[135] = xx[1] * (xx[138] - xx[117] * xx[30]);\n  xx[3] = xx[1] * (xx[90] + xx[89]);\n  xx[36] = xx[88] * xx[33];\n  xx[89] = xx[3] * xx[33];\n  xx[90] = xx[3] * xx[32];\n  xx[93] = xx[95] + xx[90];\n  xx[136] = xx[36];\n  xx[137] = xx[89];\n  xx[138] = - xx[93];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 136, xx + 139);\n  xx[136] = xx[3] + xx[1] * (xx[36] * xx[30] + xx[139]);\n  xx[137] = xx[1] * (xx[89] * xx[30] + xx[140]) - xx[88];\n  xx[138] = xx[1] * (xx[141] - xx[93] * xx[30]);\n  xx[36] = xx[1] * (xx[100] - xx[99]);\n  xx[139] = xx[35];\n  xx[140] = xx[36];\n  xx[141] = xx[2] - xx[105];\n  xx[35] = xx[31] * xx[33];\n  xx[89] = xx[30] * xx[32];\n  xx[142] = xx[1] * (xx[35] + xx[89]);\n  xx[143] = xx[1] * (xx[112] - xx[113]);\n  xx[144] = xx[1] * (xx[111] + xx[33] * xx[33]) - xx[2];\n  xx[93] = xx[1] * (xx[104] + xx[118]);\n  xx[95] = xx[1] * (xx[43] + xx[42]);\n  xx[145] = xx[93] - xx[2];\n  xx[146] = - xx[95];\n  xx[147] = xx[1] * (xx[49] - xx[48]);\n  xx[99] = xx[125] + xx[39];\n  xx[39] = xx[51] * xx[31];\n  xx[100] = xx[38] * xx[31];\n  xx[124] = - xx[99];\n  xx[125] = xx[39];\n  xx[126] = xx[100];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 124, xx + 148);\n  xx[124] = xx[1] * (xx[148] - xx[99] * xx[30]);\n  xx[125] = xx[38] + xx[1] * (xx[39] * xx[30] + xx[149]);\n  xx[126] = xx[1] * (xx[100] * xx[30] + xx[150]) - xx[51];\n  xx[148] = xx[1] * (xx[48] + xx[49]);\n  xx[149] = xx[36];\n  xx[150] = xx[1] * (xx[34] + xx[118]) - xx[2];\n  xx[34] = xx[53] + xx[92];\n  xx[36] = xx[40] * xx[31];\n  xx[38] = xx[91] * xx[31];\n  xx[151] = - xx[34];\n  xx[152] = xx[36];\n  xx[153] = xx[38];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 151, xx + 154);\n  xx[151] = xx[1] * (xx[154] - xx[34] * xx[30]);\n  xx[152] = xx[91] + xx[1] * (xx[36] * xx[30] + xx[155]);\n  xx[153] = xx[1] * (xx[38] * xx[30] + xx[156]) - xx[40];\n  xx[34] = xx[90] + xx[13];\n  xx[13] = xx[3] * xx[31];\n  xx[36] = xx[94] * xx[31];\n  xx[90] = - xx[34];\n  xx[91] = xx[13];\n  xx[92] = xx[36];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 90, xx + 154);\n  xx[90] = xx[1] * (xx[154] - xx[34] * xx[30]);\n  xx[91] = xx[94] + xx[1] * (xx[13] * xx[30] + xx[155]);\n  xx[92] = xx[1] * (xx[36] * xx[30] + xx[156]) - xx[3];\n  xx[154] = xx[1] * (xx[43] - xx[42]);\n  xx[155] = xx[119] - xx[2];\n  xx[156] = - xx[41];\n  xx[41] = xx[1] * (xx[111] + xx[31] * xx[31]) - xx[2];\n  xx[42] = xx[1] * (xx[109] + xx[110]);\n  xx[43] = xx[1] * (xx[35] - xx[89]);\n  xx[34] = xx[2] - xx[93];\n  xx[35] = xx[95];\n  xx[36] = xx[50];\n  xx[13] = xx[10] * xx[15];\n  xx[38] = xx[13] * xx[33];\n  xx[39] = xx[10] * xx[51];\n  xx[48] = xx[39] * xx[33];\n  xx[49] = xx[13] * xx[31] + xx[39] * xx[32];\n  xx[93] = - xx[38];\n  xx[94] = - xx[48];\n  xx[95] = xx[49];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 93, xx + 109);\n  xx[50] = xx[44] * xx[7];\n  xx[51] = xx[44] * xx[12];\n  xx[53] = xx[1] * (xx[50] * xx[11] - xx[51] * xx[4]);\n  xx[89] = xx[53] * xx[59];\n  xx[93] = xx[1] * (xx[50] * xx[7] + xx[51] * xx[12]);\n  xx[94] = xx[93] - xx[44] - xx[2];\n  xx[95] = xx[94] * xx[60];\n  xx[99] = xx[89] + xx[95];\n  xx[100] = xx[53] * xx[58];\n  xx[104] = xx[94] * xx[58];\n  xx[117] = - xx[99];\n  xx[118] = xx[100];\n  xx[119] = xx[104];\n  pm_math_Vector3_cross_ra(xx + 16, xx + 117, xx + 157);\n  xx[105] = xx[57] * xx[60];\n  xx[112] = xx[58] * xx[59];\n  xx[113] = xx[10] * xx[87];\n  xx[87] = xx[113] * xx[33];\n  xx[117] = xx[10] * xx[40];\n  xx[40] = xx[117] * xx[33];\n  xx[118] = xx[113] * xx[31] + xx[117] * xx[32];\n  xx[160] = - xx[87];\n  xx[161] = - xx[40];\n  xx[162] = xx[118];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 160, xx + 163);\n  xx[119] = xx[1] * (xx[51] * xx[11] + xx[50] * xx[4]);\n  xx[50] = xx[119] * xx[59];\n  xx[51] = xx[119] * xx[58];\n  xx[160] = xx[95] - xx[51];\n  xx[95] = xx[94] * xx[59];\n  xx[166] = - xx[50];\n  xx[167] = - xx[160];\n  xx[168] = xx[95];\n  pm_math_Vector3_cross_ra(xx + 16, xx + 166, xx + 169);\n  xx[161] = xx[60] * xx[60];\n  xx[162] = xx[10] * xx[88];\n  xx[88] = xx[162] * xx[33];\n  xx[166] = xx[10] * xx[3];\n  xx[3] = xx[166] * xx[33];\n  xx[167] = xx[162] * xx[31] + xx[166] * xx[32];\n  xx[172] = - xx[88];\n  xx[173] = - xx[3];\n  xx[174] = xx[167];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 172, xx + 175);\n  xx[168] = xx[119] * xx[60];\n  xx[172] = xx[53] * xx[60];\n  xx[173] = xx[89] - xx[51];\n  xx[178] = - xx[168];\n  xx[179] = xx[172];\n  xx[180] = - xx[173];\n  pm_math_Vector3_cross_ra(xx + 16, xx + 178, xx + 181);\n  xx[51] = xx[52] * xx[77];\n  xx[89] = xx[51] * xx[74];\n  xx[174] = xx[52] * xx[75];\n  xx[178] = xx[52] * xx[76];\n  xx[179] = xx[51] * xx[77];\n  xx[184] = xx[0];\n  xx[185] = xx[0];\n  xx[186] = xx[0];\n  xx[187] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 45, xx + 84);\n  xx[188] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 96, xx + 84);\n  xx[189] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 101, xx + 84);\n  xx[190] = xx[0];\n  xx[191] = xx[0];\n  xx[192] = xx[0];\n  xx[193] = xx[0];\n  xx[194] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 106, xx + 114);\n  xx[195] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 120, xx + 114);\n  xx[196] = xx[0];\n  xx[197] = xx[0];\n  xx[198] = xx[0];\n  xx[199] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 127, xx + 130);\n  xx[200] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 133, xx + 130);\n  xx[201] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 136, xx + 130);\n  xx[202] = xx[0];\n  xx[203] = xx[0];\n  xx[204] = xx[0];\n  xx[205] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 139, xx + 142);\n  xx[206] = xx[0];\n  xx[207] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 145, xx + 142);\n  xx[208] = xx[0];\n  xx[209] = xx[0];\n  xx[210] = xx[0];\n  xx[211] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 124, xx + 148);\n  xx[212] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 151, xx + 148);\n  xx[213] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 90, xx + 148);\n  xx[214] = xx[0];\n  xx[215] = xx[0];\n  xx[216] = xx[0];\n  xx[217] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 154, xx + 41);\n  xx[218] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 34, xx + 41);\n  xx[219] = xx[0];\n  xx[220] = xx[9];\n  xx[221] = xx[0];\n  xx[222] = xx[0];\n  xx[223] = bb[0] ? xx[0] : - (xx[1] * (xx[109] - xx[38] * xx[30]) - xx[39] +\n    xx[1] * (xx[99] * xx[57] + xx[157]) + xx[1] * (xx[105] - xx[112]));\n  xx[224] = bb[0] ? xx[0] : - (xx[1] * (xx[163] - xx[87] * xx[30]) - xx[117] +\n    xx[94] + xx[1] * (xx[169] + xx[50] * xx[57]) - xx[1] * (xx[59] * xx[59] +\n    xx[161]) + xx[2]);\n  xx[225] = bb[0] ? xx[0] : - (xx[1] * (xx[175] - xx[88] * xx[30]) - xx[166] +\n    xx[1] * (xx[181] + xx[168] * xx[57]) - xx[53]);\n  xx[226] = xx[6];\n  xx[227] = xx[0];\n  xx[228] = xx[0];\n  xx[229] = bb[0] ? xx[0] : xx[1] * (xx[89] - xx[174] * xx[76]);\n  xx[230] = bb[0] ? xx[0] : xx[52] - xx[1] * (xx[178] * xx[76] + xx[179]);\n  xx[231] = xx[0];\n  xx[232] = xx[0];\n  xx[233] = xx[9];\n  xx[234] = xx[0];\n  xx[235] = bb[0] ? xx[0] : - (xx[1] * (xx[110] - xx[48] * xx[30]) + xx[1] *\n    (xx[158] - xx[100] * xx[57]) + xx[1] * (xx[161] + xx[58] * xx[58]) - xx[94]\n    + xx[13] - xx[2]);\n  xx[236] = bb[0] ? xx[0] : - (xx[1] * (xx[164] - xx[40] * xx[30]) + xx[113] +\n    xx[1] * (xx[160] * xx[57] + xx[170]) + xx[1] * (xx[105] + xx[112]));\n  xx[237] = bb[0] ? xx[0] : - (xx[1] * (xx[176] - xx[3] * xx[30]) + xx[162] +\n    xx[1] * (xx[182] - xx[172] * xx[57]) - xx[119]);\n  xx[238] = xx[0];\n  xx[239] = xx[6];\n  xx[240] = xx[0];\n  xx[241] = bb[0] ? xx[0] : xx[1] * (xx[179] + xx[174] * xx[75]) - xx[52];\n  xx[242] = bb[0] ? xx[0] : xx[1] * (xx[89] + xx[178] * xx[75]);\n  xx[243] = xx[0];\n  xx[244] = xx[0];\n  xx[245] = xx[0];\n  xx[246] = xx[9];\n  xx[247] = bb[0] ? xx[0] : - (xx[1] * (xx[111] + xx[49] * xx[30]) + xx[53] +\n    xx[1] * (xx[159] - xx[104] * xx[57]) - xx[1] * (xx[57] * xx[58] + xx[59] *\n    xx[60]));\n  xx[248] = bb[0] ? xx[0] : - (xx[1] * (xx[165] + xx[118] * xx[30]) + xx[1] *\n    (xx[171] - xx[95] * xx[57]) + xx[119] + xx[1] * (xx[58] * xx[60] - xx[57] *\n    xx[59]));\n  xx[249] = bb[0] ? xx[0] : - (xx[1] * (xx[177] + xx[167] * xx[30]) + xx[1] *\n    (xx[173] * xx[57] + xx[183]));\n  xx[250] = xx[0];\n  xx[251] = xx[0];\n  xx[252] = xx[6];\n  xx[253] = bb[0] ? xx[0] : - (xx[1] * (xx[174] * xx[74] + xx[51] * xx[76]));\n  xx[254] = bb[0] ? xx[0] : xx[1] * (xx[51] * xx[75] - xx[178] * xx[74]);\n  xx[255] = xx[0];\n  xx[34] = - xx[75];\n  xx[35] = - xx[76];\n  xx[36] = - xx[77];\n  xx[0] = xx[76] * xx[82];\n  xx[2] = xx[77] * xx[83];\n  xx[3] = xx[0] + xx[2];\n  xx[6] = xx[75] * xx[82];\n  xx[9] = xx[75] * xx[83];\n  xx[38] = xx[3];\n  xx[39] = - xx[6];\n  xx[40] = - xx[9];\n  pm_math_Vector3_cross_ra(xx + 34, xx + 38, xx + 45);\n  xx[38] = xx[1] * (xx[45] - xx[3] * xx[74]);\n  xx[39] = xx[83] + xx[1] * (xx[6] * xx[74] + xx[46]);\n  xx[40] = xx[1] * (xx[9] * xx[74] + xx[47]) - xx[82];\n  pm_math_Quaternion_inverseXform_ra(xx + 26, xx + 64, xx + 45);\n  xx[3] = xx[15] * xx[69];\n  xx[6] = xx[45] + xx[3];\n  xx[9] = xx[6] * xx[32];\n  xx[13] = xx[1] * xx[37] * xx[69];\n  xx[15] = xx[47] + xx[13];\n  xx[37] = xx[15] * xx[33];\n  xx[48] = xx[6] * xx[31];\n  xx[49] = xx[37] + xx[48];\n  xx[50] = xx[15] * xx[32];\n  xx[87] = xx[9];\n  xx[88] = - xx[49];\n  xx[89] = xx[50];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 87, xx + 90);\n  xx[87] = xx[1] * (xx[9] * xx[30] + xx[90]) - xx[15];\n  xx[88] = xx[1] * (xx[91] - xx[49] * xx[30]);\n  xx[89] = xx[6] + xx[1] * (xx[50] * xx[30] + xx[92]);\n  xx[9] = xx[76] * xx[81];\n  xx[49] = xx[75] * xx[81];\n  xx[50] = xx[2] + xx[49];\n  xx[2] = xx[76] * xx[83];\n  xx[90] = - xx[9];\n  xx[91] = xx[50];\n  xx[92] = - xx[2];\n  pm_math_Vector3_cross_ra(xx + 34, xx + 90, xx + 95);\n  xx[90] = xx[1] * (xx[9] * xx[74] + xx[95]) - xx[83];\n  xx[91] = xx[1] * (xx[96] - xx[50] * xx[74]);\n  xx[92] = xx[81] + xx[1] * (xx[2] * xx[74] + xx[97]);\n  xx[2] = xx[1] * xx[123] * xx[69] + xx[70];\n  xx[9] = xx[46] + xx[2];\n  xx[45] = xx[6] * xx[33];\n  xx[46] = xx[9] * xx[33];\n  xx[47] = xx[9] * xx[32];\n  xx[50] = xx[48] + xx[47];\n  xx[95] = xx[45];\n  xx[96] = xx[46];\n  xx[97] = - xx[50];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 95, xx + 98);\n  xx[95] = xx[9] + xx[1] * (xx[45] * xx[30] + xx[98]);\n  xx[96] = xx[1] * (xx[46] * xx[30] + xx[99]) - xx[6];\n  xx[97] = xx[1] * (xx[100] - xx[50] * xx[30]);\n  xx[45] = xx[77] * xx[81];\n  xx[46] = xx[77] * xx[82];\n  xx[48] = xx[49] + xx[0];\n  xx[49] = - xx[45];\n  xx[50] = - xx[46];\n  xx[51] = xx[48];\n  pm_math_Vector3_cross_ra(xx + 34, xx + 49, xx + 98);\n  xx[49] = xx[82] + xx[1] * (xx[45] * xx[74] + xx[98]);\n  xx[50] = xx[1] * (xx[46] * xx[74] + xx[99]) - xx[81];\n  xx[51] = xx[1] * (xx[100] - xx[48] * xx[74]);\n  xx[0] = xx[47] + xx[37];\n  xx[37] = xx[9] * xx[31];\n  xx[45] = xx[15] * xx[31];\n  xx[46] = - xx[0];\n  xx[47] = xx[37];\n  xx[48] = xx[45];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 46, xx + 98);\n  xx[46] = xx[1] * (xx[98] - xx[0] * xx[30]);\n  xx[47] = xx[15] + xx[1] * (xx[37] * xx[30] + xx[99]);\n  xx[48] = xx[1] * (xx[45] * xx[30] + xx[100]) - xx[9];\n  xx[0] = xx[52] * xx[82];\n  xx[15] = xx[52] * xx[81];\n  xx[37] = xx[15] * xx[77];\n  xx[45] = xx[0] * xx[77];\n  xx[98] = xx[15] * xx[75] + xx[0] * xx[76];\n  xx[99] = - xx[37];\n  xx[100] = - xx[45];\n  xx[101] = xx[98];\n  pm_math_Vector3_cross_ra(xx + 34, xx + 99, xx + 102);\n  xx[99] = xx[10] * xx[6];\n  xx[6] = xx[99] * xx[33];\n  xx[100] = xx[10] * xx[9];\n  xx[9] = xx[100] * xx[33];\n  xx[101] = xx[99] * xx[31] + xx[100] * xx[32];\n  xx[105] = - xx[6];\n  xx[106] = - xx[9];\n  xx[107] = xx[101];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 105, xx + 108);\n  xx[105] = xx[60] * xx[64];\n  xx[106] = xx[60] * xx[65];\n  xx[107] = xx[58] * xx[64] + xx[59] * xx[65];\n  xx[111] = - xx[105];\n  xx[112] = - xx[106];\n  xx[113] = xx[107];\n  pm_math_Vector3_cross_ra(xx + 16, xx + 111, xx + 120);\n  xx[111] = xx[14];\n  xx[112] = xx[23];\n  xx[113] = xx[24];\n  xx[14] = xx[44] * xx[3];\n  xx[23] = xx[14] * xx[4];\n  xx[24] = xx[44] * xx[2];\n  xx[44] = xx[24] * xx[4];\n  xx[4] = xx[14] * xx[7] + xx[24] * xx[12];\n  xx[123] = xx[23];\n  xx[124] = xx[44];\n  xx[125] = - xx[4];\n  pm_math_Vector3_cross_ra(xx + 111, xx + 123, xx + 126);\n  xx[7] = xx[1] * (xx[126] - xx[23] * xx[11]) - xx[24];\n  xx[12] = - xx[119];\n  xx[111] = xx[12];\n  xx[112] = xx[53];\n  xx[113] = xx[94];\n  pm_math_Vector3_cross_ra(xx + 64, xx + 111, xx + 117);\n  xx[23] = xx[1] * (xx[127] - xx[44] * xx[11]) + xx[14];\n  xx[14] = xx[1] * (xx[128] + xx[11] * xx[4]);\n  xx[111] = xx[7] + xx[117];\n  xx[112] = xx[23] + xx[118];\n  xx[113] = xx[14] + xx[119];\n  pm_math_Quaternion_xform_ra(xx + 19, xx + 111, xx + 117);\n  xx[123] = pm_math_Vector3_dot_ra(xx + 38, xx + 114) + pm_math_Vector3_dot_ra\n    (xx + 87, xx + 84);\n  xx[124] = pm_math_Vector3_dot_ra(xx + 90, xx + 142) + pm_math_Vector3_dot_ra\n    (xx + 95, xx + 130);\n  xx[125] = pm_math_Vector3_dot_ra(xx + 49, xx + 41) + pm_math_Vector3_dot_ra(xx\n    + 46, xx + 148);\n  xx[126] = xx[0] + xx[1] * (xx[37] * xx[74] + xx[102]) + xx[78] - (xx[1] * (xx\n    [108] - xx[6] * xx[30]) - xx[100] + xx[65] + xx[1] * (xx[105] * xx[57] + xx\n    [120]) + xx[61] + xx[117]);\n  xx[127] = xx[1] * (xx[45] * xx[74] + xx[103]) - xx[15] + xx[79] - (xx[1] *\n    (xx[109] - xx[9] * xx[30]) + xx[99] + xx[1] * (xx[106] * xx[57] + xx[121]) -\n    xx[64] + xx[62] + xx[118]);\n  xx[128] = xx[1] * (xx[104] - xx[98] * xx[74]) + xx[80] - (xx[1] * (xx[110] +\n    xx[101] * xx[30]) + xx[1] * (xx[122] - xx[107] * xx[57]) + xx[63] + xx[119]);\n  zeroMajor(1, 6, ii + 0, xx + 123);\n  xx[44] = - xx[123];\n  xx[45] = - xx[124];\n  xx[46] = - xx[125];\n  xx[47] = - xx[126];\n  xx[48] = - xx[127];\n  xx[49] = - xx[128];\n  memcpy(xx + 256, xx + 184, 72 * sizeof(double));\n  factorAndSolveWide(6, 12, xx + 256, xx + 87, xx + 106, ii + 1, xx + 44, xx[8],\n                     xx + 94);\n  xx[0] = xx[61] + xx[94];\n  xx[4] = xx[62] + xx[95];\n  xx[6] = xx[63] + xx[96];\n  xx[8] = xx[64] + xx[97];\n  xx[9] = xx[65] + xx[98];\n  xx[11] = xx[66] + xx[99];\n  xx[15] = xx[78] + xx[100];\n  xx[24] = xx[79] + xx[101];\n  xx[37] = xx[80] + xx[102];\n  xx[38] = xx[81] + xx[103];\n  xx[39] = xx[82] + xx[104];\n  xx[40] = xx[83] + xx[105];\n  xx[151] = xx[54];\n  xx[152] = xx[55];\n  xx[153] = xx[56];\n  xx[154] = xx[57];\n  xx[155] = xx[58];\n  xx[156] = xx[59];\n  xx[157] = xx[60];\n  xx[158] = xx[0];\n  xx[159] = xx[4];\n  xx[160] = xx[6];\n  xx[161] = xx[8];\n  xx[162] = xx[9];\n  xx[163] = xx[11];\n  xx[164] = xx[67];\n  xx[165] = xx[68];\n  xx[166] = xx[69];\n  xx[167] = xx[70];\n  xx[168] = xx[71];\n  xx[169] = xx[72];\n  xx[170] = xx[73];\n  xx[171] = xx[74];\n  xx[172] = xx[75];\n  xx[173] = xx[76];\n  xx[174] = xx[77];\n  xx[175] = xx[15];\n  xx[176] = xx[24];\n  xx[177] = xx[37];\n  xx[178] = xx[38];\n  xx[179] = xx[39];\n  xx[180] = xx[40];\n  xx[44] = xx[39] * xx[76];\n  xx[45] = xx[40] * xx[77];\n  xx[46] = xx[44] + xx[45];\n  xx[47] = xx[39] * xx[75];\n  xx[48] = xx[40] * xx[75];\n  xx[49] = xx[46];\n  xx[50] = - xx[47];\n  xx[51] = - xx[48];\n  pm_math_Vector3_cross_ra(xx + 34, xx + 49, xx + 54);\n  xx[49] = xx[1] * (xx[54] - xx[46] * xx[74]);\n  xx[50] = xx[40] + xx[1] * (xx[47] * xx[74] + xx[55]);\n  xx[51] = xx[1] * (xx[48] * xx[74] + xx[56]) - xx[39];\n  xx[46] = xx[8];\n  xx[47] = xx[9];\n  xx[48] = xx[11];\n  pm_math_Quaternion_inverseXform_ra(xx + 26, xx + 46, xx + 54);\n  xx[11] = xx[54] + xx[3];\n  xx[3] = xx[11] * xx[32];\n  xx[26] = xx[56] + xx[13];\n  xx[13] = xx[26] * xx[33];\n  xx[27] = xx[11] * xx[31];\n  xx[28] = xx[13] + xx[27];\n  xx[29] = xx[26] * xx[32];\n  xx[61] = xx[3];\n  xx[62] = - xx[28];\n  xx[63] = xx[29];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 61, xx + 64);\n  xx[61] = xx[1] * (xx[3] * xx[30] + xx[64]) - xx[26];\n  xx[62] = xx[1] * (xx[65] - xx[28] * xx[30]);\n  xx[63] = xx[11] + xx[1] * (xx[29] * xx[30] + xx[66]);\n  xx[3] = xx[38] * xx[76];\n  xx[28] = xx[38] * xx[75];\n  xx[29] = xx[45] + xx[28];\n  xx[45] = xx[40] * xx[76];\n  xx[64] = - xx[3];\n  xx[65] = xx[29];\n  xx[66] = - xx[45];\n  pm_math_Vector3_cross_ra(xx + 34, xx + 64, xx + 67);\n  xx[64] = xx[1] * (xx[3] * xx[74] + xx[67]) - xx[40];\n  xx[65] = xx[1] * (xx[68] - xx[29] * xx[74]);\n  xx[66] = xx[38] + xx[1] * (xx[45] * xx[74] + xx[69]);\n  xx[3] = xx[55] + xx[2];\n  xx[2] = xx[11] * xx[33];\n  xx[29] = xx[3] * xx[33];\n  xx[40] = xx[3] * xx[32];\n  xx[45] = xx[27] + xx[40];\n  xx[54] = xx[2];\n  xx[55] = xx[29];\n  xx[56] = - xx[45];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 54, xx + 67);\n  xx[54] = xx[3] + xx[1] * (xx[2] * xx[30] + xx[67]);\n  xx[55] = xx[1] * (xx[29] * xx[30] + xx[68]) - xx[11];\n  xx[56] = xx[1] * (xx[69] - xx[45] * xx[30]);\n  xx[2] = xx[38] * xx[77];\n  xx[27] = xx[39] * xx[77];\n  xx[29] = xx[28] + xx[44];\n  xx[67] = - xx[2];\n  xx[68] = - xx[27];\n  xx[69] = xx[29];\n  pm_math_Vector3_cross_ra(xx + 34, xx + 67, xx + 70);\n  xx[67] = xx[39] + xx[1] * (xx[2] * xx[74] + xx[70]);\n  xx[68] = xx[1] * (xx[27] * xx[74] + xx[71]) - xx[38];\n  xx[69] = xx[1] * (xx[72] - xx[29] * xx[74]);\n  xx[2] = xx[40] + xx[13];\n  xx[13] = xx[3] * xx[31];\n  xx[27] = xx[26] * xx[31];\n  xx[70] = - xx[2];\n  xx[71] = xx[13];\n  xx[72] = xx[27];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 70, xx + 78);\n  xx[70] = xx[1] * (xx[78] - xx[2] * xx[30]);\n  xx[71] = xx[26] + xx[1] * (xx[13] * xx[30] + xx[79]);\n  xx[72] = xx[1] * (xx[27] * xx[30] + xx[80]) - xx[3];\n  xx[2] = xx[52] * xx[39];\n  xx[13] = xx[52] * xx[38];\n  xx[26] = xx[13] * xx[77];\n  xx[27] = xx[2] * xx[77];\n  xx[28] = xx[13] * xx[75] + xx[2] * xx[76];\n  xx[38] = - xx[26];\n  xx[39] = - xx[27];\n  xx[40] = xx[28];\n  pm_math_Vector3_cross_ra(xx + 34, xx + 38, xx + 75);\n  xx[29] = xx[10] * xx[11];\n  xx[11] = xx[29] * xx[33];\n  xx[34] = xx[10] * xx[3];\n  xx[3] = xx[34] * xx[33];\n  xx[10] = xx[29] * xx[31] + xx[34] * xx[32];\n  xx[38] = - xx[11];\n  xx[39] = - xx[3];\n  xx[40] = xx[10];\n  pm_math_Vector3_cross_ra(xx + 31, xx + 38, xx + 78);\n  xx[31] = xx[8] * xx[60];\n  xx[32] = xx[9] * xx[60];\n  xx[33] = xx[8] * xx[58] + xx[9] * xx[59];\n  xx[38] = - xx[31];\n  xx[39] = - xx[32];\n  xx[40] = xx[33];\n  pm_math_Vector3_cross_ra(xx + 16, xx + 38, xx + 58);\n  xx[16] = xx[12];\n  xx[17] = xx[53];\n  xx[18] = xx[93] - xx[25];\n  pm_math_Vector3_cross_ra(xx + 46, xx + 16, xx + 38);\n  xx[16] = xx[7] + xx[38];\n  xx[17] = xx[23] + xx[39];\n  xx[18] = xx[14] + xx[40];\n  pm_math_Quaternion_xform_ra(xx + 19, xx + 16, xx + 38);\n  xx[16] = pm_math_Vector3_dot_ra(xx + 49, xx + 114) + pm_math_Vector3_dot_ra(xx\n    + 61, xx + 84);\n  xx[17] = pm_math_Vector3_dot_ra(xx + 64, xx + 142) + pm_math_Vector3_dot_ra(xx\n    + 54, xx + 130);\n  xx[18] = pm_math_Vector3_dot_ra(xx + 67, xx + 41) + pm_math_Vector3_dot_ra(xx\n    + 70, xx + 148);\n  xx[19] = xx[2] + xx[1] * (xx[26] * xx[74] + xx[75]) + xx[15] - (xx[1] * (xx[78]\n    - xx[11] * xx[30]) - xx[34] + xx[9] + xx[1] * (xx[31] * xx[57] + xx[58]) +\n    xx[0] + xx[38]);\n  xx[20] = xx[1] * (xx[27] * xx[74] + xx[76]) - xx[13] + xx[24] - (xx[1] * (xx\n    [79] - xx[3] * xx[30]) + xx[29] + xx[1] * (xx[32] * xx[57] + xx[59]) - xx[8]\n    + xx[4] + xx[39]);\n  xx[21] = xx[1] * (xx[77] - xx[28] * xx[74]) + xx[37] - (xx[1] * (xx[80] + xx\n    [10] * xx[30]) + xx[1] * (xx[60] - xx[33] * xx[57]) + xx[6] + xx[40]);\n  zeroMajor(1, 6, ii + 0, xx + 16);\n  xx[6] = fabs(xx[16]);\n  xx[7] = fabs(xx[17]);\n  xx[8] = fabs(xx[18]);\n  xx[9] = fabs(xx[19]);\n  xx[10] = fabs(xx[20]);\n  xx[11] = fabs(xx[21]);\n  ii[0] = 6;\n\n  {\n    int ll;\n    for (ll = 7; ll < 12; ++ll)\n      if (xx[ll] > xx[ii[0]])\n        ii[0] = ll;\n  }\n\n  ii[0] -= 6;\n  xx[0] = xx[6 + (ii[0])];\n  if (xx[0] > xx[5]) {\n    switch (ii[0])\n    {\n     case 0:\n     case 1:\n     case 2:\n     case 3:\n     case 4:\n     case 5:\n      {\n        return sm_ssci_recordRunTimeError(\n          \"physmod:sm:core:compiler:mechanism:mechanism:constraintViolation\",\n          \"'simulation/Plant/ TVC Physics/Staging Joint' kinematic constraints cannot be maintained. Check solver type and consistency tolerance in the Simscape Solver Configuration block. Check Simulink solver type and tolerances in Model Configuration Parameters. A kinematic singularity might be the source of this problem.\",\n          neDiagMgr);\n      }\n    }\n  }\n\n  state[0] = xx[151];\n  state[1] = xx[152];\n  state[2] = xx[153];\n  state[3] = xx[154];\n  state[4] = xx[155];\n  state[5] = xx[156];\n  state[6] = xx[157];\n  state[7] = xx[158];\n  state[8] = xx[159];\n  state[9] = xx[160];\n  state[10] = xx[161];\n  state[11] = xx[162];\n  state[12] = xx[163];\n  state[13] = xx[164];\n  state[14] = xx[165];\n  state[15] = xx[166];\n  state[16] = xx[167];\n  state[17] = xx[168];\n  state[18] = xx[169];\n  state[19] = xx[170];\n  state[20] = xx[171];\n  state[21] = xx[172];\n  state[22] = xx[173];\n  state[23] = xx[174];\n  state[24] = xx[175];\n  state[25] = xx[176];\n  state[26] = xx[177];\n  state[27] = xx[178];\n  state[28] = xx[179];\n  state[29] = xx[180];\n  return NULL;\n}\n\nvoid simulation_b048d748_1_computeConstraintError(const void *mech, const\n  RuntimeDerivedValuesBundle *rtdv, const double *state, const int *modeVector,\n  double *error)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  int ii[1];\n  double xx[44];\n  (void) mech;\n  (void) rtdvd;\n  (void) rtdvi;\n  ii[0] = modeVector[0] == -1 ? 0 : 1;\n  xx[0] = 2.0;\n  xx[1] = state[20] * state[20];\n  xx[2] = 1.0;\n  xx[3] = state[21] * state[22];\n  xx[4] = state[20] * state[23];\n  xx[5] = state[21] * state[23];\n  xx[6] = state[20] * state[22];\n  xx[7] = xx[0] * (xx[1] + state[21] * state[21]) - xx[2];\n  xx[8] = xx[0] * (xx[3] + xx[4]);\n  xx[9] = xx[0] * (xx[5] - xx[6]);\n  xx[10] = - state[3];\n  xx[11] = - state[4];\n  xx[12] = - state[5];\n  xx[13] = - state[6];\n  xx[14] = 0.5;\n  xx[15] = xx[14] * state[13];\n  xx[16] = cos(xx[15]);\n  xx[17] = xx[14] * state[14];\n  xx[14] = cos(xx[17]);\n  xx[18] = xx[16] * xx[14];\n  xx[19] = sin(xx[15]);\n  xx[15] = xx[14] * xx[19];\n  xx[14] = sin(xx[17]);\n  xx[17] = xx[16] * xx[14];\n  xx[16] = xx[19] * xx[14];\n  xx[19] = - xx[18];\n  xx[20] = - xx[15];\n  xx[21] = - xx[17];\n  xx[22] = - xx[16];\n  pm_math_Quaternion_compose_ra(xx + 10, xx + 19, xx + 23);\n  xx[14] = xx[24] * xx[25];\n  xx[19] = xx[23] * xx[26];\n  xx[20] = xx[23] * xx[23];\n  xx[21] = xx[25] * xx[26];\n  xx[22] = xx[23] * xx[24];\n  xx[27] = xx[0] * (xx[14] - xx[19]);\n  xx[28] = xx[0] * (xx[20] + xx[25] * xx[25]) - xx[2];\n  xx[29] = xx[0] * (xx[21] + xx[22]);\n  xx[30] = state[22] * state[23];\n  xx[31] = state[20] * state[21];\n  xx[32] = xx[0] * (xx[3] - xx[4]);\n  xx[33] = xx[0] * (xx[1] + state[22] * state[22]) - xx[2];\n  xx[34] = xx[0] * (xx[30] + xx[31]);\n  xx[3] = xx[24] * xx[26];\n  xx[4] = xx[23] * xx[25];\n  xx[35] = xx[0] * (xx[3] + xx[4]);\n  xx[36] = xx[0] * (xx[21] - xx[22]);\n  xx[37] = xx[0] * (xx[20] + xx[26] * xx[26]) - xx[2];\n  xx[38] = xx[0] * (xx[5] + xx[6]);\n  xx[39] = xx[0] * (xx[30] - xx[31]);\n  xx[40] = xx[0] * (xx[1] + state[23] * state[23]) - xx[2];\n  xx[41] = xx[0] * (xx[20] + xx[24] * xx[24]) - xx[2];\n  xx[42] = xx[0] * (xx[14] + xx[19]);\n  xx[43] = xx[0] * (xx[3] - xx[4]);\n  xx[1] = 0.0225;\n  xx[2] = xx[1] * state[22];\n  xx[3] = xx[1] * state[21];\n  xx[1] = 0.04499999999999999;\n  xx[4] = xx[1] * xx[17];\n  xx[5] = xx[1] * xx[15];\n  xx[19] = - (xx[0] * (xx[4] * xx[18] + xx[5] * xx[16]));\n  xx[20] = xx[0] * (xx[5] * xx[18] - xx[4] * xx[16]);\n  xx[21] = xx[0] * (xx[5] * xx[15] + xx[4] * xx[17]) - 1.045;\n  pm_math_Quaternion_xform_ra(xx + 10, xx + 19, xx + 4);\n  xx[1] = 0.04500000000000001;\n  xx[10] = xx[1] * xx[25];\n  xx[11] = xx[1] * xx[24];\n  xx[12] = pm_math_Vector3_dot_ra(xx + 7, xx + 27);\n  xx[13] = pm_math_Vector3_dot_ra(xx + 32, xx + 35);\n  xx[14] = pm_math_Vector3_dot_ra(xx + 38, xx + 41);\n  xx[15] = xx[0] * (xx[2] * state[20] + xx[3] * state[23]) + state[17] - (xx[4]\n    + state[0] + xx[0] * (state[3] * state[5] + state[4] * state[6]) - xx[0] *\n    (xx[10] * xx[23] + xx[11] * xx[26]));\n  xx[16] = xx[0] * (xx[2] * state[23] - xx[3] * state[20]) + state[18] - (xx[0] *\n    (xx[11] * xx[23] - xx[10] * xx[26]) + xx[5] + state[1] - xx[0] * (state[3] *\n    state[4] - state[5] * state[6]));\n  xx[17] = state[19] - xx[0] * (xx[3] * state[21] + xx[2] * state[22]) - (xx[6]\n    + state[2] - xx[0] * (state[4] * state[4] + state[5] * state[5]) + xx[0] *\n    (xx[11] * xx[24] + xx[10] * xx[25])) - 0.9325;\n  zeroMajor(1, 6, ii + 0, xx + 12);\n  error[0] = xx[12];\n  error[1] = xx[13];\n  error[2] = xx[14];\n  error[3] = xx[15];\n  error[4] = xx[16];\n  error[5] = xx[17];\n}\n\nvoid simulation_b048d748_1_resetModeVector(const void *mech, int *modeVector)\n{\n  (void) mech;\n  modeVector[0] = 0;\n}\n\nboolean_T simulation_b048d748_1_hasJointDisToNormModeChange(const void *mech,\n  const int *prevModeVector, const int *modeVector)\n{\n  (void) mech;\n  return prevModeVector[0] == -1 && modeVector[0] == 0;\n}\n\nPmfMessageId simulation_b048d748_1_performJointDisToNormModeChange(const void\n  *mech, const RuntimeDerivedValuesBundle *rtdv, const int *eqnEnableFlags,\n  const int *prevModeVector, const int *modeVector, const double *input, double *\n  state, void *neDiagMgr0)\n{\n  const double *rtdvd = rtdv->mDoubles.mValues;\n  const int *rtdvi = rtdv->mInts.mValues;\n  NeuDiagnosticManager *neDiagMgr = (NeuDiagnosticManager *) neDiagMgr0;\n  boolean_T bb[2];\n  int ii[15];\n  double xx[401];\n  (void) mech;\n  (void) rtdvd;\n  (void) rtdvi;\n  (void) eqnEnableFlags;\n  (void) input;\n  (void) neDiagMgr;\n  xx[0] = 0.0;\n  bb[0] = modeVector[0] == -1;\n  xx[1] = 2.0;\n  xx[2] = 1.0;\n  xx[3] = 0.5;\n  xx[4] = xx[3] * state[13];\n  xx[5] = cos(xx[4]);\n  xx[6] = xx[3] * state[14];\n  xx[7] = sin(xx[6]);\n  xx[8] = xx[5] * xx[7];\n  xx[9] = xx[8] * xx[8];\n  xx[10] = sin(xx[4]);\n  xx[4] = xx[10] * xx[7];\n  xx[11] = xx[4] * xx[4];\n  xx[12] = xx[2] - xx[1] * (xx[9] + xx[11]);\n  xx[13] = sqrt(state[3] * state[3] + state[4] * state[4] + state[5] * state[5]\n                + state[6] * state[6]);\n  xx[14] = state[3] / xx[13];\n  xx[15] = state[4] / xx[13];\n  xx[16] = - xx[15];\n  xx[17] = state[5] / xx[13];\n  xx[18] = - xx[17];\n  xx[19] = state[6] / xx[13];\n  xx[13] = - xx[19];\n  xx[20] = - xx[14];\n  xx[21] = xx[16];\n  xx[22] = xx[18];\n  xx[23] = xx[13];\n  xx[24] = cos(xx[6]);\n  xx[6] = xx[5] * xx[24];\n  xx[5] = xx[24] * xx[10];\n  xx[25] = - xx[6];\n  xx[26] = - xx[5];\n  xx[27] = - xx[8];\n  xx[28] = - xx[4];\n  pm_math_Quaternion_compose_ra(xx + 20, xx + 25, xx + 29);\n  xx[10] = xx[12] * xx[31];\n  xx[33] = xx[6] * xx[8];\n  xx[34] = xx[5] * xx[4];\n  xx[35] = xx[1] * (xx[33] + xx[34]);\n  xx[36] = xx[35] * xx[32];\n  xx[37] = xx[12] * xx[30];\n  xx[38] = xx[36] + xx[37];\n  xx[39] = xx[35] * xx[31];\n  xx[40] = xx[10];\n  xx[41] = - xx[38];\n  xx[42] = xx[39];\n  pm_math_Vector3_cross_ra(xx + 30, xx + 40, xx + 43);\n  xx[40] = xx[1] * (xx[10] * xx[29] + xx[43]) - xx[35];\n  xx[41] = xx[1] * (xx[44] - xx[38] * xx[29]);\n  xx[42] = xx[12] + xx[1] * (xx[39] * xx[29] + xx[45]);\n  xx[10] = sqrt(state[20] * state[20] + state[21] * state[21] + state[22] *\n                state[22] + state[23] * state[23]);\n  xx[38] = state[20] / xx[10];\n  xx[39] = xx[38] * xx[38];\n  xx[43] = state[21] / xx[10];\n  xx[44] = xx[43] * xx[43];\n  xx[45] = state[22] / xx[10];\n  xx[46] = xx[43] * xx[45];\n  xx[47] = state[23] / xx[10];\n  xx[10] = xx[38] * xx[47];\n  xx[48] = xx[43] * xx[47];\n  xx[49] = xx[38] * xx[45];\n  xx[50] = xx[1] * (xx[48] - xx[49]);\n  xx[51] = xx[1] * (xx[39] + xx[44]) - xx[2];\n  xx[52] = xx[1] * (xx[46] + xx[10]);\n  xx[53] = xx[50];\n  xx[54] = xx[6] * xx[4];\n  xx[55] = xx[8] * xx[5];\n  xx[56] = xx[1] * (xx[54] + xx[55]);\n  xx[57] = xx[56] * xx[31];\n  xx[58] = xx[8] * xx[4];\n  xx[59] = xx[6] * xx[5];\n  xx[60] = xx[1] * (xx[58] - xx[59]);\n  xx[61] = xx[60] * xx[32];\n  xx[62] = xx[56] * xx[30];\n  xx[63] = xx[61] + xx[62];\n  xx[64] = xx[60] * xx[31];\n  xx[65] = xx[57];\n  xx[66] = - xx[63];\n  xx[67] = xx[64];\n  pm_math_Vector3_cross_ra(xx + 30, xx + 65, xx + 68);\n  xx[65] = xx[1] * (xx[57] * xx[29] + xx[68]) - xx[60];\n  xx[66] = xx[1] * (xx[69] - xx[63] * xx[29]);\n  xx[67] = xx[56] + xx[1] * (xx[64] * xx[29] + xx[70]);\n  xx[57] = xx[1] * (xx[34] - xx[33]);\n  xx[63] = xx[57] * xx[31];\n  xx[64] = xx[5] * xx[5];\n  xx[68] = xx[2] - xx[1] * (xx[64] + xx[9]);\n  xx[69] = xx[68] * xx[32];\n  xx[70] = xx[57] * xx[30];\n  xx[71] = xx[69] + xx[70];\n  xx[72] = xx[68] * xx[31];\n  xx[73] = xx[63];\n  xx[74] = - xx[71];\n  xx[75] = xx[72];\n  pm_math_Vector3_cross_ra(xx + 30, xx + 73, xx + 76);\n  xx[73] = xx[1] * (xx[63] * xx[29] + xx[76]) - xx[68];\n  xx[74] = xx[1] * (xx[77] - xx[71] * xx[29]);\n  xx[75] = xx[57] + xx[1] * (xx[72] * xx[29] + xx[78]);\n  xx[63] = xx[1] * (xx[49] + xx[48]);\n  xx[71] = xx[38] * xx[43];\n  xx[72] = xx[45] * xx[47];\n  xx[76] = xx[45] * xx[45];\n  xx[77] = xx[1] * (xx[44] + xx[76]);\n  xx[78] = - xx[63];\n  xx[79] = xx[1] * (xx[71] - xx[72]);\n  xx[80] = xx[77] - xx[2];\n  xx[81] = xx[30] * xx[31];\n  xx[82] = xx[29] * xx[32];\n  xx[83] = xx[29] * xx[29];\n  xx[84] = xx[31] * xx[32];\n  xx[85] = xx[29] * xx[30];\n  xx[86] = xx[1] * (xx[81] - xx[82]);\n  xx[87] = xx[1] * (xx[83] + xx[31] * xx[31]) - xx[2];\n  xx[88] = xx[1] * (xx[84] + xx[85]);\n  xx[89] = xx[1] * (xx[46] - xx[10]);\n  xx[90] = xx[47] * xx[47];\n  xx[91] = xx[1] * (xx[90] + xx[44]);\n  xx[44] = xx[1] * (xx[71] + xx[72]);\n  xx[92] = xx[89];\n  xx[93] = xx[2] - xx[91];\n  xx[94] = xx[44];\n  xx[95] = xx[1] * (xx[55] - xx[54]);\n  xx[96] = xx[12] * xx[32];\n  xx[97] = xx[95] * xx[32];\n  xx[98] = xx[95] * xx[31];\n  xx[99] = xx[37] + xx[98];\n  xx[100] = xx[96];\n  xx[101] = xx[97];\n  xx[102] = - xx[99];\n  pm_math_Vector3_cross_ra(xx + 30, xx + 100, xx + 103);\n  xx[100] = xx[95] + xx[1] * (xx[96] * xx[29] + xx[103]);\n  xx[101] = xx[1] * (xx[97] * xx[29] + xx[104]) - xx[12];\n  xx[102] = xx[1] * (xx[105] - xx[99] * xx[29]);\n  xx[103] = xx[89];\n  xx[104] = xx[1] * (xx[39] + xx[76]) - xx[2];\n  xx[105] = xx[1] * (xx[72] + xx[71]);\n  xx[37] = xx[2] - xx[1] * (xx[11] + xx[64]);\n  xx[89] = xx[56] * xx[32];\n  xx[96] = xx[37] * xx[32];\n  xx[97] = xx[37] * xx[31];\n  xx[99] = xx[62] + xx[97];\n  xx[106] = xx[89];\n  xx[107] = xx[96];\n  xx[108] = - xx[99];\n  pm_math_Vector3_cross_ra(xx + 30, xx + 106, xx + 109);\n  xx[106] = xx[37] + xx[1] * (xx[89] * xx[29] + xx[109]);\n  xx[107] = xx[1] * (xx[96] * xx[29] + xx[110]) - xx[56];\n  xx[108] = xx[1] * (xx[111] - xx[99] * xx[29]);\n  xx[62] = xx[1] * (xx[59] + xx[58]);\n  xx[89] = xx[57] * xx[32];\n  xx[96] = xx[62] * xx[32];\n  xx[99] = xx[62] * xx[31];\n  xx[109] = xx[70] + xx[99];\n  xx[110] = xx[89];\n  xx[111] = xx[96];\n  xx[112] = - xx[109];\n  pm_math_Vector3_cross_ra(xx + 30, xx + 110, xx + 113);\n  xx[110] = xx[62] + xx[1] * (xx[89] * xx[29] + xx[113]);\n  xx[111] = xx[1] * (xx[96] * xx[29] + xx[114]) - xx[57];\n  xx[112] = xx[1] * (xx[115] - xx[109] * xx[29]);\n  xx[70] = xx[1] * (xx[72] - xx[71]);\n  xx[113] = xx[63];\n  xx[114] = xx[70];\n  xx[115] = xx[2] - xx[77];\n  xx[63] = xx[30] * xx[32];\n  xx[71] = xx[29] * xx[31];\n  xx[116] = xx[1] * (xx[63] + xx[71]);\n  xx[117] = xx[1] * (xx[84] - xx[85]);\n  xx[118] = xx[1] * (xx[83] + xx[32] * xx[32]) - xx[2];\n  xx[72] = xx[1] * (xx[76] + xx[90]);\n  xx[76] = xx[1] * (xx[10] + xx[46]);\n  xx[119] = xx[72] - xx[2];\n  xx[120] = - xx[76];\n  xx[121] = xx[1] * (xx[49] - xx[48]);\n  xx[77] = xx[98] + xx[36];\n  xx[36] = xx[95] * xx[30];\n  xx[84] = xx[35] * xx[30];\n  xx[122] = - xx[77];\n  xx[123] = xx[36];\n  xx[124] = xx[84];\n  pm_math_Vector3_cross_ra(xx + 30, xx + 122, xx + 125);\n  xx[122] = xx[1] * (xx[125] - xx[77] * xx[29]);\n  xx[123] = xx[35] + xx[1] * (xx[36] * xx[29] + xx[126]);\n  xx[124] = xx[1] * (xx[84] * xx[29] + xx[127]) - xx[95];\n  xx[125] = xx[1] * (xx[48] + xx[49]);\n  xx[126] = xx[70];\n  xx[127] = xx[1] * (xx[39] + xx[90]) - xx[2];\n  xx[36] = xx[97] + xx[61];\n  xx[39] = xx[37] * xx[30];\n  xx[48] = xx[60] * xx[30];\n  xx[96] = - xx[36];\n  xx[97] = xx[39];\n  xx[98] = xx[48];\n  pm_math_Vector3_cross_ra(xx + 30, xx + 96, xx + 128);\n  xx[96] = xx[1] * (xx[128] - xx[36] * xx[29]);\n  xx[97] = xx[60] + xx[1] * (xx[39] * xx[29] + xx[129]);\n  xx[98] = xx[1] * (xx[48] * xx[29] + xx[130]) - xx[37];\n  xx[36] = xx[99] + xx[69];\n  xx[39] = xx[62] * xx[30];\n  xx[48] = xx[68] * xx[30];\n  xx[128] = - xx[36];\n  xx[129] = xx[39];\n  xx[130] = xx[48];\n  pm_math_Vector3_cross_ra(xx + 30, xx + 128, xx + 131);\n  xx[128] = xx[1] * (xx[131] - xx[36] * xx[29]);\n  xx[129] = xx[68] + xx[1] * (xx[39] * xx[29] + xx[132]);\n  xx[130] = xx[1] * (xx[48] * xx[29] + xx[133]) - xx[62];\n  xx[131] = xx[1] * (xx[10] - xx[46]);\n  xx[132] = xx[91] - xx[2];\n  xx[133] = - xx[44];\n  xx[89] = xx[1] * (xx[83] + xx[30] * xx[30]) - xx[2];\n  xx[90] = xx[1] * (xx[81] + xx[82]);\n  xx[91] = xx[1] * (xx[63] - xx[71]);\n  xx[69] = xx[2] - xx[72];\n  xx[70] = xx[76];\n  xx[71] = xx[50];\n  xx[10] = bb[0] ? xx[0] : - xx[2];\n  xx[36] = 0.04500000000000001;\n  xx[39] = xx[36] * xx[12];\n  xx[44] = xx[39] * xx[32];\n  xx[46] = xx[36] * xx[95];\n  xx[48] = xx[46] * xx[32];\n  xx[49] = xx[39] * xx[30] + xx[46] * xx[31];\n  xx[81] = - xx[44];\n  xx[82] = - xx[48];\n  xx[83] = xx[49];\n  pm_math_Vector3_cross_ra(xx + 30, xx + 81, xx + 134);\n  xx[50] = 0.04499999999999999;\n  xx[61] = xx[50] * xx[5];\n  xx[63] = xx[50] * xx[8];\n  xx[72] = xx[1] * (xx[61] * xx[6] - xx[63] * xx[4]);\n  xx[76] = xx[72] * xx[17];\n  xx[77] = xx[1] * (xx[61] * xx[5] + xx[63] * xx[8]) - xx[50] - xx[2];\n  xx[81] = xx[77] * xx[19];\n  xx[82] = xx[76] + xx[81];\n  xx[83] = xx[16];\n  xx[84] = xx[18];\n  xx[85] = xx[13];\n  xx[13] = xx[72] * xx[15];\n  xx[16] = xx[77] * xx[15];\n  xx[137] = - xx[82];\n  xx[138] = xx[13];\n  xx[139] = xx[16];\n  pm_math_Vector3_cross_ra(xx + 83, xx + 137, xx + 140);\n  xx[18] = xx[14] * xx[19];\n  xx[99] = xx[15] * xx[17];\n  xx[109] = xx[36] * xx[56];\n  xx[137] = xx[109] * xx[32];\n  xx[138] = xx[36] * xx[37];\n  xx[139] = xx[138] * xx[32];\n  xx[143] = xx[109] * xx[30] + xx[138] * xx[31];\n  xx[144] = - xx[137];\n  xx[145] = - xx[139];\n  xx[146] = xx[143];\n  pm_math_Vector3_cross_ra(xx + 30, xx + 144, xx + 147);\n  xx[144] = xx[1] * (xx[63] * xx[6] + xx[61] * xx[4]);\n  xx[61] = xx[144] * xx[17];\n  xx[63] = xx[144] * xx[15];\n  xx[145] = xx[81] - xx[63];\n  xx[81] = xx[77] * xx[17];\n  xx[150] = - xx[61];\n  xx[151] = - xx[145];\n  xx[152] = xx[81];\n  pm_math_Vector3_cross_ra(xx + 83, xx + 150, xx + 153);\n  xx[146] = xx[17] * xx[17];\n  xx[150] = xx[19] * xx[19];\n  xx[151] = xx[36] * xx[57];\n  xx[152] = xx[151] * xx[32];\n  xx[156] = xx[36] * xx[62];\n  xx[157] = xx[156] * xx[32];\n  xx[158] = xx[151] * xx[30] + xx[156] * xx[31];\n  xx[159] = - xx[152];\n  xx[160] = - xx[157];\n  xx[161] = xx[158];\n  pm_math_Vector3_cross_ra(xx + 30, xx + 159, xx + 162);\n  xx[159] = xx[144] * xx[19];\n  xx[160] = xx[72] * xx[19];\n  xx[161] = xx[76] - xx[63];\n  xx[165] = - xx[159];\n  xx[166] = xx[160];\n  xx[167] = - xx[161];\n  pm_math_Vector3_cross_ra(xx + 83, xx + 165, xx + 168);\n  xx[63] = bb[0] ? xx[0] : xx[2];\n  xx[76] = 0.0225;\n  xx[83] = xx[76] * xx[47];\n  xx[84] = xx[83] * xx[38];\n  xx[85] = xx[76] * xx[43];\n  xx[165] = xx[76] * xx[45];\n  xx[166] = xx[165] * xx[45];\n  xx[167] = xx[83] * xx[47];\n  xx[171] = xx[15] * xx[15];\n  xx[172] = xx[85] * xx[43];\n  xx[173] = xx[14] * xx[15];\n  xx[174] = xx[17] * xx[19];\n  xx[175] = xx[15] * xx[19];\n  xx[176] = xx[14] * xx[17];\n  xx[177] = xx[85] * xx[38];\n  xx[178] = xx[165] * xx[38];\n  xx[179] = xx[0];\n  xx[180] = xx[0];\n  xx[181] = xx[0];\n  xx[182] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 40, xx + 51);\n  xx[183] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 65, xx + 51);\n  xx[184] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 73, xx + 51);\n  xx[185] = xx[0];\n  xx[186] = xx[0];\n  xx[187] = xx[0];\n  xx[188] = xx[0];\n  xx[189] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 78, xx + 86);\n  xx[190] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 92, xx + 86);\n  xx[191] = xx[0];\n  xx[192] = xx[0];\n  xx[193] = xx[0];\n  xx[194] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 100, xx + 103);\n  xx[195] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 106, xx + 103);\n  xx[196] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 110, xx + 103);\n  xx[197] = xx[0];\n  xx[198] = xx[0];\n  xx[199] = xx[0];\n  xx[200] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 113, xx + 116);\n  xx[201] = xx[0];\n  xx[202] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 119, xx + 116);\n  xx[203] = xx[0];\n  xx[204] = xx[0];\n  xx[205] = xx[0];\n  xx[206] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 122, xx + 125);\n  xx[207] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 96, xx + 125);\n  xx[208] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 128, xx + 125);\n  xx[209] = xx[0];\n  xx[210] = xx[0];\n  xx[211] = xx[0];\n  xx[212] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 131, xx + 89);\n  xx[213] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 69, xx + 89);\n  xx[214] = xx[0];\n  xx[215] = xx[10];\n  xx[216] = xx[0];\n  xx[217] = xx[0];\n  xx[218] = bb[0] ? xx[0] : - (xx[1] * (xx[134] - xx[44] * xx[29]) - xx[46] +\n    xx[1] * (xx[82] * xx[14] + xx[140]) + xx[1] * (xx[18] - xx[99]));\n  xx[219] = bb[0] ? xx[0] : - (xx[1] * (xx[147] - xx[137] * xx[29]) - xx[138] +\n    xx[77] + xx[1] * (xx[153] + xx[61] * xx[14]) - xx[1] * (xx[146] + xx[150]) +\n    xx[2]);\n  xx[220] = bb[0] ? xx[0] : - (xx[1] * (xx[162] - xx[152] * xx[29]) - xx[156] +\n    xx[1] * (xx[168] + xx[159] * xx[14]) - xx[72]);\n  xx[221] = xx[63];\n  xx[222] = xx[0];\n  xx[223] = xx[0];\n  xx[224] = bb[0] ? xx[0] : xx[1] * (xx[84] - xx[85] * xx[45]);\n  xx[225] = bb[0] ? xx[0] : xx[76] - xx[1] * (xx[166] + xx[167]);\n  xx[226] = xx[0];\n  xx[227] = xx[0];\n  xx[228] = xx[10];\n  xx[229] = xx[0];\n  xx[230] = bb[0] ? xx[0] : - (xx[1] * (xx[135] - xx[48] * xx[29]) + xx[1] *\n    (xx[141] - xx[13] * xx[14]) + xx[1] * (xx[150] + xx[171]) - xx[77] + xx[39]\n    - xx[2]);\n  xx[231] = bb[0] ? xx[0] : - (xx[1] * (xx[148] - xx[139] * xx[29]) + xx[109] +\n    xx[1] * (xx[145] * xx[14] + xx[154]) + xx[1] * (xx[18] + xx[99]));\n  xx[232] = bb[0] ? xx[0] : - (xx[1] * (xx[163] - xx[157] * xx[29]) + xx[151] +\n    xx[1] * (xx[169] - xx[160] * xx[14]) - xx[144]);\n  xx[233] = xx[0];\n  xx[234] = xx[63];\n  xx[235] = xx[0];\n  xx[236] = bb[0] ? xx[0] : xx[1] * (xx[167] + xx[172]) - xx[76];\n  xx[237] = bb[0] ? xx[0] : xx[1] * (xx[84] + xx[165] * xx[43]);\n  xx[238] = xx[0];\n  xx[239] = xx[0];\n  xx[240] = xx[0];\n  xx[241] = xx[10];\n  xx[242] = bb[0] ? xx[0] : - (xx[1] * (xx[136] + xx[49] * xx[29]) + xx[72] +\n    xx[1] * (xx[142] - xx[16] * xx[14]) - xx[1] * (xx[173] + xx[174]));\n  xx[243] = bb[0] ? xx[0] : - (xx[1] * (xx[149] + xx[143] * xx[29]) + xx[1] *\n    (xx[155] - xx[81] * xx[14]) + xx[144] + xx[1] * (xx[175] - xx[176]));\n  xx[244] = bb[0] ? xx[0] : - (xx[1] * (xx[164] + xx[158] * xx[29]) + xx[1] *\n    (xx[161] * xx[14] + xx[170]));\n  xx[245] = xx[0];\n  xx[246] = xx[0];\n  xx[247] = xx[63];\n  xx[248] = bb[0] ? xx[0] : - (xx[1] * (xx[177] + xx[83] * xx[45]));\n  xx[249] = bb[0] ? xx[0] : xx[1] * (xx[83] * xx[43] - xx[178]);\n  xx[250] = xx[0];\n  ii[0] = bb[0] ? 0 : 1;\n  xx[40] = - xx[144];\n  xx[41] = xx[72];\n  xx[42] = xx[77];\n  pm_math_Quaternion_xform_ra(xx + 20, xx + 40, xx + 65);\n  xx[13] = xx[36] * xx[31];\n  xx[16] = xx[36] * xx[30];\n  xx[78] = pm_math_Vector3_dot_ra(xx + 51, xx + 86);\n  xx[79] = pm_math_Vector3_dot_ra(xx + 103, xx + 116);\n  xx[80] = pm_math_Vector3_dot_ra(xx + 125, xx + 89);\n  xx[81] = xx[1] * (xx[178] + xx[85] * xx[47]) + state[17] - (xx[65] + state[0]\n    + xx[1] * (xx[176] + xx[175]) - xx[1] * (xx[13] * xx[29] + xx[16] * xx[32]));\n  xx[82] = xx[1] * (xx[165] * xx[47] - xx[177]) + state[18] - (xx[1] * (xx[16] *\n    xx[29] - xx[13] * xx[32]) + xx[66] + state[1] - xx[1] * (xx[173] - xx[174]));\n  xx[83] = state[19] - xx[1] * (xx[172] + xx[166]) - (xx[67] + state[2] - xx[1] *\n    (xx[171] + xx[146]) + xx[1] * (xx[16] * xx[30] + xx[13] * xx[31])) - 0.9325;\n  zeroMajor(1, 6, ii + 0, xx + 78);\n  xx[84] = - xx[78];\n  xx[85] = - xx[79];\n  xx[86] = - xx[80];\n  xx[87] = - xx[81];\n  xx[88] = - xx[82];\n  xx[89] = - xx[83];\n  xx[13] = 1.0e-8;\n  memcpy(xx + 251, xx + 179, 72 * sizeof(double));\n  factorAndSolveWide(6, 12, xx + 251, xx + 78, xx + 110, ii + 1, xx + 84, xx[13],\n                     xx + 96);\n  xx[16] = state[0] + xx[96];\n  xx[20] = xx[14];\n  xx[21] = xx[15];\n  xx[22] = xx[17];\n  xx[23] = xx[19];\n  pm_math_Quaternion_compDeriv_ra(xx + 20, xx + 99, xx + 29);\n  xx[18] = xx[14] + xx[29];\n  xx[14] = xx[15] + xx[30];\n  xx[15] = xx[17] + xx[31];\n  xx[17] = xx[19] + xx[32];\n  xx[19] = 1.0e-64;\n  xx[20] = sqrt(xx[18] * xx[18] + xx[14] * xx[14] + xx[15] * xx[15] + xx[17] *\n                xx[17]);\n  if (xx[19] > xx[20])\n    xx[20] = xx[19];\n  xx[21] = xx[18] / xx[20];\n  xx[18] = xx[14] / xx[20];\n  xx[14] = - xx[18];\n  xx[22] = xx[15] / xx[20];\n  xx[15] = - xx[22];\n  xx[23] = xx[17] / xx[20];\n  xx[17] = - xx[23];\n  xx[29] = - xx[21];\n  xx[30] = xx[14];\n  xx[31] = xx[15];\n  xx[32] = xx[17];\n  pm_math_Quaternion_compose_ra(xx + 29, xx + 25, xx + 78);\n  xx[20] = xx[12] * xx[80];\n  xx[44] = xx[35] * xx[81];\n  xx[48] = xx[12] * xx[79];\n  xx[49] = xx[44] + xx[48];\n  xx[51] = xx[35] * xx[80];\n  xx[65] = xx[20];\n  xx[66] = - xx[49];\n  xx[67] = xx[51];\n  pm_math_Vector3_cross_ra(xx + 79, xx + 65, xx + 69);\n  xx[65] = xx[1] * (xx[20] * xx[78] + xx[69]) - xx[35];\n  xx[66] = xx[1] * (xx[70] - xx[49] * xx[78]);\n  xx[67] = xx[12] + xx[1] * (xx[51] * xx[78] + xx[71]);\n  xx[82] = xx[38];\n  xx[83] = xx[43];\n  xx[84] = xx[45];\n  xx[85] = xx[47];\n  pm_math_Quaternion_compDeriv_ra(xx + 82, xx + 105, xx + 86);\n  xx[20] = xx[38] + xx[86];\n  xx[38] = xx[43] + xx[87];\n  xx[43] = xx[45] + xx[88];\n  xx[45] = xx[47] + xx[89];\n  xx[47] = sqrt(xx[20] * xx[20] + xx[38] * xx[38] + xx[43] * xx[43] + xx[45] *\n                xx[45]);\n  if (xx[19] > xx[47])\n    xx[47] = xx[19];\n  xx[49] = xx[20] / xx[47];\n  xx[20] = xx[49] * xx[49];\n  xx[51] = xx[38] / xx[47];\n  xx[38] = xx[51] * xx[51];\n  xx[52] = xx[43] / xx[47];\n  xx[43] = xx[51] * xx[52];\n  xx[53] = xx[45] / xx[47];\n  xx[45] = xx[49] * xx[53];\n  xx[47] = xx[51] * xx[53];\n  xx[61] = xx[49] * xx[52];\n  xx[69] = xx[1] * (xx[47] - xx[61]);\n  xx[73] = xx[1] * (xx[20] + xx[38]) - xx[2];\n  xx[74] = xx[1] * (xx[43] + xx[45]);\n  xx[75] = xx[69];\n  xx[70] = xx[56] * xx[80];\n  xx[71] = xx[60] * xx[81];\n  xx[82] = xx[56] * xx[79];\n  xx[83] = xx[71] + xx[82];\n  xx[84] = xx[60] * xx[80];\n  xx[85] = xx[70];\n  xx[86] = - xx[83];\n  xx[87] = xx[84];\n  pm_math_Vector3_cross_ra(xx + 79, xx + 85, xx + 88);\n  xx[85] = xx[1] * (xx[70] * xx[78] + xx[88]) - xx[60];\n  xx[86] = xx[1] * (xx[89] - xx[83] * xx[78]);\n  xx[87] = xx[56] + xx[1] * (xx[84] * xx[78] + xx[90]);\n  xx[70] = xx[57] * xx[80];\n  xx[83] = xx[68] * xx[81];\n  xx[84] = xx[57] * xx[79];\n  xx[88] = xx[83] + xx[84];\n  xx[89] = xx[68] * xx[80];\n  xx[90] = xx[70];\n  xx[91] = - xx[88];\n  xx[92] = xx[89];\n  pm_math_Vector3_cross_ra(xx + 79, xx + 90, xx + 110);\n  xx[90] = xx[1] * (xx[70] * xx[78] + xx[110]) - xx[68];\n  xx[91] = xx[1] * (xx[111] - xx[88] * xx[78]);\n  xx[92] = xx[57] + xx[1] * (xx[89] * xx[78] + xx[112]);\n  xx[70] = xx[1] * (xx[61] + xx[47]);\n  xx[88] = xx[49] * xx[51];\n  xx[89] = xx[52] * xx[53];\n  xx[93] = xx[52] * xx[52];\n  xx[94] = xx[1] * (xx[38] + xx[93]);\n  xx[110] = - xx[70];\n  xx[111] = xx[1] * (xx[88] - xx[89]);\n  xx[112] = xx[94] - xx[2];\n  xx[108] = xx[79] * xx[80];\n  xx[113] = xx[78] * xx[81];\n  xx[114] = xx[78] * xx[78];\n  xx[115] = xx[80] * xx[81];\n  xx[116] = xx[78] * xx[79];\n  xx[117] = xx[1] * (xx[108] - xx[113]);\n  xx[118] = xx[1] * (xx[114] + xx[80] * xx[80]) - xx[2];\n  xx[119] = xx[1] * (xx[115] + xx[116]);\n  xx[120] = xx[1] * (xx[43] - xx[45]);\n  xx[121] = xx[53] * xx[53];\n  xx[122] = xx[1] * (xx[121] + xx[38]);\n  xx[38] = xx[1] * (xx[88] + xx[89]);\n  xx[123] = xx[120];\n  xx[124] = xx[2] - xx[122];\n  xx[125] = xx[38];\n  xx[126] = xx[12] * xx[81];\n  xx[127] = xx[95] * xx[81];\n  xx[128] = xx[95] * xx[80];\n  xx[129] = xx[48] + xx[128];\n  xx[130] = xx[126];\n  xx[131] = xx[127];\n  xx[132] = - xx[129];\n  pm_math_Vector3_cross_ra(xx + 79, xx + 130, xx + 133);\n  xx[130] = xx[95] + xx[1] * (xx[126] * xx[78] + xx[133]);\n  xx[131] = xx[1] * (xx[127] * xx[78] + xx[134]) - xx[12];\n  xx[132] = xx[1] * (xx[135] - xx[129] * xx[78]);\n  xx[133] = xx[120];\n  xx[134] = xx[1] * (xx[20] + xx[93]) - xx[2];\n  xx[135] = xx[1] * (xx[89] + xx[88]);\n  xx[12] = xx[56] * xx[81];\n  xx[48] = xx[37] * xx[81];\n  xx[120] = xx[37] * xx[80];\n  xx[126] = xx[82] + xx[120];\n  xx[139] = xx[12];\n  xx[140] = xx[48];\n  xx[141] = - xx[126];\n  pm_math_Vector3_cross_ra(xx + 79, xx + 139, xx + 145);\n  xx[139] = xx[37] + xx[1] * (xx[12] * xx[78] + xx[145]);\n  xx[140] = xx[1] * (xx[48] * xx[78] + xx[146]) - xx[56];\n  xx[141] = xx[1] * (xx[147] - xx[126] * xx[78]);\n  xx[12] = xx[57] * xx[81];\n  xx[48] = xx[62] * xx[81];\n  xx[56] = xx[62] * xx[80];\n  xx[82] = xx[84] + xx[56];\n  xx[145] = xx[12];\n  xx[146] = xx[48];\n  xx[147] = - xx[82];\n  pm_math_Vector3_cross_ra(xx + 79, xx + 145, xx + 148);\n  xx[145] = xx[62] + xx[1] * (xx[12] * xx[78] + xx[148]);\n  xx[146] = xx[1] * (xx[48] * xx[78] + xx[149]) - xx[57];\n  xx[147] = xx[1] * (xx[150] - xx[82] * xx[78]);\n  xx[12] = xx[1] * (xx[89] - xx[88]);\n  xx[148] = xx[70];\n  xx[149] = xx[12];\n  xx[150] = xx[2] - xx[94];\n  xx[48] = xx[79] * xx[81];\n  xx[70] = xx[78] * xx[80];\n  xx[152] = xx[1] * (xx[48] + xx[70]);\n  xx[153] = xx[1] * (xx[115] - xx[116]);\n  xx[154] = xx[1] * (xx[114] + xx[81] * xx[81]) - xx[2];\n  xx[82] = xx[1] * (xx[93] + xx[121]);\n  xx[84] = xx[1] * (xx[45] + xx[43]);\n  xx[157] = xx[82] - xx[2];\n  xx[158] = - xx[84];\n  xx[159] = xx[1] * (xx[61] - xx[47]);\n  xx[88] = xx[128] + xx[44];\n  xx[44] = xx[95] * xx[79];\n  xx[89] = xx[35] * xx[79];\n  xx[126] = - xx[88];\n  xx[127] = xx[44];\n  xx[128] = xx[89];\n  pm_math_Vector3_cross_ra(xx + 79, xx + 126, xx + 160);\n  xx[126] = xx[1] * (xx[160] - xx[88] * xx[78]);\n  xx[127] = xx[35] + xx[1] * (xx[44] * xx[78] + xx[161]);\n  xx[128] = xx[1] * (xx[89] * xx[78] + xx[162]) - xx[95];\n  xx[160] = xx[1] * (xx[47] + xx[61]);\n  xx[161] = xx[12];\n  xx[162] = xx[1] * (xx[20] + xx[121]) - xx[2];\n  xx[12] = xx[120] + xx[71];\n  xx[20] = xx[37] * xx[79];\n  xx[35] = xx[60] * xx[79];\n  xx[163] = - xx[12];\n  xx[164] = xx[20];\n  xx[165] = xx[35];\n  pm_math_Vector3_cross_ra(xx + 79, xx + 163, xx + 166);\n  xx[163] = xx[1] * (xx[166] - xx[12] * xx[78]);\n  xx[164] = xx[60] + xx[1] * (xx[20] * xx[78] + xx[167]);\n  xx[165] = xx[1] * (xx[35] * xx[78] + xx[168]) - xx[37];\n  xx[12] = xx[56] + xx[83];\n  xx[20] = xx[62] * xx[79];\n  xx[35] = xx[68] * xx[79];\n  xx[166] = - xx[12];\n  xx[167] = xx[20];\n  xx[168] = xx[35];\n  pm_math_Vector3_cross_ra(xx + 79, xx + 166, xx + 169);\n  xx[166] = xx[1] * (xx[169] - xx[12] * xx[78]);\n  xx[167] = xx[68] + xx[1] * (xx[20] * xx[78] + xx[170]);\n  xx[168] = xx[1] * (xx[35] * xx[78] + xx[171]) - xx[62];\n  xx[169] = xx[1] * (xx[45] - xx[43]);\n  xx[170] = xx[122] - xx[2];\n  xx[171] = - xx[38];\n  xx[43] = xx[1] * (xx[114] + xx[79] * xx[79]) - xx[2];\n  xx[44] = xx[1] * (xx[108] + xx[113]);\n  xx[45] = xx[1] * (xx[48] - xx[70]);\n  xx[113] = xx[2] - xx[82];\n  xx[114] = xx[84];\n  xx[115] = xx[69];\n  xx[12] = xx[39] * xx[81];\n  xx[20] = xx[46] * xx[81];\n  xx[35] = xx[39] * xx[79] + xx[46] * xx[80];\n  xx[68] = - xx[12];\n  xx[69] = - xx[20];\n  xx[70] = xx[35];\n  pm_math_Vector3_cross_ra(xx + 79, xx + 68, xx + 82);\n  xx[37] = xx[72] * xx[22];\n  xx[38] = xx[77] * xx[23];\n  xx[47] = xx[37] + xx[38];\n  xx[68] = xx[14];\n  xx[69] = xx[15];\n  xx[70] = xx[17];\n  xx[14] = xx[72] * xx[18];\n  xx[15] = xx[77] * xx[18];\n  xx[120] = - xx[47];\n  xx[121] = xx[14];\n  xx[122] = xx[15];\n  pm_math_Vector3_cross_ra(xx + 68, xx + 120, xx + 172);\n  xx[17] = xx[21] * xx[23];\n  xx[48] = xx[18] * xx[22];\n  xx[56] = xx[109] * xx[81];\n  xx[61] = xx[138] * xx[81];\n  xx[62] = xx[109] * xx[79] + xx[138] * xx[80];\n  xx[120] = - xx[56];\n  xx[121] = - xx[61];\n  xx[122] = xx[62];\n  pm_math_Vector3_cross_ra(xx + 79, xx + 120, xx + 175);\n  xx[71] = xx[144] * xx[22];\n  xx[88] = xx[144] * xx[18];\n  xx[89] = xx[38] - xx[88];\n  xx[38] = xx[77] * xx[22];\n  xx[120] = - xx[71];\n  xx[121] = - xx[89];\n  xx[122] = xx[38];\n  pm_math_Vector3_cross_ra(xx + 68, xx + 120, xx + 178);\n  xx[93] = xx[22] * xx[22];\n  xx[94] = xx[23] * xx[23];\n  xx[108] = xx[151] * xx[81];\n  xx[116] = xx[156] * xx[81];\n  xx[120] = xx[151] * xx[79] + xx[156] * xx[80];\n  xx[181] = - xx[108];\n  xx[182] = - xx[116];\n  xx[183] = xx[120];\n  pm_math_Vector3_cross_ra(xx + 79, xx + 181, xx + 184);\n  xx[121] = xx[144] * xx[23];\n  xx[122] = xx[72] * xx[23];\n  xx[129] = xx[37] - xx[88];\n  xx[181] = - xx[121];\n  xx[182] = xx[122];\n  xx[183] = - xx[129];\n  pm_math_Vector3_cross_ra(xx + 68, xx + 181, xx + 187);\n  xx[37] = xx[76] * xx[53];\n  xx[68] = xx[37] * xx[49];\n  xx[69] = xx[76] * xx[51];\n  xx[70] = xx[76] * xx[52];\n  xx[88] = xx[70] * xx[52];\n  xx[136] = xx[37] * xx[53];\n  xx[137] = xx[18] * xx[18];\n  xx[142] = xx[69] * xx[51];\n  xx[143] = xx[21] * xx[18];\n  xx[155] = xx[22] * xx[23];\n  xx[181] = xx[18] * xx[23];\n  xx[182] = xx[21] * xx[22];\n  xx[183] = xx[69] * xx[49];\n  xx[190] = xx[70] * xx[49];\n  xx[191] = xx[0];\n  xx[192] = xx[0];\n  xx[193] = xx[0];\n  xx[194] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 65, xx + 73);\n  xx[195] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 85, xx + 73);\n  xx[196] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 90, xx + 73);\n  xx[197] = xx[0];\n  xx[198] = xx[0];\n  xx[199] = xx[0];\n  xx[200] = xx[0];\n  xx[201] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 110, xx + 117);\n  xx[202] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 123, xx + 117);\n  xx[203] = xx[0];\n  xx[204] = xx[0];\n  xx[205] = xx[0];\n  xx[206] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 130, xx + 133);\n  xx[207] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 139, xx + 133);\n  xx[208] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 145, xx + 133);\n  xx[209] = xx[0];\n  xx[210] = xx[0];\n  xx[211] = xx[0];\n  xx[212] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 148, xx + 152);\n  xx[213] = xx[0];\n  xx[214] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 157, xx + 152);\n  xx[215] = xx[0];\n  xx[216] = xx[0];\n  xx[217] = xx[0];\n  xx[218] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 126, xx + 160);\n  xx[219] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 163, xx + 160);\n  xx[220] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 166, xx + 160);\n  xx[221] = xx[0];\n  xx[222] = xx[0];\n  xx[223] = xx[0];\n  xx[224] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 169, xx + 43);\n  xx[225] = bb[0] ? xx[0] : pm_math_Vector3_dot_ra(xx + 113, xx + 43);\n  xx[226] = xx[0];\n  xx[227] = xx[10];\n  xx[228] = xx[0];\n  xx[229] = xx[0];\n  xx[230] = bb[0] ? xx[0] : - (xx[1] * (xx[82] - xx[12] * xx[78]) - xx[46] + xx\n    [1] * (xx[47] * xx[21] + xx[172]) + xx[1] * (xx[17] - xx[48]));\n  xx[231] = bb[0] ? xx[0] : - (xx[1] * (xx[175] - xx[56] * xx[78]) - xx[138] +\n    xx[77] + xx[1] * (xx[178] + xx[71] * xx[21]) - xx[1] * (xx[93] + xx[94]) +\n    xx[2]);\n  xx[232] = bb[0] ? xx[0] : - (xx[1] * (xx[184] - xx[108] * xx[78]) - xx[156] +\n    xx[1] * (xx[187] + xx[121] * xx[21]) - xx[72]);\n  xx[233] = xx[63];\n  xx[234] = xx[0];\n  xx[235] = xx[0];\n  xx[236] = bb[0] ? xx[0] : xx[1] * (xx[68] - xx[69] * xx[52]);\n  xx[237] = bb[0] ? xx[0] : xx[76] - xx[1] * (xx[88] + xx[136]);\n  xx[238] = xx[0];\n  xx[239] = xx[0];\n  xx[240] = xx[10];\n  xx[241] = xx[0];\n  xx[242] = bb[0] ? xx[0] : - (xx[1] * (xx[83] - xx[20] * xx[78]) + xx[1] * (xx\n    [173] - xx[14] * xx[21]) + xx[1] * (xx[94] + xx[137]) - xx[77] + xx[39] -\n    xx[2]);\n  xx[243] = bb[0] ? xx[0] : - (xx[1] * (xx[176] - xx[61] * xx[78]) + xx[109] +\n    xx[1] * (xx[89] * xx[21] + xx[179]) + xx[1] * (xx[17] + xx[48]));\n  xx[244] = bb[0] ? xx[0] : - (xx[1] * (xx[185] - xx[116] * xx[78]) + xx[151] +\n    xx[1] * (xx[188] - xx[122] * xx[21]) - xx[144]);\n  xx[245] = xx[0];\n  xx[246] = xx[63];\n  xx[247] = xx[0];\n  xx[248] = bb[0] ? xx[0] : xx[1] * (xx[136] + xx[142]) - xx[76];\n  xx[249] = bb[0] ? xx[0] : xx[1] * (xx[68] + xx[70] * xx[51]);\n  xx[250] = xx[0];\n  xx[251] = xx[0];\n  xx[252] = xx[0];\n  xx[253] = xx[10];\n  xx[254] = bb[0] ? xx[0] : - (xx[1] * (xx[84] + xx[35] * xx[78]) + xx[72] + xx\n    [1] * (xx[174] - xx[15] * xx[21]) - xx[1] * (xx[143] + xx[155]));\n  xx[255] = bb[0] ? xx[0] : - (xx[1] * (xx[177] + xx[62] * xx[78]) + xx[1] *\n    (xx[180] - xx[38] * xx[21]) + xx[144] + xx[1] * (xx[181] - xx[182]));\n  xx[256] = bb[0] ? xx[0] : - (xx[1] * (xx[186] + xx[120] * xx[78]) + xx[1] *\n    (xx[129] * xx[21] + xx[189]));\n  xx[257] = xx[0];\n  xx[258] = xx[0];\n  xx[259] = xx[63];\n  xx[260] = bb[0] ? xx[0] : - (xx[1] * (xx[183] + xx[37] * xx[52]));\n  xx[261] = bb[0] ? xx[0] : xx[1] * (xx[37] * xx[51] - xx[190]);\n  xx[262] = xx[0];\n  xx[12] = state[17] + xx[102];\n  pm_math_Quaternion_xform_ra(xx + 29, xx + 40, xx + 37);\n  xx[14] = xx[36] * xx[80];\n  xx[15] = xx[36] * xx[79];\n  xx[17] = state[18] + xx[103];\n  xx[20] = state[1] + xx[97];\n  xx[29] = state[19] + xx[104];\n  xx[30] = state[2] + xx[98];\n  xx[82] = pm_math_Vector3_dot_ra(xx + 73, xx + 117);\n  xx[83] = pm_math_Vector3_dot_ra(xx + 133, xx + 152);\n  xx[84] = pm_math_Vector3_dot_ra(xx + 160, xx + 43);\n  xx[85] = xx[1] * (xx[190] + xx[69] * xx[53]) + xx[12] - (xx[37] + xx[16] + xx\n    [1] * (xx[182] + xx[181]) - xx[1] * (xx[14] * xx[78] + xx[15] * xx[81]));\n  xx[86] = xx[1] * (xx[70] * xx[53] - xx[183]) + xx[17] - (xx[1] * (xx[15] * xx\n    [78] - xx[14] * xx[81]) + xx[38] + xx[20] - xx[1] * (xx[143] - xx[155]));\n  xx[87] = xx[76] - xx[1] * (xx[142] + xx[88]) + xx[29] - (xx[39] + xx[30] -\n    (xx[1] * (xx[137] + xx[93]) - xx[2]) + xx[1] * (xx[15] * xx[79] + xx[14] *\n    xx[80])) + xx[36];\n  zeroMajor(1, 6, ii + 0, xx + 82);\n  xx[43] = - xx[82];\n  xx[44] = - xx[83];\n  xx[45] = - xx[84];\n  xx[46] = - xx[85];\n  xx[47] = - xx[86];\n  xx[48] = - xx[87];\n  memcpy(xx + 96, xx + 191, 72 * sizeof(double));\n  factorAndSolveWide(6, 12, xx + 96, xx + 65, xx + 89, ii + 1, xx + 43, xx[13],\n                     xx + 77);\n  xx[13] = xx[16] + xx[77];\n  xx[14] = xx[20] + xx[78];\n  xx[15] = xx[30] + xx[79];\n  xx[43] = xx[21];\n  xx[44] = xx[18];\n  xx[45] = xx[22];\n  xx[46] = xx[23];\n  pm_math_Quaternion_compDeriv_ra(xx + 43, xx + 80, xx + 65);\n  xx[16] = xx[21] + xx[65];\n  xx[20] = xx[18] + xx[66];\n  xx[18] = xx[22] + xx[67];\n  xx[21] = xx[23] + xx[68];\n  xx[22] = sqrt(xx[16] * xx[16] + xx[20] * xx[20] + xx[18] * xx[18] + xx[21] *\n                xx[21]);\n  if (xx[19] > xx[22])\n    xx[22] = xx[19];\n  xx[23] = xx[16] / xx[22];\n  xx[16] = xx[20] / xx[22];\n  xx[20] = xx[18] / xx[22];\n  xx[18] = xx[21] / xx[22];\n  xx[21] = xx[12] + xx[83];\n  xx[12] = xx[17] + xx[84];\n  xx[17] = xx[29] + xx[85];\n  xx[29] = xx[49];\n  xx[30] = xx[51];\n  xx[31] = xx[52];\n  xx[32] = xx[53];\n  pm_math_Quaternion_compDeriv_ra(xx + 29, xx + 86, xx + 43);\n  xx[22] = xx[49] + xx[43];\n  xx[29] = xx[51] + xx[44];\n  xx[30] = xx[52] + xx[45];\n  xx[31] = xx[53] + xx[46];\n  xx[32] = sqrt(xx[22] * xx[22] + xx[29] * xx[29] + xx[30] * xx[30] + xx[31] *\n                xx[31]);\n  if (xx[19] > xx[32])\n    xx[32] = xx[19];\n  xx[19] = xx[22] / xx[32];\n  xx[22] = xx[29] / xx[32];\n  xx[29] = xx[30] / xx[32];\n  xx[30] = xx[31] / xx[32];\n  xx[96] = xx[13];\n  xx[97] = xx[14];\n  xx[98] = xx[15];\n  xx[99] = xx[23];\n  xx[100] = xx[16];\n  xx[101] = xx[20];\n  xx[102] = xx[18];\n  xx[103] = state[7];\n  xx[104] = state[8];\n  xx[105] = state[9];\n  xx[106] = state[10];\n  xx[107] = state[11];\n  xx[108] = state[12];\n  xx[109] = state[13];\n  xx[110] = state[14];\n  xx[111] = state[15];\n  xx[112] = state[16];\n  xx[113] = xx[21];\n  xx[114] = xx[12];\n  xx[115] = xx[17];\n  xx[116] = xx[19];\n  xx[117] = xx[22];\n  xx[118] = xx[29];\n  xx[119] = xx[30];\n  xx[120] = state[24];\n  xx[121] = state[25];\n  xx[122] = state[26];\n  xx[123] = state[27];\n  xx[124] = state[28];\n  xx[125] = state[29];\n  xx[31] = xx[19] * xx[19];\n  xx[32] = xx[22] * xx[29];\n  xx[35] = xx[19] * xx[30];\n  xx[37] = xx[22] * xx[30];\n  xx[38] = xx[19] * xx[29];\n  xx[43] = xx[1] * (xx[31] + xx[22] * xx[22]) - xx[2];\n  xx[44] = xx[1] * (xx[32] + xx[35]);\n  xx[45] = xx[1] * (xx[37] - xx[38]);\n  xx[46] = - xx[23];\n  xx[47] = - xx[16];\n  xx[48] = - xx[20];\n  xx[49] = - xx[18];\n  pm_math_Quaternion_compose_ra(xx + 46, xx + 25, xx + 65);\n  xx[39] = xx[66] * xx[67];\n  xx[51] = xx[65] * xx[68];\n  xx[52] = xx[65] * xx[65];\n  xx[53] = xx[67] * xx[68];\n  xx[56] = xx[65] * xx[66];\n  xx[69] = xx[1] * (xx[39] - xx[51]);\n  xx[70] = xx[1] * (xx[52] + xx[67] * xx[67]) - xx[2];\n  xx[71] = xx[1] * (xx[53] + xx[56]);\n  xx[61] = xx[29] * xx[30];\n  xx[62] = xx[19] * xx[22];\n  xx[72] = xx[1] * (xx[32] - xx[35]);\n  xx[73] = xx[1] * (xx[31] + xx[29] * xx[29]) - xx[2];\n  xx[74] = xx[1] * (xx[61] + xx[62]);\n  xx[32] = xx[66] * xx[68];\n  xx[35] = xx[65] * xx[67];\n  xx[77] = xx[1] * (xx[32] + xx[35]);\n  xx[78] = xx[1] * (xx[53] - xx[56]);\n  xx[79] = xx[1] * (xx[52] + xx[68] * xx[68]) - xx[2];\n  xx[80] = xx[1] * (xx[37] + xx[38]);\n  xx[81] = xx[1] * (xx[61] - xx[62]);\n  xx[82] = xx[1] * (xx[31] + xx[30] * xx[30]) - xx[2];\n  xx[83] = xx[1] * (xx[52] + xx[66] * xx[66]) - xx[2];\n  xx[84] = xx[1] * (xx[39] + xx[51]);\n  xx[85] = xx[1] * (xx[32] - xx[35]);\n  xx[31] = xx[76] * xx[29];\n  xx[32] = xx[76] * xx[22];\n  pm_math_Quaternion_xform_ra(xx + 46, xx + 40, xx + 37);\n  xx[35] = xx[37] + xx[13] + xx[1] * (xx[23] * xx[20] + xx[16] * xx[18]);\n  xx[13] = xx[36] * xx[67];\n  xx[51] = xx[36] * xx[66];\n  xx[52] = xx[38] + xx[14] - xx[1] * (xx[23] * xx[16] - xx[20] * xx[18]);\n  xx[14] = xx[39] + xx[15] - xx[1] * (xx[16] * xx[16] + xx[20] * xx[20]) + xx[2];\n  xx[86] = pm_math_Vector3_dot_ra(xx + 43, xx + 69);\n  xx[87] = pm_math_Vector3_dot_ra(xx + 72, xx + 77);\n  xx[88] = pm_math_Vector3_dot_ra(xx + 80, xx + 83);\n  xx[89] = xx[1] * (xx[31] * xx[19] + xx[32] * xx[30]) + xx[21] - (xx[35] - xx[1]\n    * (xx[13] * xx[65] + xx[51] * xx[68]));\n  xx[90] = xx[1] * (xx[31] * xx[30] - xx[32] * xx[19]) + xx[12] - (xx[1] * (xx\n    [51] * xx[65] - xx[13] * xx[68]) + xx[52]);\n  xx[91] = xx[76] - xx[1] * (xx[32] * xx[22] + xx[31] * xx[29]) + xx[17] - (xx[1]\n    * (xx[51] * xx[66] + xx[13] * xx[67]) - xx[36] + xx[14]);\n  zeroMajor(1, 6, ii + 0, xx + 86);\n  xx[77] = fabs(xx[86]);\n  xx[78] = fabs(xx[87]);\n  xx[79] = fabs(xx[88]);\n  xx[80] = fabs(xx[89]);\n  xx[81] = fabs(xx[90]);\n  xx[82] = fabs(xx[91]);\n  ii[1] = 77;\n\n  {\n    int ll;\n    for (ll = 78; ll < 83; ++ll)\n      if (xx[ll] > xx[ii[1]])\n        ii[1] = ll;\n  }\n\n  ii[1] -= 77;\n  xx[13] = xx[77 + (ii[1])];\n  xx[15] = 1.0e-9;\n  if (!(!(xx[13] > xx[15]) && (bb[0] ? 1 : pm_math_Vector3_dot_ra(xx + 43, xx +\n         83) > xx[3] && pm_math_Vector3_dot_ra(xx + 72, xx + 69) > xx[3]))) {\n    return sm_ssci_recordRunTimeError(\n      \"physmod:sm:core:compiler:mechanism:mechanism:jointDisToNormPositionSatisfactionFailure\",\n      \"The position components of the kinematic constraints of the mechanism cannot be satisfied when attempting to transition joints from disengaged to normal mode. This is more likely to occur for large rotation errors compared to large translation errors. Consider reducing the error in those joints before attempting the transition or consider increasing the joint mode transition nonlinear iterations parameter in the associated Mechanism Configuration block.\",\n      neDiagMgr);\n  }\n\n  xx[13] = xx[101] * xx[101];\n  xx[16] = xx[102] * xx[102];\n  xx[18] = xx[2] - xx[1] * (xx[13] + xx[16]);\n  xx[20] = xx[100] * xx[101];\n  xx[23] = xx[99] * xx[102];\n  xx[31] = xx[1] * (xx[20] - xx[23]);\n  xx[32] = xx[99] * xx[101];\n  xx[37] = xx[100] * xx[102];\n  xx[38] = xx[1] * (xx[32] + xx[37]);\n  xx[43] = xx[18];\n  xx[44] = xx[31];\n  xx[45] = xx[38];\n  xx[39] = 1.1;\n  xx[51] = xx[6] * xx[6];\n  xx[53] = xx[1] * (xx[51] + xx[64]) - xx[2];\n  xx[56] = xx[1] * (xx[34] + xx[33]);\n  xx[33] = xx[1] * (xx[55] + xx[54]);\n  xx[34] = xx[1] * (xx[51] + xx[9]) - xx[2];\n  xx[9] = xx[1] * (xx[58] + xx[59]);\n  xx[54] = xx[1] * (xx[51] + xx[11]) - xx[2];\n  xx[77] = xx[53];\n  xx[78] = xx[95];\n  xx[79] = xx[56];\n  xx[80] = xx[33];\n  xx[81] = xx[34];\n  xx[82] = xx[60];\n  xx[83] = xx[57];\n  xx[84] = xx[9];\n  xx[85] = xx[54];\n  xx[11] = 0.1;\n  xx[86] = xx[11] * xx[53];\n  xx[87] = xx[11] * xx[33];\n  xx[88] = xx[11] * xx[57];\n  xx[89] = xx[11] * xx[95];\n  xx[90] = xx[11] * xx[34];\n  xx[91] = xx[11] * xx[9];\n  xx[92] = xx[11] * xx[56];\n  xx[93] = xx[11] * xx[60];\n  xx[94] = xx[11] * xx[54];\n  pm_math_Matrix3x3_compose_ra(xx + 77, xx + 86, xx + 126);\n  xx[51] = xx[39] + xx[126];\n  xx[55] = xx[39] + xx[130];\n  xx[86] = xx[51];\n  xx[87] = xx[127];\n  xx[88] = xx[128];\n  xx[89] = xx[129];\n  xx[90] = xx[55];\n  xx[91] = xx[131];\n  xx[92] = xx[132];\n  xx[93] = xx[133];\n  xx[94] = xx[39] + xx[134];\n  pm_math_Matrix3x3_xform_ra(xx + 86, xx + 43, xx + 69);\n  xx[39] = xx[1] * (xx[23] + xx[20]);\n  xx[20] = xx[100] * xx[100];\n  xx[23] = xx[2] - xx[1] * (xx[16] + xx[20]);\n  xx[16] = xx[101] * xx[102];\n  xx[58] = xx[99] * xx[100];\n  xx[59] = xx[1] * (xx[16] - xx[58]);\n  xx[72] = xx[39];\n  xx[73] = xx[23];\n  xx[74] = xx[59];\n  pm_math_Matrix3x3_xform_ra(xx + 86, xx + 72, xx + 135);\n  xx[61] = pm_math_Vector3_dot_ra(xx + 43, xx + 135);\n  xx[62] = xx[1] * (xx[37] - xx[32]);\n  xx[32] = xx[1] * (xx[58] + xx[16]);\n  xx[16] = xx[2] - xx[1] * (xx[20] + xx[13]);\n  xx[138] = xx[62];\n  xx[139] = xx[32];\n  xx[140] = xx[16];\n  pm_math_Matrix3x3_xform_ra(xx + 86, xx + 138, xx + 141);\n  xx[13] = pm_math_Vector3_dot_ra(xx + 43, xx + 141);\n  pm_math_Matrix3x3_postCross_ra(xx + 126, xx + 40, xx + 86);\n  xx[144] = - (xx[86] + xx[127]);\n  xx[145] = - (xx[89] + xx[55]);\n  xx[146] = - (xx[92] + xx[133]);\n  xx[20] = pm_math_Vector3_dot_ra(xx + 43, xx + 144);\n  xx[37] = xx[129] - xx[90];\n  xx[126] = xx[51] - xx[87];\n  xx[127] = xx[37];\n  xx[128] = xx[132] - xx[93];\n  xx[58] = pm_math_Vector3_dot_ra(xx + 43, xx + 126);\n  xx[129] = - xx[88];\n  xx[130] = - xx[91];\n  xx[131] = - xx[94];\n  xx[64] = pm_math_Vector3_dot_ra(xx + 43, xx + 129);\n  xx[75] = pm_math_Vector3_dot_ra(xx + 72, xx + 141);\n  xx[132] = pm_math_Vector3_dot_ra(xx + 72, xx + 144);\n  xx[133] = pm_math_Vector3_dot_ra(xx + 72, xx + 126);\n  xx[134] = pm_math_Vector3_dot_ra(xx + 72, xx + 129);\n  xx[147] = pm_math_Vector3_dot_ra(xx + 138, xx + 144);\n  xx[144] = pm_math_Vector3_dot_ra(xx + 138, xx + 126);\n  xx[126] = pm_math_Vector3_dot_ra(xx + 138, xx + 129);\n  xx[127] = 1.181250000000001e-4;\n  xx[128] = 1.0125e-4;\n  xx[148] = xx[127] * xx[53];\n  xx[149] = xx[127] * xx[33];\n  xx[150] = xx[127] * xx[57];\n  xx[151] = xx[127] * xx[95];\n  xx[152] = xx[127] * xx[34];\n  xx[153] = xx[127] * xx[9];\n  xx[154] = xx[128] * xx[56];\n  xx[155] = xx[128] * xx[60];\n  xx[156] = xx[128] * xx[54];\n  pm_math_Matrix3x3_compose_ra(xx + 77, xx + 148, xx + 157);\n  pm_math_Matrix3x3_preCross_ra(xx + 86, xx + 40, xx + 77);\n  xx[9] = xx[158] - xx[78] - xx[86] - xx[37];\n  xx[33] = xx[159] - xx[79] + xx[91];\n  xx[34] = xx[162] - xx[82] - xx[88];\n  xx[166] = pm_math_Vector3_dot_ra(xx + 43, xx + 69);\n  xx[167] = xx[61];\n  xx[168] = xx[13];\n  xx[169] = xx[20];\n  xx[170] = xx[58];\n  xx[171] = xx[64];\n  xx[172] = xx[61];\n  xx[173] = pm_math_Vector3_dot_ra(xx + 72, xx + 135);\n  xx[174] = xx[75];\n  xx[175] = xx[132];\n  xx[176] = xx[133];\n  xx[177] = xx[134];\n  xx[178] = xx[13];\n  xx[179] = xx[75];\n  xx[180] = pm_math_Vector3_dot_ra(xx + 138, xx + 141);\n  xx[181] = xx[147];\n  xx[182] = xx[144];\n  xx[183] = xx[126];\n  xx[184] = xx[20];\n  xx[185] = xx[132];\n  xx[186] = xx[147];\n  xx[187] = xx[157] - xx[77] + xx[89] + xx[89] + xx[55] + xx[2];\n  xx[188] = xx[9];\n  xx[189] = xx[33];\n  xx[190] = xx[58];\n  xx[191] = xx[133];\n  xx[192] = xx[144];\n  xx[193] = xx[9];\n  xx[194] = xx[161] - xx[81] - xx[87] + xx[51] - xx[87] + xx[2];\n  xx[195] = xx[34];\n  xx[196] = xx[64];\n  xx[197] = xx[134];\n  xx[198] = xx[126];\n  xx[199] = xx[33];\n  xx[200] = xx[34];\n  xx[201] = xx[2] + xx[165] - xx[85];\n  ii[1] = factorSymmetricPosDef(xx + 166, 6, xx + 53);\n  if (ii[1] != 0) {\n    return sm_ssci_recordRunTimeError(\n      \"physmod:sm:core:compiler:mechanism:mechanism:degenerateMassFoll\",\n      \"'simulation/Plant/ Rocket Body/Free Movement' has a degenerate mass distribution on its follower side.\",\n      neDiagMgr);\n  }\n\n  bb[1] = prevModeVector[0] == -1 && modeVector[0] == 0;\n  ii[1] = bb[1] ? 1 : 0;\n  ii[2] = ii[1] + ii[1] + ii[1] + ii[1] + ii[1] + ii[1];\n  ii[3] = ii[1];\n  ii[4] = ii[1];\n  ii[5] = ii[1];\n  ii[6] = ii[1];\n  ii[7] = ii[1];\n  ii[8] = ii[1];\n  sm_core_math_computeIndicesNonzeroElements(6, ii + 3, ii + 9);\n  xx[9] = xx[118] * xx[118];\n  xx[13] = xx[119] * xx[119];\n  xx[20] = xx[2] - xx[1] * (xx[9] + xx[13]);\n  xx[33] = xx[117] * xx[118];\n  xx[34] = xx[116] * xx[119];\n  xx[37] = xx[1] * (xx[33] - xx[34]);\n  xx[51] = xx[116] * xx[118];\n  xx[53] = xx[117] * xx[119];\n  xx[54] = xx[1] * (xx[51] + xx[53]);\n  xx[55] = xx[20];\n  xx[56] = xx[37];\n  xx[57] = xx[54];\n  xx[69] = xx[11] * xx[20];\n  xx[70] = xx[11] * xx[37];\n  xx[71] = xx[11] * xx[54];\n  xx[58] = xx[1] * (xx[34] + xx[33]);\n  xx[60] = xx[117] * xx[117];\n  xx[61] = xx[2] - xx[1] * (xx[13] + xx[60]);\n  xx[64] = xx[118] * xx[119];\n  xx[75] = xx[116] * xx[117];\n  xx[77] = xx[1] * (xx[64] - xx[75]);\n  xx[78] = xx[11] * xx[58];\n  xx[79] = xx[11] * xx[61];\n  xx[80] = xx[11] * xx[77];\n  xx[81] = pm_math_Vector3_dot_ra(xx + 55, xx + 78);\n  xx[82] = xx[1] * (xx[53] - xx[51]);\n  xx[83] = xx[1] * (xx[75] + xx[64]);\n  xx[84] = xx[2] - xx[1] * (xx[60] + xx[9]);\n  xx[85] = xx[11] * xx[82];\n  xx[86] = xx[11] * xx[83];\n  xx[87] = xx[11] * xx[84];\n  xx[11] = pm_math_Vector3_dot_ra(xx + 55, xx + 85);\n  xx[88] = xx[58];\n  xx[89] = xx[61];\n  xx[90] = xx[77];\n  xx[91] = pm_math_Vector3_dot_ra(xx + 88, xx + 85);\n  xx[92] = 6.750000000000001e-5;\n  xx[202] = pm_math_Vector3_dot_ra(xx + 55, xx + 69);\n  xx[203] = xx[81];\n  xx[204] = xx[11];\n  xx[205] = xx[0];\n  xx[206] = xx[0];\n  xx[207] = xx[0];\n  xx[208] = xx[81];\n  xx[209] = pm_math_Vector3_dot_ra(xx + 88, xx + 78);\n  xx[210] = xx[91];\n  xx[211] = xx[0];\n  xx[212] = xx[0];\n  xx[213] = xx[0];\n  xx[214] = xx[11];\n  xx[215] = xx[91];\n  xx[216] = pm_math_Vector3_dot_ra(xx + 82, xx + 85);\n  xx[217] = xx[0];\n  xx[218] = xx[0];\n  xx[219] = xx[0];\n  xx[220] = xx[0];\n  xx[221] = xx[0];\n  xx[222] = xx[0];\n  xx[223] = xx[92];\n  xx[224] = xx[0];\n  xx[225] = xx[0];\n  xx[226] = xx[0];\n  xx[227] = xx[0];\n  xx[228] = xx[0];\n  xx[229] = xx[0];\n  xx[230] = xx[92];\n  xx[231] = xx[0];\n  xx[232] = xx[0];\n  xx[233] = xx[0];\n  xx[234] = xx[0];\n  xx[235] = xx[0];\n  xx[236] = xx[0];\n  xx[237] = xx[128];\n  ii[1] = factorSymmetricPosDef(xx + 202, 6, xx + 126);\n  if (ii[1] != 0) {\n    return sm_ssci_recordRunTimeError(\n      \"physmod:sm:core:compiler:mechanism:mechanism:degenerateMassImplicit6Dof\",\n      \"An implicit 6-DOF joint is attached to a degenerate mass distribution.\",\n      neDiagMgr);\n  }\n\n  xx[11] = bb[1] ? xx[63] : xx[0];\n  xx[126] = xx[0];\n  xx[127] = xx[0];\n  xx[128] = xx[0];\n  xx[129] = xx[11];\n  xx[130] = xx[0];\n  xx[131] = xx[0];\n  solveSymmetricPosDef(xx + 202, xx + 126, 6, 1, xx + 132, xx + 141);\n  xx[78] = - xx[19];\n  xx[79] = - xx[22];\n  xx[80] = - xx[29];\n  xx[81] = - xx[30];\n  pm_math_Quaternion_inverseCompose_ra(xx + 78, xx + 65, xx + 91);\n  xx[65] = - xx[91];\n  xx[66] = - xx[92];\n  xx[67] = - xx[93];\n  xx[68] = - xx[94];\n  xx[19] = bb[1] ? xx[10] : xx[0];\n  xx[22] = xx[8] * xx[19];\n  xx[29] = xx[22] * xx[8];\n  xx[30] = xx[4] * xx[19];\n  xx[69] = xx[30] * xx[4];\n  xx[70] = xx[1] * (xx[29] + xx[69]);\n  xx[71] = xx[30] * xx[6];\n  xx[85] = xx[1] * (xx[71] + xx[22] * xx[5]);\n  xx[86] = xx[22] * xx[6];\n  xx[87] = xx[1] * (xx[86] - xx[30] * xx[5]);\n  xx[126] = xx[0];\n  xx[127] = xx[0];\n  xx[128] = xx[0];\n  xx[129] = xx[19] - xx[70];\n  xx[130] = xx[85];\n  xx[131] = - xx[87];\n  solveSymmetricPosDef(xx + 166, xx + 126, 6, 1, xx + 141, xx + 147);\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 144, xx + 91);\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 91, xx + 126);\n  xx[91] = xx[135] - xx[126];\n  xx[92] = xx[136] - xx[127];\n  xx[93] = bb[0] ? xx[0] : xx[76];\n  xx[94] = xx[76] * xx[63];\n  xx[95] = xx[93] - xx[94];\n  xx[129] = xx[35] - xx[21];\n  xx[130] = xx[52] - xx[12];\n  xx[131] = xx[14] - xx[17];\n  pm_math_Quaternion_inverseXform_ra(xx + 78, xx + 129, xx + 147);\n  xx[129] = xx[147];\n  xx[130] = xx[148];\n  xx[131] = xx[149] - xx[76];\n  pm_math_Vector3_cross_ra(xx + 129, xx + 126, xx + 147);\n  pm_math_Vector3_cross_ra(xx + 144, xx + 40, xx + 150);\n  xx[153] = xx[18] * xx[141] + xx[39] * xx[142] + xx[62] * xx[143] + xx[145] +\n    xx[150];\n  xx[154] = xx[31] * xx[141] + xx[23] * xx[142] + xx[32] * xx[143] - xx[144] +\n    xx[151];\n  xx[155] = xx[38] * xx[141] + xx[59] * xx[142] + xx[16] * xx[143] + xx[152];\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 153, xx + 141);\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 141, xx + 144);\n  xx[12] = bb[0] ? xx[0] : - xx[76];\n  xx[14] = xx[12] + xx[94];\n  xx[150] = xx[0];\n  xx[151] = xx[0];\n  xx[152] = xx[0];\n  xx[153] = xx[0];\n  xx[154] = xx[11];\n  xx[155] = xx[0];\n  solveSymmetricPosDef(xx + 202, xx + 150, 6, 1, xx + 156, xx + 238);\n  xx[17] = xx[5] * xx[19];\n  xx[21] = xx[1] * (xx[71] - xx[17] * xx[8]);\n  xx[35] = xx[17] * xx[5];\n  xx[52] = xx[1] * (xx[69] + xx[35]);\n  xx[69] = xx[17] * xx[6];\n  xx[71] = xx[1] * (xx[69] + xx[30] * xx[8]);\n  xx[150] = xx[0];\n  xx[151] = xx[0];\n  xx[152] = xx[0];\n  xx[153] = - xx[21];\n  xx[154] = xx[19] - xx[52];\n  xx[155] = xx[71];\n  solveSymmetricPosDef(xx + 166, xx + 150, 6, 1, xx + 238, xx + 244);\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 241, xx + 141);\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 141, xx + 150);\n  xx[30] = xx[159] - xx[150];\n  xx[94] = xx[160] - xx[151];\n  pm_math_Vector3_cross_ra(xx + 129, xx + 150, xx + 141);\n  pm_math_Vector3_cross_ra(xx + 241, xx + 40, xx + 153);\n  xx[162] = xx[18] * xx[238] + xx[39] * xx[239] + xx[62] * xx[240] + xx[242] +\n    xx[153];\n  xx[163] = xx[31] * xx[238] + xx[23] * xx[239] + xx[32] * xx[240] - xx[241] +\n    xx[154];\n  xx[164] = xx[38] * xx[238] + xx[59] * xx[239] + xx[16] * xx[240] + xx[155];\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 162, xx + 153);\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 153, xx + 162);\n  xx[238] = xx[0];\n  xx[239] = xx[0];\n  xx[240] = xx[0];\n  xx[241] = xx[0];\n  xx[242] = xx[0];\n  xx[243] = xx[11];\n  solveSymmetricPosDef(xx + 202, xx + 238, 6, 1, xx + 244, xx + 250);\n  xx[126] = xx[1] * (xx[86] + xx[17] * xx[4]);\n  xx[17] = xx[1] * (xx[69] - xx[22] * xx[4]);\n  xx[22] = xx[1] * (xx[35] + xx[29]);\n  xx[238] = xx[0];\n  xx[239] = xx[0];\n  xx[240] = xx[0];\n  xx[241] = xx[126];\n  xx[242] = - xx[17];\n  xx[243] = xx[19] - xx[22];\n  solveSymmetricPosDef(xx + 166, xx + 238, 6, 1, xx + 250, xx + 256);\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 253, xx + 153);\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 153, xx + 238);\n  xx[29] = xx[247] - xx[238];\n  xx[35] = xx[248] - xx[239];\n  pm_math_Vector3_cross_ra(xx + 129, xx + 238, xx + 153);\n  pm_math_Vector3_cross_ra(xx + 253, xx + 40, xx + 241);\n  xx[255] = xx[18] * xx[250] + xx[39] * xx[251] + xx[62] * xx[252] + xx[254] +\n    xx[241];\n  xx[256] = xx[31] * xx[250] + xx[23] * xx[251] + xx[32] * xx[252] - xx[253] +\n    xx[242];\n  xx[257] = xx[38] * xx[250] + xx[59] * xx[251] + xx[16] * xx[252] + xx[243];\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 255, xx + 241);\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 241, xx + 250);\n  xx[253] = xx[20] * xx[11];\n  xx[254] = xx[58] * xx[11];\n  xx[255] = xx[82] * xx[11];\n  xx[256] = xx[0];\n  xx[257] = bb[1] ? xx[93] : xx[0];\n  xx[258] = xx[0];\n  solveSymmetricPosDef(xx + 202, xx + 253, 6, 1, xx + 259, xx + 265);\n  xx[69] = xx[70] - xx[19];\n  xx[241] = xx[69];\n  xx[242] = - xx[85];\n  xx[243] = xx[87];\n  xx[70] = bb[0] ? xx[0] : xx[36];\n  xx[86] = bb[1] ? xx[70] : xx[0];\n  xx[87] = xx[4] * xx[86];\n  xx[127] = xx[5] * xx[86];\n  pm_math_Vector3_cross_ra(xx + 40, xx + 241, xx + 253);\n  xx[265] = - pm_math_Vector3_dot_ra(xx + 43, xx + 241);\n  xx[266] = - pm_math_Vector3_dot_ra(xx + 72, xx + 241);\n  xx[267] = - pm_math_Vector3_dot_ra(xx + 138, xx + 241);\n  xx[268] = - (xx[1] * (xx[87] * xx[6] - xx[127] * xx[8]) + xx[253] + xx[85]);\n  xx[269] = - (xx[1] * (xx[87] * xx[4] + xx[127] * xx[5]) - xx[86] + xx[254] +\n               xx[69]);\n  xx[270] = xx[1] * (xx[127] * xx[6] + xx[87] * xx[8]) - xx[255];\n  solveSymmetricPosDef(xx + 166, xx + 265, 6, 1, xx + 253, xx + 271);\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 256, xx + 85);\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 85, xx + 241);\n  xx[69] = xx[262] - xx[241];\n  xx[85] = xx[263] - xx[242];\n  pm_math_Vector3_cross_ra(xx + 129, xx + 241, xx + 265);\n  pm_math_Vector3_cross_ra(xx + 256, xx + 40, xx + 268);\n  xx[271] = xx[18] * xx[253] + xx[39] * xx[254] + xx[62] * xx[255] + xx[257] +\n    xx[268];\n  xx[272] = xx[31] * xx[253] + xx[23] * xx[254] + xx[32] * xx[255] - xx[256] +\n    xx[269];\n  xx[273] = xx[38] * xx[253] + xx[59] * xx[254] + xx[16] * xx[255] + xx[270];\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 271, xx + 253);\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 253, xx + 256);\n  xx[268] = xx[37] * xx[11];\n  xx[269] = xx[61] * xx[11];\n  xx[270] = xx[83] * xx[11];\n  xx[271] = bb[1] ? xx[12] : xx[0];\n  xx[272] = xx[0];\n  xx[273] = xx[0];\n  solveSymmetricPosDef(xx + 202, xx + 268, 6, 1, xx + 274, xx + 280);\n  xx[86] = xx[52] - xx[19];\n  xx[253] = xx[21];\n  xx[254] = xx[86];\n  xx[255] = - xx[71];\n  xx[52] = bb[0] ? xx[0] : - xx[36];\n  xx[71] = bb[1] ? xx[52] : xx[0];\n  xx[87] = xx[8] * xx[71];\n  xx[127] = xx[4] * xx[71];\n  pm_math_Vector3_cross_ra(xx + 40, xx + 253, xx + 268);\n  xx[280] = - pm_math_Vector3_dot_ra(xx + 43, xx + 253);\n  xx[281] = - pm_math_Vector3_dot_ra(xx + 72, xx + 253);\n  xx[282] = - pm_math_Vector3_dot_ra(xx + 138, xx + 253);\n  xx[283] = xx[86] - (xx[1] * (xx[87] * xx[8] + xx[127] * xx[4]) - xx[71] + xx\n                      [268]);\n  xx[284] = - (xx[269] - xx[1] * (xx[127] * xx[6] + xx[87] * xx[5]) + xx[21]);\n  xx[285] = - (xx[1] * (xx[87] * xx[6] - xx[127] * xx[5]) + xx[270]);\n  solveSymmetricPosDef(xx + 166, xx + 280, 6, 1, xx + 268, xx + 286);\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 271, xx + 4);\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 4, xx + 253);\n  xx[4] = xx[277] - xx[253];\n  xx[5] = xx[278] - xx[254];\n  pm_math_Vector3_cross_ra(xx + 129, xx + 253, xx + 280);\n  pm_math_Vector3_cross_ra(xx + 271, xx + 40, xx + 283);\n  xx[286] = xx[18] * xx[268] + xx[39] * xx[269] + xx[62] * xx[270] + xx[272] +\n    xx[283];\n  xx[287] = xx[31] * xx[268] + xx[23] * xx[269] + xx[32] * xx[270] - xx[271] +\n    xx[284];\n  xx[288] = xx[38] * xx[268] + xx[59] * xx[269] + xx[16] * xx[270] + xx[285];\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 286, xx + 268);\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 268, xx + 271);\n  xx[283] = xx[54] * xx[11];\n  xx[284] = xx[77] * xx[11];\n  xx[285] = xx[84] * xx[11];\n  xx[286] = xx[0];\n  xx[287] = xx[0];\n  xx[288] = xx[0];\n  solveSymmetricPosDef(xx + 202, xx + 283, 6, 1, xx + 289, xx + 295);\n  xx[268] = - xx[126];\n  xx[269] = xx[17];\n  xx[270] = xx[22] - xx[19];\n  pm_math_Vector3_cross_ra(xx + 40, xx + 268, xx + 283);\n  xx[295] = - pm_math_Vector3_dot_ra(xx + 43, xx + 268);\n  xx[296] = - pm_math_Vector3_dot_ra(xx + 72, xx + 268);\n  xx[297] = - pm_math_Vector3_dot_ra(xx + 138, xx + 268);\n  xx[298] = xx[17] - xx[283];\n  xx[299] = xx[126] - xx[284];\n  xx[300] = - xx[285];\n  solveSymmetricPosDef(xx + 166, xx + 295, 6, 1, xx + 283, xx + 301);\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 286, xx + 268);\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 268, xx + 295);\n  xx[6] = xx[292] - xx[295];\n  xx[8] = xx[293] - xx[296];\n  pm_math_Vector3_cross_ra(xx + 129, xx + 295, xx + 268);\n  pm_math_Vector3_cross_ra(xx + 286, xx + 40, xx + 298);\n  xx[301] = xx[18] * xx[283] + xx[39] * xx[284] + xx[62] * xx[285] + xx[287] +\n    xx[298];\n  xx[302] = xx[31] * xx[283] + xx[23] * xx[284] + xx[32] * xx[285] - xx[286] +\n    xx[299];\n  xx[303] = xx[38] * xx[283] + xx[59] * xx[284] + xx[16] * xx[285] + xx[300];\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 301, xx + 16);\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 16, xx + 21);\n  xx[298] = xx[91] * xx[63];\n  xx[299] = xx[92] * xx[63];\n  xx[300] = (xx[137] - xx[128]) * xx[63];\n  xx[301] = xx[92] * xx[95] + (xx[20] * xx[132] + xx[58] * xx[133] + xx[82] *\n    xx[134] + xx[76] * xx[136] - (xx[147] + xx[144])) * xx[63];\n  xx[302] = xx[91] * xx[14] + (xx[37] * xx[132] + xx[61] * xx[133] + xx[83] *\n    xx[134] - xx[76] * xx[135] - (xx[148] + xx[145])) * xx[63];\n  xx[303] = (xx[54] * xx[132] + xx[77] * xx[133] + xx[84] * xx[134] - (xx[149] +\n              xx[146])) * xx[63];\n  xx[304] = xx[30] * xx[63];\n  xx[305] = xx[94] * xx[63];\n  xx[306] = (xx[161] - xx[152]) * xx[63];\n  xx[307] = xx[94] * xx[95] + (xx[20] * xx[156] + xx[58] * xx[157] + xx[82] *\n    xx[158] + xx[76] * xx[160] - (xx[141] + xx[162])) * xx[63];\n  xx[308] = xx[30] * xx[14] + (xx[37] * xx[156] + xx[61] * xx[157] + xx[83] *\n    xx[158] - xx[76] * xx[159] - (xx[142] + xx[163])) * xx[63];\n  xx[309] = (xx[54] * xx[156] + xx[77] * xx[157] + xx[84] * xx[158] - (xx[143] +\n              xx[164])) * xx[63];\n  xx[310] = xx[29] * xx[63];\n  xx[311] = xx[35] * xx[63];\n  xx[312] = (xx[249] - xx[240]) * xx[63];\n  xx[313] = xx[35] * xx[95] + (xx[20] * xx[244] + xx[58] * xx[245] + xx[82] *\n    xx[246] + xx[76] * xx[248] - (xx[153] + xx[250])) * xx[63];\n  xx[314] = xx[29] * xx[14] + (xx[37] * xx[244] + xx[61] * xx[245] + xx[83] *\n    xx[246] - xx[76] * xx[247] - (xx[154] + xx[251])) * xx[63];\n  xx[315] = (xx[54] * xx[244] + xx[77] * xx[245] + xx[84] * xx[246] - (xx[155] +\n              xx[252])) * xx[63];\n  xx[316] = xx[69] * xx[63];\n  xx[317] = xx[85] * xx[63];\n  xx[318] = (xx[264] - xx[243]) * xx[63];\n  xx[319] = xx[85] * xx[95] + (xx[20] * xx[259] + xx[58] * xx[260] + xx[82] *\n    xx[261] + xx[76] * xx[263] - (xx[265] + xx[256])) * xx[63];\n  xx[320] = xx[69] * xx[14] + (xx[37] * xx[259] + xx[61] * xx[260] + xx[83] *\n    xx[261] - xx[76] * xx[262] - (xx[266] + xx[257])) * xx[63];\n  xx[321] = (xx[54] * xx[259] + xx[77] * xx[260] + xx[84] * xx[261] - (xx[267] +\n              xx[258])) * xx[63];\n  xx[322] = xx[4] * xx[63];\n  xx[323] = xx[5] * xx[63];\n  xx[324] = (xx[279] - xx[255]) * xx[63];\n  xx[325] = xx[5] * xx[95] + (xx[20] * xx[274] + xx[58] * xx[275] + xx[82] * xx\n    [276] + xx[76] * xx[278] - (xx[280] + xx[271])) * xx[63];\n  xx[326] = xx[4] * xx[14] + (xx[37] * xx[274] + xx[61] * xx[275] + xx[83] * xx\n    [276] - xx[76] * xx[277] - (xx[281] + xx[272])) * xx[63];\n  xx[327] = (xx[54] * xx[274] + xx[77] * xx[275] + xx[84] * xx[276] - (xx[282] +\n              xx[273])) * xx[63];\n  xx[328] = xx[6] * xx[63];\n  xx[329] = xx[8] * xx[63];\n  xx[330] = (xx[294] - xx[297]) * xx[63];\n  xx[331] = xx[8] * xx[95] + (xx[20] * xx[289] + xx[58] * xx[290] + xx[82] * xx\n    [291] + xx[76] * xx[293] - (xx[268] + xx[21])) * xx[63];\n  xx[332] = xx[6] * xx[14] + (xx[37] * xx[289] + xx[61] * xx[290] + xx[83] * xx\n    [291] - xx[76] * xx[292] - (xx[269] + xx[22])) * xx[63];\n  xx[333] = (xx[54] * xx[289] + xx[77] * xx[290] + xx[84] * xx[291] - (xx[270] +\n              xx[23])) * xx[63];\n  reduceMatrix(6, 6, ii[2], ii + 9, xx + 298);\n  transposeColMajor(6, ii[2], xx + 298, xx + 238);\n  reduceMatrix(ii[2], 6, ii[2], ii + 9, xx + 238);\n  transposeColMajor(ii[2], ii[2], xx + 238, xx + 274);\n  svd(ii[2], ii[2], xx + 274, TRUE, xx + 16, xx + 238, xx + 310, xx + 346);\n  bb[0] = ii[2] > 0 ? xx[16] > 9.999999999999999e-21 : 1;\n  xx[4] = state[10];\n  xx[5] = state[11];\n  xx[6] = state[12];\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 4, xx + 29);\n  xx[8] = (xx[2] - xx[1] * xx[7] * xx[7]) * state[15];\n  xx[85] = xx[29] + xx[8];\n  xx[86] = xx[30] + state[16];\n  xx[87] = xx[31] + xx[1] * xx[24] * xx[7] * state[15];\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 85, xx + 22);\n  xx[7] = state[27] - xx[22];\n  xx[11] = state[28] - xx[23];\n  xx[29] = state[24];\n  xx[30] = state[25];\n  xx[31] = state[26];\n  pm_math_Quaternion_inverseXform_ra(xx + 78, xx + 29, xx + 85);\n  pm_math_Vector3_cross_ra(xx + 129, xx + 22, xx + 29);\n  pm_math_Vector3_cross_ra(xx + 4, xx + 40, xx + 78);\n  xx[4] = state[7];\n  xx[5] = state[8];\n  xx[6] = state[9];\n  pm_math_Quaternion_inverseXform_ra(xx + 46, xx + 4, xx + 126);\n  xx[4] = xx[78] + xx[126] + state[11];\n  xx[5] = xx[79] + xx[127] - state[10];\n  xx[6] = xx[80] + xx[128];\n  pm_math_Quaternion_inverseXform_ra(xx + 25, xx + 4, xx + 46);\n  xx[4] = xx[46] - xx[50] * state[16];\n  xx[5] = xx[47] + xx[50] * xx[8];\n  xx[6] = xx[48];\n  pm_math_Quaternion_xform_ra(xx + 65, xx + 4, xx + 46);\n  xx[126] = - (xx[7] * xx[63]);\n  xx[127] = - (xx[11] * xx[63]);\n  xx[128] = - ((state[29] - xx[24]) * xx[63]);\n  xx[129] = - (xx[11] * xx[95] + (xx[85] + xx[76] * state[28] - (xx[29] + xx[46]))\n               * xx[63]);\n  xx[130] = - (xx[7] * xx[14] + (xx[86] - xx[76] * state[27] - (xx[30] + xx[47]))\n               * xx[63]);\n  xx[131] = - ((xx[87] - (xx[31] + xx[48])) * xx[63]);\n  reduceMatrix(1, 6, ii[2], ii + 9, xx + 126);\n  ii[1] = svdSolveFromFactorization(ii[2], ii[2], xx + 16, xx + 238, xx + 310,\n    xx + 126, 1.0e-12, xx + 132, xx + 141);\n  xx[16] = bb[0] ? xx[132] : xx[0];\n  xx[17] = bb[0] ? xx[133] : xx[0];\n  xx[18] = bb[0] ? xx[134] : xx[0];\n  xx[19] = bb[0] ? xx[135] : xx[0];\n  xx[20] = bb[0] ? xx[136] : xx[0];\n  xx[21] = bb[0] ? xx[137] : xx[0];\n  expandVector(6, ii[2], ii + 9, xx + 16);\n  xx[4] = - (xx[19] * xx[10]);\n  xx[5] = - (xx[20] * xx[10]);\n  xx[6] = - (xx[21] * xx[10]);\n  pm_math_Quaternion_xform_ra(xx + 25, xx + 4, xx + 22);\n  xx[4] = - (xx[16] * xx[10] + xx[20] * xx[52]);\n  xx[5] = - (xx[17] * xx[10] + xx[19] * xx[70]);\n  xx[6] = - (xx[18] * xx[10]);\n  pm_math_Quaternion_xform_ra(xx + 25, xx + 4, xx + 29);\n  pm_math_Vector3_cross_ra(xx + 40, xx + 22, xx + 4);\n  xx[65] = - pm_math_Vector3_dot_ra(xx + 43, xx + 22);\n  xx[66] = - pm_math_Vector3_dot_ra(xx + 72, xx + 22);\n  xx[67] = - pm_math_Vector3_dot_ra(xx + 138, xx + 22);\n  xx[68] = xx[23] - (xx[29] + xx[4]);\n  xx[69] = - (xx[30] + xx[5] + xx[22]);\n  xx[70] = - (xx[31] + xx[6]);\n  solveSymmetricPosDef(xx + 166, xx + 65, 6, 1, xx + 22, xx + 38);\n  xx[0] = xx[103] + xx[22];\n  xx[4] = xx[104] + xx[23];\n  xx[5] = xx[105] + xx[24];\n  xx[6] = xx[106] + xx[25];\n  xx[7] = xx[107] + xx[26];\n  xx[8] = xx[108] + xx[27];\n  xx[22] = - (xx[19] * xx[63]);\n  xx[23] = - (xx[20] * xx[63]);\n  xx[24] = - (xx[21] * xx[63]);\n  xx[25] = - pm_math_Vector3_dot_ra(xx + 55, xx + 22);\n  xx[26] = - pm_math_Vector3_dot_ra(xx + 88, xx + 22);\n  xx[27] = - pm_math_Vector3_dot_ra(xx + 82, xx + 22);\n  xx[28] = xx[16] * xx[63] + xx[20] * xx[12];\n  xx[29] = xx[17] * xx[63] + xx[19] * xx[93];\n  xx[30] = xx[18] * xx[63];\n  solveSymmetricPosDef(xx + 202, xx + 25, 6, 1, xx + 16, xx + 38);\n  xx[10] = xx[120] + xx[16];\n  xx[11] = xx[121] + xx[17];\n  xx[12] = xx[122] + xx[18];\n  xx[14] = xx[123] + xx[19];\n  xx[22] = xx[124] + xx[20];\n  xx[16] = xx[125] + xx[21];\n  xx[120] = xx[96];\n  xx[121] = xx[97];\n  xx[122] = xx[98];\n  xx[123] = xx[99];\n  xx[124] = xx[100];\n  xx[125] = xx[101];\n  xx[126] = xx[102];\n  xx[127] = xx[0];\n  xx[128] = xx[4];\n  xx[129] = xx[5];\n  xx[130] = xx[6];\n  xx[131] = xx[7];\n  xx[132] = xx[8];\n  xx[133] = xx[109];\n  xx[134] = xx[110];\n  xx[135] = xx[111];\n  xx[136] = xx[112];\n  xx[137] = xx[113];\n  xx[138] = xx[114];\n  xx[139] = xx[115];\n  xx[140] = xx[116];\n  xx[141] = xx[117];\n  xx[142] = xx[118];\n  xx[143] = xx[119];\n  xx[144] = xx[10];\n  xx[145] = xx[11];\n  xx[146] = xx[12];\n  xx[147] = xx[14];\n  xx[148] = xx[22];\n  xx[149] = xx[16];\n  xx[17] = - xx[117];\n  xx[18] = - xx[118];\n  xx[19] = - xx[119];\n  xx[20] = xx[22] * xx[118];\n  xx[21] = xx[16] * xx[119];\n  xx[23] = xx[20] + xx[21];\n  xx[24] = xx[22] * xx[117];\n  xx[25] = xx[16] * xx[117];\n  xx[26] = xx[23];\n  xx[27] = - xx[24];\n  xx[28] = - xx[25];\n  pm_math_Vector3_cross_ra(xx + 17, xx + 26, xx + 29);\n  xx[26] = xx[1] * (xx[29] - xx[23] * xx[116]);\n  xx[27] = xx[16] + xx[1] * (xx[24] * xx[116] + xx[30]);\n  xx[28] = xx[1] * (xx[25] * xx[116] + xx[31]) - xx[22];\n  xx[23] = - xx[100];\n  xx[24] = - xx[101];\n  xx[25] = - xx[102];\n  xx[29] = - xx[99];\n  xx[30] = xx[23];\n  xx[31] = xx[24];\n  xx[32] = xx[25];\n  xx[35] = xx[3] * xx[109];\n  xx[38] = cos(xx[35]);\n  xx[39] = xx[3] * xx[110];\n  xx[3] = cos(xx[39]);\n  xx[40] = xx[38] * xx[3];\n  xx[41] = sin(xx[35]);\n  xx[35] = xx[3] * xx[41];\n  xx[3] = - xx[35];\n  xx[42] = sin(xx[39]);\n  xx[39] = xx[38] * xx[42];\n  xx[38] = - xx[39];\n  xx[43] = xx[41] * xx[42];\n  xx[41] = - xx[43];\n  xx[44] = - xx[40];\n  xx[45] = xx[3];\n  xx[46] = xx[38];\n  xx[47] = xx[41];\n  pm_math_Quaternion_compose_ra(xx + 29, xx + 44, xx + 54);\n  xx[42] = xx[55] * xx[56];\n  xx[48] = xx[54] * xx[57];\n  xx[49] = xx[54] * xx[54];\n  xx[52] = xx[56] * xx[57];\n  xx[58] = xx[54] * xx[55];\n  xx[61] = xx[1] * (xx[42] - xx[48]);\n  xx[62] = xx[1] * (xx[49] + xx[56] * xx[56]) - xx[2];\n  xx[63] = xx[1] * (xx[52] + xx[58]);\n  pm_math_Quaternion_inverseXform_ra(xx + 44, xx + 6, xx + 65);\n  xx[44] = (xx[2] - xx[1] * (xx[39] * xx[39] + xx[43] * xx[43])) * xx[111];\n  xx[45] = xx[65] + xx[44];\n  xx[46] = xx[45] * xx[56];\n  xx[47] = xx[67] + xx[1] * (xx[40] * xx[39] + xx[35] * xx[43]) * xx[111];\n  xx[59] = xx[47] * xx[57];\n  xx[68] = xx[45] * xx[55];\n  xx[69] = xx[59] + xx[68];\n  xx[70] = xx[47] * xx[56];\n  xx[71] = xx[46];\n  xx[72] = - xx[69];\n  xx[73] = xx[70];\n  pm_math_Vector3_cross_ra(xx + 55, xx + 71, xx + 78);\n  xx[71] = xx[1] * (xx[46] * xx[54] + xx[78]) - xx[47];\n  xx[72] = xx[1] * (xx[79] - xx[69] * xx[54]);\n  xx[73] = xx[45] + xx[1] * (xx[70] * xx[54] + xx[80]);\n  xx[46] = xx[116] * xx[116];\n  xx[78] = xx[1] * (xx[46] + xx[60]) - xx[2];\n  xx[79] = xx[1] * (xx[33] + xx[34]);\n  xx[80] = xx[82];\n  xx[33] = xx[14] * xx[118];\n  xx[34] = xx[14] * xx[117];\n  xx[60] = xx[21] + xx[34];\n  xx[21] = xx[16] * xx[118];\n  xx[81] = - xx[33];\n  xx[82] = xx[60];\n  xx[83] = - xx[21];\n  pm_math_Vector3_cross_ra(xx + 17, xx + 81, xx + 84);\n  xx[81] = xx[1] * (xx[33] * xx[116] + xx[84]) - xx[16];\n  xx[82] = xx[1] * (xx[85] - xx[60] * xx[116]);\n  xx[83] = xx[14] + xx[1] * (xx[21] * xx[116] + xx[86]);\n  xx[16] = xx[55] * xx[57];\n  xx[21] = xx[54] * xx[56];\n  xx[84] = xx[1] * (xx[16] + xx[21]);\n  xx[85] = xx[1] * (xx[52] - xx[58]);\n  xx[86] = xx[1] * (xx[49] + xx[57] * xx[57]) - xx[2];\n  xx[33] = xx[1] * (xx[39] * xx[35] - xx[40] * xx[43]) * xx[111] + xx[112];\n  xx[52] = xx[66] + xx[33];\n  xx[58] = xx[45] * xx[57];\n  xx[60] = xx[52] * xx[57];\n  xx[65] = xx[52] * xx[56];\n  xx[66] = xx[68] + xx[65];\n  xx[67] = xx[58];\n  xx[68] = xx[60];\n  xx[69] = - xx[66];\n  pm_math_Vector3_cross_ra(xx + 55, xx + 67, xx + 87);\n  xx[67] = xx[52] + xx[1] * (xx[58] * xx[54] + xx[87]);\n  xx[68] = xx[1] * (xx[60] * xx[54] + xx[88]) - xx[45];\n  xx[69] = xx[1] * (xx[89] - xx[66] * xx[54]);\n  xx[87] = xx[37];\n  xx[88] = xx[1] * (xx[46] + xx[9]) - xx[2];\n  xx[89] = xx[1] * (xx[64] + xx[75]);\n  xx[9] = xx[14] * xx[119];\n  xx[37] = xx[22] * xx[119];\n  xx[58] = xx[34] + xx[20];\n  xx[90] = - xx[9];\n  xx[91] = - xx[37];\n  xx[92] = xx[58];\n  pm_math_Vector3_cross_ra(xx + 17, xx + 90, xx + 93);\n  xx[90] = xx[22] + xx[1] * (xx[9] * xx[116] + xx[93]);\n  xx[91] = xx[1] * (xx[37] * xx[116] + xx[94]) - xx[14];\n  xx[92] = xx[1] * (xx[95] - xx[58] * xx[116]);\n  xx[93] = xx[1] * (xx[49] + xx[55] * xx[55]) - xx[2];\n  xx[94] = xx[1] * (xx[42] + xx[48]);\n  xx[95] = xx[1] * (xx[16] - xx[21]);\n  xx[9] = xx[65] + xx[59];\n  xx[16] = xx[52] * xx[55];\n  xx[20] = xx[47] * xx[55];\n  xx[58] = - xx[9];\n  xx[59] = xx[16];\n  xx[60] = xx[20];\n  pm_math_Vector3_cross_ra(xx + 55, xx + 58, xx + 64);\n  xx[58] = xx[1] * (xx[64] - xx[9] * xx[54]);\n  xx[59] = xx[47] + xx[1] * (xx[16] * xx[54] + xx[65]);\n  xx[60] = xx[1] * (xx[20] * xx[54] + xx[66]) - xx[52];\n  xx[47] = xx[1] * (xx[53] + xx[51]);\n  xx[48] = xx[77];\n  xx[49] = xx[1] * (xx[46] + xx[13]) - xx[2];\n  xx[2] = xx[76] * xx[22];\n  xx[9] = xx[76] * xx[14];\n  xx[13] = xx[9] * xx[119];\n  xx[14] = xx[2] * xx[119];\n  xx[16] = xx[9] * xx[117] + xx[2] * xx[118];\n  xx[20] = - xx[13];\n  xx[21] = - xx[14];\n  xx[22] = xx[16];\n  pm_math_Vector3_cross_ra(xx + 17, xx + 20, xx + 64);\n  xx[17] = xx[36] * xx[45];\n  xx[18] = xx[17] * xx[57];\n  xx[19] = xx[36] * xx[52];\n  xx[20] = xx[19] * xx[57];\n  xx[21] = xx[17] * xx[55] + xx[19] * xx[56];\n  xx[51] = - xx[18];\n  xx[52] = - xx[20];\n  xx[53] = xx[21];\n  pm_math_Vector3_cross_ra(xx + 55, xx + 51, xx + 74);\n  xx[22] = xx[6] * xx[102];\n  xx[34] = xx[7] * xx[102];\n  xx[36] = xx[6] * xx[100] + xx[7] * xx[101];\n  xx[51] = - xx[22];\n  xx[52] = - xx[34];\n  xx[53] = xx[36];\n  pm_math_Vector3_cross_ra(xx + 23, xx + 51, xx + 55);\n  xx[23] = xx[3];\n  xx[24] = xx[38];\n  xx[25] = xx[41];\n  xx[3] = xx[50] * xx[44];\n  xx[37] = xx[3] * xx[43];\n  xx[38] = xx[50] * xx[33];\n  xx[33] = xx[38] * xx[43];\n  xx[41] = xx[3] * xx[35] + xx[38] * xx[39];\n  xx[44] = xx[37];\n  xx[45] = xx[33];\n  xx[46] = - xx[41];\n  pm_math_Vector3_cross_ra(xx + 23, xx + 44, xx + 51);\n  xx[23] = xx[50] * xx[39];\n  xx[24] = xx[50] * xx[35];\n  xx[44] = - (xx[1] * (xx[23] * xx[40] + xx[24] * xx[43]));\n  xx[45] = xx[1] * (xx[24] * xx[40] - xx[23] * xx[43]);\n  xx[46] = xx[1] * (xx[24] * xx[35] + xx[23] * xx[39]) - 1.045;\n  pm_math_Vector3_cross_ra(xx + 6, xx + 44, xx + 23);\n  xx[42] = xx[1] * (xx[51] - xx[37] * xx[40]) - xx[38] + xx[23];\n  xx[43] = xx[1] * (xx[52] - xx[33] * xx[40]) + xx[3] + xx[24];\n  xx[44] = xx[1] * (xx[53] + xx[40] * xx[41]) + xx[25];\n  pm_math_Quaternion_xform_ra(xx + 29, xx + 42, xx + 23);\n  xx[37] = pm_math_Vector3_dot_ra(xx + 26, xx + 61) + pm_math_Vector3_dot_ra(xx\n    + 71, xx + 78);\n  xx[38] = pm_math_Vector3_dot_ra(xx + 81, xx + 84) + pm_math_Vector3_dot_ra(xx\n    + 67, xx + 87);\n  xx[39] = pm_math_Vector3_dot_ra(xx + 90, xx + 93) + pm_math_Vector3_dot_ra(xx\n    + 58, xx + 47);\n  xx[40] = xx[2] + xx[1] * (xx[13] * xx[116] + xx[64]) + xx[10] - (xx[1] * (xx\n    [74] - xx[18] * xx[54]) - xx[19] + xx[7] + xx[1] * (xx[22] * xx[99] + xx[55])\n    + xx[0] + xx[23]);\n  xx[41] = xx[1] * (xx[14] * xx[116] + xx[65]) - xx[9] + xx[11] - (xx[1] * (xx\n    [75] - xx[20] * xx[54]) + xx[17] + xx[1] * (xx[34] * xx[99] + xx[56]) - xx[6]\n    + xx[4] + xx[24]);\n  xx[42] = xx[1] * (xx[66] - xx[16] * xx[116]) + xx[12] - (xx[1] * (xx[76] + xx\n    [21] * xx[54]) + xx[1] * (xx[57] - xx[36] * xx[99]) + xx[5] + xx[25]);\n  zeroMajor(1, 6, ii + 0, xx + 37);\n  xx[0] = fabs(xx[37]);\n  xx[1] = fabs(xx[38]);\n  xx[2] = fabs(xx[39]);\n  xx[3] = fabs(xx[40]);\n  xx[4] = fabs(xx[41]);\n  xx[5] = fabs(xx[42]);\n  ii[0] = 0;\n\n  {\n    int ll;\n    for (ll = 1; ll < 6; ++ll)\n      if (xx[ll] > xx[ii[0]])\n        ii[0] = ll;\n  }\n\n  ii[0] -= 0;\n  xx[6] = xx[0 + (ii[0])];\n  if (xx[6] > xx[15]) {\n    const char *msgs[] = {\n      \"Impulses to satisfy the velocity components of the kinematic constraint equations of the joints transitioning from disengaged to normal mode cannot be computed. This is either because the mechanism has insufficient non-motion input degrees-of-freedom available for the required instantaneous velocity change, or, after the position components of the kinematic constraint equations of the mechanism were satisfied, the velocity of the mechanism is incompatible with the new positio\",\n      \"n of the mechanism. Consider increasing the number of non-motion actuated degrees-of-freedom, or reducing the position errors in the transitioning joints before attempting the transition.\"\n    };\n\n    char msg[668];\n    return sm_ssci_recordRunTimeErrorSegmented(\n      \"physmod:sm:core:compiler:mechanism:mechanism:jointDisToNormVelocitySatisfactionFailure\",\n      2, msgs, msg, neDiagMgr);\n  }\n\n  state[0] = xx[120];\n  state[1] = xx[121];\n  state[2] = xx[122];\n  state[3] = xx[123];\n  state[4] = xx[124];\n  state[5] = xx[125];\n  state[6] = xx[126];\n  state[7] = xx[127];\n  state[8] = xx[128];\n  state[9] = xx[129];\n  state[10] = xx[130];\n  state[11] = xx[131];\n  state[12] = xx[132];\n  state[13] = xx[133];\n  state[14] = xx[134];\n  state[15] = xx[135];\n  state[16] = xx[136];\n  state[17] = xx[137];\n  state[18] = xx[138];\n  state[19] = xx[139];\n  state[20] = xx[140];\n  state[21] = xx[141];\n  state[22] = xx[142];\n  state[23] = xx[143];\n  state[24] = xx[144];\n  state[25] = xx[145];\n  state[26] = xx[146];\n  state[27] = xx[147];\n  state[28] = xx[148];\n  state[29] = xx[149];\n  return NULL;\n}\n\nvoid simulation_b048d748_1_onModeChangedCutJoints(const void *mech, const int\n  *prevModeVector, const int *modeVector, double *state)\n{\n  (void) mech;\n  (void) prevModeVector;\n  (void) modeVector;\n  (void) state;\n}\n"},{"name":"ssc_ml_fun.h","type":"header","group":"other","path":"/MATLAB Drive/simulation_ert_rtw","tag":"","groupDisplay":"Other files","code":"// Simscape target specific file.\n//  This file is generated for the Simscape network associated with the solver block 'simulation/Plant/ World Setup/Solver Configuration'.\n\n\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n#ifndef SSC_ML_FUN_H\n#define SSC_ML_FUN_H                   1\n#endif\n\n#ifdef __cplusplus\n\n}\n\n;\n\n#endif\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};